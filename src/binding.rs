/* automatically generated by rust-bindgen 0.69.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const AV_AAC_ADTS_HEADER_SIZE: u32 = 7;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 58;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 29;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const M_Ef: f64 = 2.718281828459045;
pub const M_LN2f: f64 = 0.6931471805599453;
pub const M_LN10f: f64 = 2.302585092994046;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_LOG2_10f: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const M_PHIf: f64 = 1.618033988749895;
pub const M_PIf: f64 = 3.141592653589793;
pub const M_PI_2f: f64 = 1.5707963267948966;
pub const M_PI_4f: f64 = 0.7853981633974483;
pub const M_1_PIf: f64 = 0.3183098861837907;
pub const M_2_PIf: f64 = 0.6366197723675814;
pub const M_2_SQRTPIf: f64 = 1.1283791670955126;
pub const M_SQRT1_2f: f64 = 0.7071067811865476;
pub const M_SQRT2f: f64 = 1.4142135623730951;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_KEY: u32 = 2;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const AV_FRAME_FLAG_INTERLACED: u32 = 8;
pub const AV_FRAME_FLAG_TOP_FIELD_FIRST: u32 = 16;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 60;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const AV_CODEC_CAP_DR1: u32 = 2;
pub const AV_CODEC_CAP_DELAY: u32 = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const AV_CODEC_CAP_SUBFRAMES: u32 = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const AV_CODEC_CAP_OTHER_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: u32 = 131072;
pub const AV_CODEC_CAP_HARDWARE: u32 = 262144;
pub const AV_CODEC_CAP_HYBRID: u32 = 524288;
pub const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE: u32 = 1048576;
pub const AV_CODEC_CAP_ENCODER_FLUSH: u32 = 2097152;
pub const AV_CODEC_CAP_ENCODER_RECON_FRAME: u32 = 4194304;
pub const AV_INPUT_BUFFER_PADDING_SIZE: u32 = 64;
pub const AV_EF_CRCCHECK: u32 = 1;
pub const AV_EF_BITSTREAM: u32 = 2;
pub const AV_EF_BUFFER: u32 = 4;
pub const AV_EF_EXPLODE: u32 = 8;
pub const AV_EF_IGNORE_ERR: u32 = 32768;
pub const AV_EF_CAREFUL: u32 = 65536;
pub const AV_EF_COMPLIANT: u32 = 131072;
pub const AV_EF_AGGRESSIVE: u32 = 262144;
pub const FF_COMPLIANCE_VERY_STRICT: u32 = 2;
pub const FF_COMPLIANCE_STRICT: u32 = 1;
pub const FF_COMPLIANCE_NORMAL: u32 = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: i32 = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: i32 = -2;
pub const AV_PROFILE_UNKNOWN: i32 = -99;
pub const AV_PROFILE_RESERVED: i32 = -100;
pub const AV_PROFILE_AAC_MAIN: u32 = 0;
pub const AV_PROFILE_AAC_LOW: u32 = 1;
pub const AV_PROFILE_AAC_SSR: u32 = 2;
pub const AV_PROFILE_AAC_LTP: u32 = 3;
pub const AV_PROFILE_AAC_HE: u32 = 4;
pub const AV_PROFILE_AAC_HE_V2: u32 = 28;
pub const AV_PROFILE_AAC_LD: u32 = 22;
pub const AV_PROFILE_AAC_ELD: u32 = 38;
pub const AV_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const AV_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const AV_PROFILE_DNXHD: u32 = 0;
pub const AV_PROFILE_DNXHR_LB: u32 = 1;
pub const AV_PROFILE_DNXHR_SQ: u32 = 2;
pub const AV_PROFILE_DNXHR_HQ: u32 = 3;
pub const AV_PROFILE_DNXHR_HQX: u32 = 4;
pub const AV_PROFILE_DNXHR_444: u32 = 5;
pub const AV_PROFILE_DTS: u32 = 20;
pub const AV_PROFILE_DTS_ES: u32 = 30;
pub const AV_PROFILE_DTS_96_24: u32 = 40;
pub const AV_PROFILE_DTS_HD_HRA: u32 = 50;
pub const AV_PROFILE_DTS_HD_MA: u32 = 60;
pub const AV_PROFILE_DTS_EXPRESS: u32 = 70;
pub const AV_PROFILE_DTS_HD_MA_X: u32 = 61;
pub const AV_PROFILE_DTS_HD_MA_X_IMAX: u32 = 62;
pub const AV_PROFILE_EAC3_DDP_ATMOS: u32 = 30;
pub const AV_PROFILE_TRUEHD_ATMOS: u32 = 30;
pub const AV_PROFILE_MPEG2_422: u32 = 0;
pub const AV_PROFILE_MPEG2_HIGH: u32 = 1;
pub const AV_PROFILE_MPEG2_SS: u32 = 2;
pub const AV_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const AV_PROFILE_MPEG2_MAIN: u32 = 4;
pub const AV_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const AV_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const AV_PROFILE_H264_INTRA: u32 = 2048;
pub const AV_PROFILE_H264_BASELINE: u32 = 66;
pub const AV_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const AV_PROFILE_H264_MAIN: u32 = 77;
pub const AV_PROFILE_H264_EXTENDED: u32 = 88;
pub const AV_PROFILE_H264_HIGH: u32 = 100;
pub const AV_PROFILE_H264_HIGH_10: u32 = 110;
pub const AV_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const AV_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const AV_PROFILE_H264_HIGH_422: u32 = 122;
pub const AV_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const AV_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const AV_PROFILE_H264_HIGH_444: u32 = 144;
pub const AV_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const AV_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const AV_PROFILE_H264_CAVLC_444: u32 = 44;
pub const AV_PROFILE_VC1_SIMPLE: u32 = 0;
pub const AV_PROFILE_VC1_MAIN: u32 = 1;
pub const AV_PROFILE_VC1_COMPLEX: u32 = 2;
pub const AV_PROFILE_VC1_ADVANCED: u32 = 3;
pub const AV_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const AV_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const AV_PROFILE_MPEG4_CORE: u32 = 2;
pub const AV_PROFILE_MPEG4_MAIN: u32 = 3;
pub const AV_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const AV_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const AV_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const AV_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const AV_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const AV_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const AV_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const AV_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const AV_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const AV_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const AV_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const AV_PROFILE_VP9_0: u32 = 0;
pub const AV_PROFILE_VP9_1: u32 = 1;
pub const AV_PROFILE_VP9_2: u32 = 2;
pub const AV_PROFILE_VP9_3: u32 = 3;
pub const AV_PROFILE_HEVC_MAIN: u32 = 1;
pub const AV_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const AV_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const AV_PROFILE_HEVC_REXT: u32 = 4;
pub const AV_PROFILE_HEVC_SCC: u32 = 9;
pub const AV_PROFILE_VVC_MAIN_10: u32 = 1;
pub const AV_PROFILE_VVC_MAIN_10_444: u32 = 33;
pub const AV_PROFILE_AV1_MAIN: u32 = 0;
pub const AV_PROFILE_AV1_HIGH: u32 = 1;
pub const AV_PROFILE_AV1_PROFESSIONAL: u32 = 2;
pub const AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: u32 = 192;
pub const AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: u32 = 193;
pub const AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: u32 = 194;
pub const AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS: u32 = 195;
pub const AV_PROFILE_MJPEG_JPEG_LS: u32 = 247;
pub const AV_PROFILE_SBC_MSBC: u32 = 1;
pub const AV_PROFILE_PRORES_PROXY: u32 = 0;
pub const AV_PROFILE_PRORES_LT: u32 = 1;
pub const AV_PROFILE_PRORES_STANDARD: u32 = 2;
pub const AV_PROFILE_PRORES_HQ: u32 = 3;
pub const AV_PROFILE_PRORES_4444: u32 = 4;
pub const AV_PROFILE_PRORES_XQ: u32 = 5;
pub const AV_PROFILE_ARIB_PROFILE_A: u32 = 0;
pub const AV_PROFILE_ARIB_PROFILE_C: u32 = 1;
pub const AV_PROFILE_KLVA_SYNC: u32 = 0;
pub const AV_PROFILE_KLVA_ASYNC: u32 = 1;
pub const AV_PROFILE_EVC_BASELINE: u32 = 0;
pub const AV_PROFILE_EVC_MAIN: u32 = 1;
pub const AV_LEVEL_UNKNOWN: i32 = -99;
pub const AV_PKT_FLAG_KEY: u32 = 1;
pub const AV_PKT_FLAG_CORRUPT: u32 = 2;
pub const AV_PKT_FLAG_DISCARD: u32 = 4;
pub const AV_PKT_FLAG_TRUSTED: u32 = 8;
pub const AV_PKT_FLAG_DISPOSABLE: u32 = 16;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 31;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 102;
pub const AV_CODEC_PROP_INTRA_ONLY: u32 = 1;
pub const AV_CODEC_PROP_LOSSY: u32 = 2;
pub const AV_CODEC_PROP_LOSSLESS: u32 = 4;
pub const AV_CODEC_PROP_REORDER: u32 = 8;
pub const AV_CODEC_PROP_FIELDS: u32 = 16;
pub const AV_CODEC_PROP_BITMAP_SUB: u32 = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: u32 = 131072;
pub const AV_INPUT_BUFFER_MIN_SIZE: u32 = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: u32 = 1;
pub const AV_CODEC_FLAG_QSCALE: u32 = 2;
pub const AV_CODEC_FLAG_4MV: u32 = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const AV_CODEC_FLAG_QPEL: u32 = 16;
pub const AV_CODEC_FLAG_DROPCHANGED: u32 = 32;
pub const AV_CODEC_FLAG_RECON_FRAME: u32 = 64;
pub const AV_CODEC_FLAG_COPY_OPAQUE: u32 = 128;
pub const AV_CODEC_FLAG_FRAME_DURATION: u32 = 256;
pub const AV_CODEC_FLAG_PASS1: u32 = 512;
pub const AV_CODEC_FLAG_PASS2: u32 = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const AV_CODEC_FLAG_GRAY: u32 = 8192;
pub const AV_CODEC_FLAG_PSNR: u32 = 32768;
pub const AV_CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: u32 = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const AV_CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: u32 = 1073741824;
pub const AV_CODEC_FLAG2_ICC_PROFILES: u32 = 2147483648;
pub const AV_CODEC_EXPORT_DATA_MVS: u32 = 1;
pub const AV_CODEC_EXPORT_DATA_PRFT: u32 = 2;
pub const AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS: u32 = 4;
pub const AV_CODEC_EXPORT_DATA_FILM_GRAIN: u32 = 8;
pub const AV_GET_BUFFER_FLAG_REF: u32 = 1;
pub const AV_GET_ENCODE_BUFFER_FLAG_REF: u32 = 1;
pub const FF_COMPRESSION_DEFAULT: i32 = -1;
pub const FF_CMP_SAD: u32 = 0;
pub const FF_CMP_SSE: u32 = 1;
pub const FF_CMP_SATD: u32 = 2;
pub const FF_CMP_DCT: u32 = 3;
pub const FF_CMP_PSNR: u32 = 4;
pub const FF_CMP_BIT: u32 = 5;
pub const FF_CMP_RD: u32 = 6;
pub const FF_CMP_ZERO: u32 = 7;
pub const FF_CMP_VSAD: u32 = 8;
pub const FF_CMP_VSSE: u32 = 9;
pub const FF_CMP_NSSE: u32 = 10;
pub const FF_CMP_W53: u32 = 11;
pub const FF_CMP_W97: u32 = 12;
pub const FF_CMP_DCTMAX: u32 = 13;
pub const FF_CMP_DCT264: u32 = 14;
pub const FF_CMP_MEDIAN_SAD: u32 = 15;
pub const FF_CMP_CHROMA: u32 = 256;
pub const SLICE_FLAG_CODED_ORDER: u32 = 1;
pub const SLICE_FLAG_ALLOW_FIELD: u32 = 2;
pub const SLICE_FLAG_ALLOW_PLANE: u32 = 4;
pub const FF_MB_DECISION_SIMPLE: u32 = 0;
pub const FF_MB_DECISION_BITS: u32 = 1;
pub const FF_MB_DECISION_RD: u32 = 2;
pub const FF_BUG_AUTODETECT: u32 = 1;
pub const FF_BUG_XVID_ILACE: u32 = 4;
pub const FF_BUG_UMP4: u32 = 8;
pub const FF_BUG_NO_PADDING: u32 = 16;
pub const FF_BUG_AMV: u32 = 32;
pub const FF_BUG_QPEL_CHROMA: u32 = 64;
pub const FF_BUG_STD_QPEL: u32 = 128;
pub const FF_BUG_QPEL_CHROMA2: u32 = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: u32 = 512;
pub const FF_BUG_EDGE: u32 = 1024;
pub const FF_BUG_HPEL_CHROMA: u32 = 2048;
pub const FF_BUG_DC_CLIP: u32 = 4096;
pub const FF_BUG_MS: u32 = 8192;
pub const FF_BUG_TRUNCATED: u32 = 16384;
pub const FF_BUG_IEDGE: u32 = 32768;
pub const FF_EC_GUESS_MVS: u32 = 1;
pub const FF_EC_DEBLOCK: u32 = 2;
pub const FF_EC_FAVOR_INTER: u32 = 256;
pub const FF_DEBUG_PICT_INFO: u32 = 1;
pub const FF_DEBUG_RC: u32 = 2;
pub const FF_DEBUG_BITSTREAM: u32 = 4;
pub const FF_DEBUG_MB_TYPE: u32 = 8;
pub const FF_DEBUG_QP: u32 = 16;
pub const FF_DEBUG_DCT_COEFF: u32 = 64;
pub const FF_DEBUG_SKIP: u32 = 128;
pub const FF_DEBUG_STARTCODE: u32 = 256;
pub const FF_DEBUG_ER: u32 = 1024;
pub const FF_DEBUG_MMCO: u32 = 2048;
pub const FF_DEBUG_BUGS: u32 = 4096;
pub const FF_DEBUG_BUFFERS: u32 = 32768;
pub const FF_DEBUG_THREADS: u32 = 65536;
pub const FF_DEBUG_GREEN_MD: u32 = 8388608;
pub const FF_DEBUG_NOMC: u32 = 16777216;
pub const FF_DCT_AUTO: u32 = 0;
pub const FF_DCT_FASTINT: u32 = 1;
pub const FF_DCT_INT: u32 = 2;
pub const FF_DCT_MMX: u32 = 3;
pub const FF_DCT_ALTIVEC: u32 = 5;
pub const FF_DCT_FAAN: u32 = 6;
pub const FF_IDCT_AUTO: u32 = 0;
pub const FF_IDCT_INT: u32 = 1;
pub const FF_IDCT_SIMPLE: u32 = 2;
pub const FF_IDCT_SIMPLEMMX: u32 = 3;
pub const FF_IDCT_ARM: u32 = 7;
pub const FF_IDCT_ALTIVEC: u32 = 8;
pub const FF_IDCT_SIMPLEARM: u32 = 10;
pub const FF_IDCT_XVID: u32 = 14;
pub const FF_IDCT_SIMPLEARMV5TE: u32 = 16;
pub const FF_IDCT_SIMPLEARMV6: u32 = 17;
pub const FF_IDCT_FAAN: u32 = 20;
pub const FF_IDCT_SIMPLENEON: u32 = 22;
pub const FF_IDCT_NONE: u32 = 24;
pub const FF_IDCT_SIMPLEAUTO: u32 = 128;
pub const FF_THREAD_FRAME: u32 = 1;
pub const FF_THREAD_SLICE: u32 = 2;
pub const FF_PROFILE_UNKNOWN: i32 = -99;
pub const FF_PROFILE_RESERVED: i32 = -100;
pub const FF_PROFILE_AAC_MAIN: u32 = 0;
pub const FF_PROFILE_AAC_LOW: u32 = 1;
pub const FF_PROFILE_AAC_SSR: u32 = 2;
pub const FF_PROFILE_AAC_LTP: u32 = 3;
pub const FF_PROFILE_AAC_HE: u32 = 4;
pub const FF_PROFILE_AAC_HE_V2: u32 = 28;
pub const FF_PROFILE_AAC_LD: u32 = 22;
pub const FF_PROFILE_AAC_ELD: u32 = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const FF_PROFILE_DNXHD: u32 = 0;
pub const FF_PROFILE_DNXHR_LB: u32 = 1;
pub const FF_PROFILE_DNXHR_SQ: u32 = 2;
pub const FF_PROFILE_DNXHR_HQ: u32 = 3;
pub const FF_PROFILE_DNXHR_HQX: u32 = 4;
pub const FF_PROFILE_DNXHR_444: u32 = 5;
pub const FF_PROFILE_DTS: u32 = 20;
pub const FF_PROFILE_DTS_ES: u32 = 30;
pub const FF_PROFILE_DTS_96_24: u32 = 40;
pub const FF_PROFILE_DTS_HD_HRA: u32 = 50;
pub const FF_PROFILE_DTS_HD_MA: u32 = 60;
pub const FF_PROFILE_DTS_EXPRESS: u32 = 70;
pub const FF_PROFILE_DTS_HD_MA_X: u32 = 61;
pub const FF_PROFILE_DTS_HD_MA_X_IMAX: u32 = 62;
pub const FF_PROFILE_EAC3_DDP_ATMOS: u32 = 30;
pub const FF_PROFILE_TRUEHD_ATMOS: u32 = 30;
pub const FF_PROFILE_MPEG2_422: u32 = 0;
pub const FF_PROFILE_MPEG2_HIGH: u32 = 1;
pub const FF_PROFILE_MPEG2_SS: u32 = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const FF_PROFILE_MPEG2_MAIN: u32 = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const FF_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const FF_PROFILE_H264_INTRA: u32 = 2048;
pub const FF_PROFILE_H264_BASELINE: u32 = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const FF_PROFILE_H264_MAIN: u32 = 77;
pub const FF_PROFILE_H264_EXTENDED: u32 = 88;
pub const FF_PROFILE_H264_HIGH: u32 = 100;
pub const FF_PROFILE_H264_HIGH_10: u32 = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const FF_PROFILE_H264_HIGH_422: u32 = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const FF_PROFILE_H264_HIGH_444: u32 = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const FF_PROFILE_H264_CAVLC_444: u32 = 44;
pub const FF_PROFILE_VC1_SIMPLE: u32 = 0;
pub const FF_PROFILE_VC1_MAIN: u32 = 1;
pub const FF_PROFILE_VC1_COMPLEX: u32 = 2;
pub const FF_PROFILE_VC1_ADVANCED: u32 = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const FF_PROFILE_MPEG4_CORE: u32 = 2;
pub const FF_PROFILE_MPEG4_MAIN: u32 = 3;
pub const FF_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const FF_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const FF_PROFILE_VP9_0: u32 = 0;
pub const FF_PROFILE_VP9_1: u32 = 1;
pub const FF_PROFILE_VP9_2: u32 = 2;
pub const FF_PROFILE_VP9_3: u32 = 3;
pub const FF_PROFILE_HEVC_MAIN: u32 = 1;
pub const FF_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const FF_PROFILE_HEVC_REXT: u32 = 4;
pub const FF_PROFILE_HEVC_SCC: u32 = 9;
pub const FF_PROFILE_VVC_MAIN_10: u32 = 1;
pub const FF_PROFILE_VVC_MAIN_10_444: u32 = 33;
pub const FF_PROFILE_AV1_MAIN: u32 = 0;
pub const FF_PROFILE_AV1_HIGH: u32 = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: u32 = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: u32 = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: u32 = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: u32 = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: u32 = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: u32 = 247;
pub const FF_PROFILE_SBC_MSBC: u32 = 1;
pub const FF_PROFILE_PRORES_PROXY: u32 = 0;
pub const FF_PROFILE_PRORES_LT: u32 = 1;
pub const FF_PROFILE_PRORES_STANDARD: u32 = 2;
pub const FF_PROFILE_PRORES_HQ: u32 = 3;
pub const FF_PROFILE_PRORES_4444: u32 = 4;
pub const FF_PROFILE_PRORES_XQ: u32 = 5;
pub const FF_PROFILE_ARIB_PROFILE_A: u32 = 0;
pub const FF_PROFILE_ARIB_PROFILE_C: u32 = 1;
pub const FF_PROFILE_KLVA_SYNC: u32 = 0;
pub const FF_PROFILE_KLVA_ASYNC: u32 = 1;
pub const FF_PROFILE_EVC_BASELINE: u32 = 0;
pub const FF_PROFILE_EVC_MAIN: u32 = 1;
pub const FF_LEVEL_UNKNOWN: i32 = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: i32 = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: u32 = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: u32 = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: u32 = 2;
pub const FF_CODEC_PROPERTY_LOSSLESS: u32 = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: u32 = 2;
pub const FF_CODEC_PROPERTY_FILM_GRAIN: u32 = 4;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: u32 = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: u32 = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: u32 = 4;
pub const AV_HWACCEL_FLAG_UNSAFE_OUTPUT: u32 = 8;
pub const AV_SUBTITLE_FLAG_FORCED: u32 = 1;
pub const AV_PARSER_PTS_NB: u32 = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: u32 = 1;
pub const PARSER_FLAG_ONCE: u32 = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: u32 = 4;
pub const PARSER_FLAG_USE_CODEC_TS: u32 = 4096;
pub const AV_OPT_FLAG_ENCODING_PARAM: u32 = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: u32 = 2;
pub const AV_OPT_FLAG_AUDIO_PARAM: u32 = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: u32 = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: u32 = 32;
pub const AV_OPT_FLAG_EXPORT: u32 = 64;
pub const AV_OPT_FLAG_READONLY: u32 = 128;
pub const AV_OPT_FLAG_BSF_PARAM: u32 = 256;
pub const AV_OPT_FLAG_RUNTIME_PARAM: u32 = 32768;
pub const AV_OPT_FLAG_FILTERING_PARAM: u32 = 65536;
pub const AV_OPT_FLAG_DEPRECATED: u32 = 131072;
pub const AV_OPT_FLAG_CHILD_CONSTS: u32 = 262144;
pub const AV_OPT_SEARCH_CHILDREN: u32 = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: u32 = 2;
pub const AV_OPT_ALLOW_NULL: u32 = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: u32 = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: u32 = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: u32 = 2;
pub const MAX_DWT_LEVELS: u32 = 5;
pub const DV_PROFILE_BYTES: u32 = 480;
pub const VORBIS_FLAG_HEADER: u32 = 1;
pub const VORBIS_FLAG_COMMENT: u32 = 2;
pub const VORBIS_FLAG_SETUP: u32 = 4;
pub const LIBAVDEVICE_VERSION_MAJOR: u32 = 60;
pub const LIBAVDEVICE_VERSION_MINOR: u32 = 3;
pub const LIBAVDEVICE_VERSION_MICRO: u32 = 100;
pub const LIBAVFORMAT_VERSION_MAJOR: u32 = 60;
pub const FF_API_R_FRAME_RATE: u32 = 1;
pub const AVIO_SEEKABLE_NORMAL: u32 = 1;
pub const AVIO_SEEKABLE_TIME: u32 = 2;
pub const AVSEEK_SIZE: u32 = 65536;
pub const AVSEEK_FORCE: u32 = 131072;
pub const AVIO_FLAG_READ: u32 = 1;
pub const AVIO_FLAG_WRITE: u32 = 2;
pub const AVIO_FLAG_READ_WRITE: u32 = 3;
pub const AVIO_FLAG_NONBLOCK: u32 = 8;
pub const AVIO_FLAG_DIRECT: u32 = 32768;
pub const LIBAVFORMAT_VERSION_MINOR: u32 = 16;
pub const LIBAVFORMAT_VERSION_MICRO: u32 = 100;
pub const AVPROBE_SCORE_EXTENSION: u32 = 50;
pub const AVPROBE_SCORE_MIME: u32 = 75;
pub const AVPROBE_SCORE_MAX: u32 = 100;
pub const AVPROBE_PADDING_SIZE: u32 = 32;
pub const AVFMT_NOFILE: u32 = 1;
pub const AVFMT_NEEDNUMBER: u32 = 2;
pub const AVFMT_EXPERIMENTAL: u32 = 4;
pub const AVFMT_SHOW_IDS: u32 = 8;
pub const AVFMT_GLOBALHEADER: u32 = 64;
pub const AVFMT_NOTIMESTAMPS: u32 = 128;
pub const AVFMT_GENERIC_INDEX: u32 = 256;
pub const AVFMT_TS_DISCONT: u32 = 512;
pub const AVFMT_VARIABLE_FPS: u32 = 1024;
pub const AVFMT_NODIMENSIONS: u32 = 2048;
pub const AVFMT_NOSTREAMS: u32 = 4096;
pub const AVFMT_NOBINSEARCH: u32 = 8192;
pub const AVFMT_NOGENSEARCH: u32 = 16384;
pub const AVFMT_NO_BYTE_SEEK: u32 = 32768;
pub const AVFMT_ALLOW_FLUSH: u32 = 65536;
pub const AVFMT_TS_NONSTRICT: u32 = 131072;
pub const AVFMT_TS_NEGATIVE: u32 = 262144;
pub const AVFMT_SEEK_TO_PTS: u32 = 67108864;
pub const AVINDEX_KEYFRAME: u32 = 1;
pub const AVINDEX_DISCARD_FRAME: u32 = 2;
pub const AV_DISPOSITION_DEFAULT: u32 = 1;
pub const AV_DISPOSITION_DUB: u32 = 2;
pub const AV_DISPOSITION_ORIGINAL: u32 = 4;
pub const AV_DISPOSITION_COMMENT: u32 = 8;
pub const AV_DISPOSITION_LYRICS: u32 = 16;
pub const AV_DISPOSITION_KARAOKE: u32 = 32;
pub const AV_DISPOSITION_FORCED: u32 = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: u32 = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: u32 = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: u32 = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: u32 = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: u32 = 2048;
pub const AV_DISPOSITION_NON_DIEGETIC: u32 = 4096;
pub const AV_DISPOSITION_CAPTIONS: u32 = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: u32 = 131072;
pub const AV_DISPOSITION_METADATA: u32 = 262144;
pub const AV_DISPOSITION_DEPENDENT: u32 = 524288;
pub const AV_DISPOSITION_STILL_IMAGE: u32 = 1048576;
pub const AV_PTS_WRAP_IGNORE: u32 = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: u32 = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: i32 = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVSTREAM_EVENT_FLAG_NEW_PACKETS: u32 = 2;
pub const AV_PROGRAM_RUNNING: u32 = 1;
pub const AVFMTCTX_NOHEADER: u32 = 1;
pub const AVFMTCTX_UNSEEKABLE: u32 = 2;
pub const AVFMT_FLAG_GENPTS: u32 = 1;
pub const AVFMT_FLAG_IGNIDX: u32 = 2;
pub const AVFMT_FLAG_NONBLOCK: u32 = 4;
pub const AVFMT_FLAG_IGNDTS: u32 = 8;
pub const AVFMT_FLAG_NOFILLIN: u32 = 16;
pub const AVFMT_FLAG_NOPARSE: u32 = 32;
pub const AVFMT_FLAG_NOBUFFER: u32 = 64;
pub const AVFMT_FLAG_CUSTOM_IO: u32 = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: u32 = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: u32 = 512;
pub const AVFMT_FLAG_BITEXACT: u32 = 1024;
pub const AVFMT_FLAG_SORT_DTS: u32 = 65536;
pub const AVFMT_FLAG_FAST_SEEK: u32 = 524288;
pub const AVFMT_FLAG_SHORTEST: u32 = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: u32 = 2097152;
pub const FF_FDEBUG_TS: u32 = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: i32 = -1;
pub const AVFMT_AVOID_NEG_TS_DISABLED: u32 = 0;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: u32 = 2;
pub const AVSEEK_FLAG_BACKWARD: u32 = 1;
pub const AVSEEK_FLAG_BYTE: u32 = 2;
pub const AVSEEK_FLAG_ANY: u32 = 4;
pub const AVSEEK_FLAG_FRAME: u32 = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: u32 = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: u32 = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: u32 = 1;
pub const LIBAVFILTER_VERSION_MAJOR: u32 = 9;
pub const LIBAVFILTER_VERSION_MINOR: u32 = 12;
pub const LIBAVFILTER_VERSION_MICRO: u32 = 100;
pub const AVFILTER_FLAG_DYNAMIC_INPUTS: u32 = 1;
pub const AVFILTER_FLAG_DYNAMIC_OUTPUTS: u32 = 2;
pub const AVFILTER_FLAG_SLICE_THREADS: u32 = 4;
pub const AVFILTER_FLAG_METADATA_ONLY: u32 = 8;
pub const AVFILTER_FLAG_HWDEVICE: u32 = 16;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC: u32 = 65536;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL: u32 = 131072;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE: u32 = 196608;
pub const AVFILTER_THREAD_SLICE: u32 = 1;
pub const AVFILTER_CMD_FLAG_ONE: u32 = 1;
pub const AVFILTER_CMD_FLAG_FAST: u32 = 2;
pub const AV_BUFFERSINK_FLAG_PEEK: u32 = 1;
pub const AV_BUFFERSINK_FLAG_NO_REQUEST: u32 = 2;
pub const AES_CTR_KEY_SIZE: u32 = 16;
pub const AES_CTR_IV_SIZE: u32 = 8;
pub const AV_ESCAPE_FLAG_WHITESPACE: u32 = 1;
pub const AV_ESCAPE_FLAG_STRICT: u32 = 2;
pub const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES: u32 = 4;
pub const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES: u32 = 8;
pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: u32 = 1;
pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: u32 = 2;
pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: u32 = 4;
pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: u32 = 8;
pub const AV_UTF8_FLAG_ACCEPT_ALL: u32 = 7;
pub const AV_BF_ROUNDS: u32 = 16;
pub const AV_BPRINT_SIZE_AUTOMATIC: u32 = 1;
pub const AV_BPRINT_SIZE_COUNT_ONLY: u32 = 0;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: u32 = 1;
pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
pub const AV_CPU_FLAG_MMX2: u32 = 2;
pub const AV_CPU_FLAG_3DNOW: u32 = 4;
pub const AV_CPU_FLAG_SSE: u32 = 8;
pub const AV_CPU_FLAG_SSE2: u32 = 16;
pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const AV_CPU_FLAG_SSE3: u32 = 64;
pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
pub const AV_CPU_FLAG_SSSE3: u32 = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: u32 = 67108864;
pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
pub const AV_CPU_FLAG_SSE4: u32 = 256;
pub const AV_CPU_FLAG_SSE42: u32 = 512;
pub const AV_CPU_FLAG_AESNI: u32 = 524288;
pub const AV_CPU_FLAG_AVX: u32 = 16384;
pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
pub const AV_CPU_FLAG_XOP: u32 = 1024;
pub const AV_CPU_FLAG_FMA4: u32 = 2048;
pub const AV_CPU_FLAG_CMOV: u32 = 4096;
pub const AV_CPU_FLAG_AVX2: u32 = 32768;
pub const AV_CPU_FLAG_FMA3: u32 = 65536;
pub const AV_CPU_FLAG_BMI1: u32 = 131072;
pub const AV_CPU_FLAG_BMI2: u32 = 262144;
pub const AV_CPU_FLAG_AVX512: u32 = 1048576;
pub const AV_CPU_FLAG_AVX512ICL: u32 = 2097152;
pub const AV_CPU_FLAG_SLOW_GATHER: u32 = 33554432;
pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
pub const AV_CPU_FLAG_VSX: u32 = 2;
pub const AV_CPU_FLAG_POWER8: u32 = 4;
pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
pub const AV_CPU_FLAG_ARMV6: u32 = 2;
pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
pub const AV_CPU_FLAG_VFP: u32 = 8;
pub const AV_CPU_FLAG_VFPV3: u32 = 16;
pub const AV_CPU_FLAG_NEON: u32 = 32;
pub const AV_CPU_FLAG_ARMV8: u32 = 64;
pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
pub const AV_CPU_FLAG_DOTPROD: u32 = 256;
pub const AV_CPU_FLAG_I8MM: u32 = 512;
pub const AV_CPU_FLAG_SETEND: u32 = 65536;
pub const AV_CPU_FLAG_MMI: u32 = 1;
pub const AV_CPU_FLAG_MSA: u32 = 2;
pub const AV_CPU_FLAG_LSX: u32 = 1;
pub const AV_CPU_FLAG_LASX: u32 = 2;
pub const AV_CPU_FLAG_RVI: u32 = 1;
pub const AV_CPU_FLAG_RVF: u32 = 2;
pub const AV_CPU_FLAG_RVD: u32 = 4;
pub const AV_CPU_FLAG_RVV_I32: u32 = 8;
pub const AV_CPU_FLAG_RVV_F32: u32 = 16;
pub const AV_CPU_FLAG_RVV_I64: u32 = 32;
pub const AV_CPU_FLAG_RVV_F64: u32 = 64;
pub const AV_CPU_FLAG_RVB_BASIC: u32 = 128;
pub const AV_CPU_FLAG_RVB_ADDR: u32 = 256;
pub const AV_DETECTION_BBOX_LABEL_NAME_MAX_SIZE: u32 = 64;
pub const AV_NUM_DETECTION_BBOX_CLASSIFY: u32 = 4;
pub const AV_DOVI_MAX_PIECES: u32 = 8;
pub const FFMPEG_VERSION: &[u8; 7] = b"n6.1.1\0";
pub const AV_FIFO_FLAG_AUTO_GROW: u32 = 1;
pub const AV_HASH_MAX_SIZE: u32 = 64;
pub const AV_HDR_PLUS_MAX_PAYLOAD_SIZE: u32 = 907;
pub const AV_PIX_FMT_FLAG_BE: u32 = 1;
pub const AV_PIX_FMT_FLAG_PAL: u32 = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: u32 = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: u32 = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: u32 = 16;
pub const AV_PIX_FMT_FLAG_RGB: u32 = 32;
pub const AV_PIX_FMT_FLAG_ALPHA: u32 = 128;
pub const AV_PIX_FMT_FLAG_BAYER: u32 = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: u32 = 512;
pub const FF_LOSS_RESOLUTION: u32 = 1;
pub const FF_LOSS_DEPTH: u32 = 2;
pub const FF_LOSS_COLORSPACE: u32 = 4;
pub const FF_LOSS_ALPHA: u32 = 8;
pub const FF_LOSS_COLORQUANT: u32 = 16;
pub const FF_LOSS_CHROMA: u32 = 32;
pub const FF_LOSS_EXCESS_RESOLUTION: u32 = 64;
pub const FF_LOSS_EXCESS_DEPTH: u32 = 128;
pub const AV_LZO_INPUT_DEPLETED: u32 = 1;
pub const AV_LZO_OUTPUT_FULL: u32 = 2;
pub const AV_LZO_INVALID_BACKPTR: u32 = 4;
pub const AV_LZO_ERROR: u32 = 8;
pub const AV_LZO_INPUT_PADDING: u32 = 8;
pub const AV_LZO_OUTPUT_PADDING: u32 = 12;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const AV_STEREO3D_FLAG_INVERT: u32 = 1;
pub const AV_TIMECODE_STR_SIZE: u32 = 23;
pub const AV_TS_MAX_STRING_SIZE: u32 = 32;
pub const AV_PRI_UUID : & [u8 ; 101] = b"%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\0" ;
pub const AV_PRI_URN_UUID : & [u8 ; 110] = b"urn:uuid:%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\0" ;
pub const AV_UUID_LEN: u32 = 16;
pub const LIBSWRESAMPLE_VERSION_MAJOR: u32 = 4;
pub const LIBSWRESAMPLE_VERSION_MINOR: u32 = 12;
pub const LIBSWRESAMPLE_VERSION_MICRO: u32 = 100;
pub const SWR_FLAG_RESAMPLE: u32 = 1;
pub const LIBSWSCALE_VERSION_MAJOR: u32 = 7;
pub const LIBSWSCALE_VERSION_MINOR: u32 = 5;
pub const LIBSWSCALE_VERSION_MICRO: u32 = 100;
pub const SWS_FAST_BILINEAR: u32 = 1;
pub const SWS_BILINEAR: u32 = 2;
pub const SWS_BICUBIC: u32 = 4;
pub const SWS_X: u32 = 8;
pub const SWS_POINT: u32 = 16;
pub const SWS_AREA: u32 = 32;
pub const SWS_BICUBLIN: u32 = 64;
pub const SWS_GAUSS: u32 = 128;
pub const SWS_SINC: u32 = 256;
pub const SWS_LANCZOS: u32 = 512;
pub const SWS_SPLINE: u32 = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: u32 = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: u32 = 16;
pub const SWS_PARAM_DEFAULT: u32 = 123456;
pub const SWS_PRINT_INFO: u32 = 4096;
pub const SWS_FULL_CHR_H_INT: u32 = 8192;
pub const SWS_FULL_CHR_H_INP: u32 = 16384;
pub const SWS_DIRECT_BGR: u32 = 32768;
pub const SWS_ACCURATE_RND: u32 = 262144;
pub const SWS_BITEXACT: u32 = 524288;
pub const SWS_ERROR_DIFFUSION: u32 = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: u32 = 1;
pub const SWS_CS_FCC: u32 = 4;
pub const SWS_CS_ITU601: u32 = 5;
pub const SWS_CS_ITU624: u32 = 5;
pub const SWS_CS_SMPTE170M: u32 = 5;
pub const SWS_CS_SMPTE240M: u32 = 7;
pub const SWS_CS_DEFAULT: u32 = 5;
pub const SWS_CS_BT2020: u32 = 9;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Extract the bitstream ID and the frame size from AC-3 data."]
    pub fn av_ac3_parse_header(
        buf: *const u8,
        size: usize,
        bitstream_id: *mut u8,
        frame_size: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract the number of samples and frames from AAC data.\n @param[in]  buf     pointer to AAC data buffer\n @param[out] samples Pointer to where number of samples is written\n @param[out] frames  Pointer to where number of frames is written\n @return Returns 0 on success, error code on failure."]
    pub fn av_adts_header_parse(
        buf: *const u8,
        samples: *mut u32,
        frames: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub const AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
pub const AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
pub const AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
pub const AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
pub const AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
pub const AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
pub const AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
pub const AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
pub const AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
pub const AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
pub const AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
pub const AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
pub const AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
pub const AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
pub type AVSampleFormat = ::std::os::raw::c_int;
extern "C" {
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_copy(
        dst: *const *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_set_silence(
        audio_data: *const *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
pub const AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
pub const AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
pub const AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMEDIA_TYPE_NB: AVMediaType = 5;
pub type AVMediaType = ::std::os::raw::c_int;
extern "C" {
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
pub const AV_PICTURE_TYPE_NONE: AVPictureType = 0;
pub const AV_PICTURE_TYPE_I: AVPictureType = 1;
pub const AV_PICTURE_TYPE_P: AVPictureType = 2;
pub const AV_PICTURE_TYPE_B: AVPictureType = 3;
pub const AV_PICTURE_TYPE_S: AVPictureType = 4;
pub const AV_PICTURE_TYPE_SI: AVPictureType = 5;
pub const AV_PICTURE_TYPE_SP: AVPictureType = 6;
pub const AV_PICTURE_TYPE_BI: AVPictureType = 7;
pub type AVPictureType = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl ::std::fmt::Debug for _G_fpos_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_G_fpos_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl ::std::fmt::Debug for _G_fpos64_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_G_fpos64_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl ::std::fmt::Debug for __atomic_wide_counter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__atomic_wide_counter {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __wseq: {:?}, __g1_start: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __wseq , self . __g1_start , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutexattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutexattr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_condattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_condattr_t {{ union }}")
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_attr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_attr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlock_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlock_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlockattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlockattr_t {{ union }}")
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrier_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrier_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrierattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrierattr_t {{ union }}")
    }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_size_mult(a: usize, b: usize, r: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_max_alloc(max: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    pub num: ::std::os::raw::c_int,
    pub den: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    const UNINIT: ::std::mem::MaybeUninit<AVRational> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).den) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: ::std::os::raw::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    const UNINIT: ::std::mem::MaybeUninit<av_intfloat32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
impl ::std::fmt::Debug for av_intfloat32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "av_intfloat32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    const UNINIT: ::std::mem::MaybeUninit<av_intfloat64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
impl ::std::fmt::Debug for av_intfloat64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "av_intfloat64 {{ union }}")
    }
}
pub const AV_ROUND_ZERO: AVRounding = 0;
pub const AV_ROUND_INF: AVRounding = 1;
pub const AV_ROUND_DOWN: AVRounding = 2;
pub const AV_ROUND_UP: AVRounding = 3;
pub const AV_ROUND_NEAR_INF: AVRounding = 5;
pub const AV_ROUND_PASS_MINMAX: AVRounding = 8192;
pub type AVRounding = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
extern "C" {
    pub fn av_bessel_i0(x: f64) -> f64;
}
pub const AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
pub const AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    pub class_name: *const ::std::os::raw::c_char,
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub option: *const AVOption,
    pub version: ::std::os::raw::c_int,
    pub log_level_offset_offset: ::std::os::raw::c_int,
    pub parent_log_context_offset: ::std::os::raw::c_int,
    pub category: AVClassCategory,
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub child_class_iterate: ::std::option::Option<
        unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
    >,
}
#[test]
fn bindgen_test_layout_AVClass() {
    const UNINIT: ::std::mem::MaybeUninit<AVClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVClass>(),
        72usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        ::std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_offset_offset) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_log_context_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_category) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_ranges) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child_next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child_class_iterate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_iterate)
        )
    );
}
extern "C" {
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn av_log_once(
        avcl: *mut ::std::os::raw::c_void,
        initial_level: ::std::os::raw::c_int,
        subsequent_level: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AV_PIX_FMT_NONE: AVPixelFormat = AVPixelFormat(-1);
pub const AV_PIX_FMT_YUV420P: AVPixelFormat = AVPixelFormat(0);
pub const AV_PIX_FMT_YUYV422: AVPixelFormat = AVPixelFormat(1);
pub const AV_PIX_FMT_RGB24: AVPixelFormat = AVPixelFormat(2);
pub const AV_PIX_FMT_BGR24: AVPixelFormat = AVPixelFormat(3);
pub const AV_PIX_FMT_YUV422P: AVPixelFormat = AVPixelFormat(4);
pub const AV_PIX_FMT_YUV444P: AVPixelFormat = AVPixelFormat(5);
pub const AV_PIX_FMT_YUV410P: AVPixelFormat = AVPixelFormat(6);
pub const AV_PIX_FMT_YUV411P: AVPixelFormat = AVPixelFormat(7);
pub const AV_PIX_FMT_GRAY8: AVPixelFormat = AVPixelFormat(8);
pub const AV_PIX_FMT_MONOWHITE: AVPixelFormat = AVPixelFormat(9);
pub const AV_PIX_FMT_MONOBLACK: AVPixelFormat = AVPixelFormat(10);
pub const AV_PIX_FMT_PAL8: AVPixelFormat = AVPixelFormat(11);
pub const AV_PIX_FMT_YUVJ420P: AVPixelFormat = AVPixelFormat(12);
pub const AV_PIX_FMT_YUVJ422P: AVPixelFormat = AVPixelFormat(13);
pub const AV_PIX_FMT_YUVJ444P: AVPixelFormat = AVPixelFormat(14);
pub const AV_PIX_FMT_UYVY422: AVPixelFormat = AVPixelFormat(15);
pub const AV_PIX_FMT_UYYVYY411: AVPixelFormat = AVPixelFormat(16);
pub const AV_PIX_FMT_BGR8: AVPixelFormat = AVPixelFormat(17);
pub const AV_PIX_FMT_BGR4: AVPixelFormat = AVPixelFormat(18);
pub const AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = AVPixelFormat(19);
pub const AV_PIX_FMT_RGB8: AVPixelFormat = AVPixelFormat(20);
pub const AV_PIX_FMT_RGB4: AVPixelFormat = AVPixelFormat(21);
pub const AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = AVPixelFormat(22);
pub const AV_PIX_FMT_NV12: AVPixelFormat = AVPixelFormat(23);
pub const AV_PIX_FMT_NV21: AVPixelFormat = AVPixelFormat(24);
pub const AV_PIX_FMT_ARGB: AVPixelFormat = AVPixelFormat(25);
pub const AV_PIX_FMT_RGBA: AVPixelFormat = AVPixelFormat(26);
pub const AV_PIX_FMT_ABGR: AVPixelFormat = AVPixelFormat(27);
pub const AV_PIX_FMT_BGRA: AVPixelFormat = AVPixelFormat(28);
pub const AV_PIX_FMT_GRAY16BE: AVPixelFormat = AVPixelFormat(29);
pub const AV_PIX_FMT_GRAY16LE: AVPixelFormat = AVPixelFormat(30);
pub const AV_PIX_FMT_YUV440P: AVPixelFormat = AVPixelFormat(31);
pub const AV_PIX_FMT_YUVJ440P: AVPixelFormat = AVPixelFormat(32);
pub const AV_PIX_FMT_YUVA420P: AVPixelFormat = AVPixelFormat(33);
pub const AV_PIX_FMT_RGB48BE: AVPixelFormat = AVPixelFormat(34);
pub const AV_PIX_FMT_RGB48LE: AVPixelFormat = AVPixelFormat(35);
pub const AV_PIX_FMT_RGB565BE: AVPixelFormat = AVPixelFormat(36);
pub const AV_PIX_FMT_RGB565LE: AVPixelFormat = AVPixelFormat(37);
pub const AV_PIX_FMT_RGB555BE: AVPixelFormat = AVPixelFormat(38);
pub const AV_PIX_FMT_RGB555LE: AVPixelFormat = AVPixelFormat(39);
pub const AV_PIX_FMT_BGR565BE: AVPixelFormat = AVPixelFormat(40);
pub const AV_PIX_FMT_BGR565LE: AVPixelFormat = AVPixelFormat(41);
pub const AV_PIX_FMT_BGR555BE: AVPixelFormat = AVPixelFormat(42);
pub const AV_PIX_FMT_BGR555LE: AVPixelFormat = AVPixelFormat(43);
pub const AV_PIX_FMT_VAAPI: AVPixelFormat = AVPixelFormat(44);
pub const AV_PIX_FMT_YUV420P16LE: AVPixelFormat = AVPixelFormat(45);
pub const AV_PIX_FMT_YUV420P16BE: AVPixelFormat = AVPixelFormat(46);
pub const AV_PIX_FMT_YUV422P16LE: AVPixelFormat = AVPixelFormat(47);
pub const AV_PIX_FMT_YUV422P16BE: AVPixelFormat = AVPixelFormat(48);
pub const AV_PIX_FMT_YUV444P16LE: AVPixelFormat = AVPixelFormat(49);
pub const AV_PIX_FMT_YUV444P16BE: AVPixelFormat = AVPixelFormat(50);
pub const AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = AVPixelFormat(51);
pub const AV_PIX_FMT_RGB444LE: AVPixelFormat = AVPixelFormat(52);
pub const AV_PIX_FMT_RGB444BE: AVPixelFormat = AVPixelFormat(53);
pub const AV_PIX_FMT_BGR444LE: AVPixelFormat = AVPixelFormat(54);
pub const AV_PIX_FMT_BGR444BE: AVPixelFormat = AVPixelFormat(55);
pub const AV_PIX_FMT_YA8: AVPixelFormat = AVPixelFormat(56);
pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat(56);
pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat(56);
pub const AV_PIX_FMT_BGR48BE: AVPixelFormat = AVPixelFormat(57);
pub const AV_PIX_FMT_BGR48LE: AVPixelFormat = AVPixelFormat(58);
pub const AV_PIX_FMT_YUV420P9BE: AVPixelFormat = AVPixelFormat(59);
pub const AV_PIX_FMT_YUV420P9LE: AVPixelFormat = AVPixelFormat(60);
pub const AV_PIX_FMT_YUV420P10BE: AVPixelFormat = AVPixelFormat(61);
pub const AV_PIX_FMT_YUV420P10LE: AVPixelFormat = AVPixelFormat(62);
pub const AV_PIX_FMT_YUV422P10BE: AVPixelFormat = AVPixelFormat(63);
pub const AV_PIX_FMT_YUV422P10LE: AVPixelFormat = AVPixelFormat(64);
pub const AV_PIX_FMT_YUV444P9BE: AVPixelFormat = AVPixelFormat(65);
pub const AV_PIX_FMT_YUV444P9LE: AVPixelFormat = AVPixelFormat(66);
pub const AV_PIX_FMT_YUV444P10BE: AVPixelFormat = AVPixelFormat(67);
pub const AV_PIX_FMT_YUV444P10LE: AVPixelFormat = AVPixelFormat(68);
pub const AV_PIX_FMT_YUV422P9BE: AVPixelFormat = AVPixelFormat(69);
pub const AV_PIX_FMT_YUV422P9LE: AVPixelFormat = AVPixelFormat(70);
pub const AV_PIX_FMT_GBRP: AVPixelFormat = AVPixelFormat(71);
pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat(71);
pub const AV_PIX_FMT_GBRP9BE: AVPixelFormat = AVPixelFormat(72);
pub const AV_PIX_FMT_GBRP9LE: AVPixelFormat = AVPixelFormat(73);
pub const AV_PIX_FMT_GBRP10BE: AVPixelFormat = AVPixelFormat(74);
pub const AV_PIX_FMT_GBRP10LE: AVPixelFormat = AVPixelFormat(75);
pub const AV_PIX_FMT_GBRP16BE: AVPixelFormat = AVPixelFormat(76);
pub const AV_PIX_FMT_GBRP16LE: AVPixelFormat = AVPixelFormat(77);
pub const AV_PIX_FMT_YUVA422P: AVPixelFormat = AVPixelFormat(78);
pub const AV_PIX_FMT_YUVA444P: AVPixelFormat = AVPixelFormat(79);
pub const AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = AVPixelFormat(80);
pub const AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = AVPixelFormat(81);
pub const AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = AVPixelFormat(82);
pub const AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = AVPixelFormat(83);
pub const AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = AVPixelFormat(84);
pub const AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = AVPixelFormat(85);
pub const AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = AVPixelFormat(86);
pub const AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = AVPixelFormat(87);
pub const AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = AVPixelFormat(88);
pub const AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = AVPixelFormat(89);
pub const AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = AVPixelFormat(90);
pub const AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = AVPixelFormat(91);
pub const AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = AVPixelFormat(92);
pub const AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = AVPixelFormat(93);
pub const AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = AVPixelFormat(94);
pub const AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = AVPixelFormat(95);
pub const AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = AVPixelFormat(96);
pub const AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = AVPixelFormat(97);
pub const AV_PIX_FMT_VDPAU: AVPixelFormat = AVPixelFormat(98);
pub const AV_PIX_FMT_XYZ12LE: AVPixelFormat = AVPixelFormat(99);
pub const AV_PIX_FMT_XYZ12BE: AVPixelFormat = AVPixelFormat(100);
pub const AV_PIX_FMT_NV16: AVPixelFormat = AVPixelFormat(101);
pub const AV_PIX_FMT_NV20LE: AVPixelFormat = AVPixelFormat(102);
pub const AV_PIX_FMT_NV20BE: AVPixelFormat = AVPixelFormat(103);
pub const AV_PIX_FMT_RGBA64BE: AVPixelFormat = AVPixelFormat(104);
pub const AV_PIX_FMT_RGBA64LE: AVPixelFormat = AVPixelFormat(105);
pub const AV_PIX_FMT_BGRA64BE: AVPixelFormat = AVPixelFormat(106);
pub const AV_PIX_FMT_BGRA64LE: AVPixelFormat = AVPixelFormat(107);
pub const AV_PIX_FMT_YVYU422: AVPixelFormat = AVPixelFormat(108);
pub const AV_PIX_FMT_YA16BE: AVPixelFormat = AVPixelFormat(109);
pub const AV_PIX_FMT_YA16LE: AVPixelFormat = AVPixelFormat(110);
pub const AV_PIX_FMT_GBRAP: AVPixelFormat = AVPixelFormat(111);
pub const AV_PIX_FMT_GBRAP16BE: AVPixelFormat = AVPixelFormat(112);
pub const AV_PIX_FMT_GBRAP16LE: AVPixelFormat = AVPixelFormat(113);
pub const AV_PIX_FMT_QSV: AVPixelFormat = AVPixelFormat(114);
pub const AV_PIX_FMT_MMAL: AVPixelFormat = AVPixelFormat(115);
pub const AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = AVPixelFormat(116);
pub const AV_PIX_FMT_CUDA: AVPixelFormat = AVPixelFormat(117);
pub const AV_PIX_FMT_0RGB: AVPixelFormat = AVPixelFormat(118);
pub const AV_PIX_FMT_RGB0: AVPixelFormat = AVPixelFormat(119);
pub const AV_PIX_FMT_0BGR: AVPixelFormat = AVPixelFormat(120);
pub const AV_PIX_FMT_BGR0: AVPixelFormat = AVPixelFormat(121);
pub const AV_PIX_FMT_YUV420P12BE: AVPixelFormat = AVPixelFormat(122);
pub const AV_PIX_FMT_YUV420P12LE: AVPixelFormat = AVPixelFormat(123);
pub const AV_PIX_FMT_YUV420P14BE: AVPixelFormat = AVPixelFormat(124);
pub const AV_PIX_FMT_YUV420P14LE: AVPixelFormat = AVPixelFormat(125);
pub const AV_PIX_FMT_YUV422P12BE: AVPixelFormat = AVPixelFormat(126);
pub const AV_PIX_FMT_YUV422P12LE: AVPixelFormat = AVPixelFormat(127);
pub const AV_PIX_FMT_YUV422P14BE: AVPixelFormat = AVPixelFormat(128);
pub const AV_PIX_FMT_YUV422P14LE: AVPixelFormat = AVPixelFormat(129);
pub const AV_PIX_FMT_YUV444P12BE: AVPixelFormat = AVPixelFormat(130);
pub const AV_PIX_FMT_YUV444P12LE: AVPixelFormat = AVPixelFormat(131);
pub const AV_PIX_FMT_YUV444P14BE: AVPixelFormat = AVPixelFormat(132);
pub const AV_PIX_FMT_YUV444P14LE: AVPixelFormat = AVPixelFormat(133);
pub const AV_PIX_FMT_GBRP12BE: AVPixelFormat = AVPixelFormat(134);
pub const AV_PIX_FMT_GBRP12LE: AVPixelFormat = AVPixelFormat(135);
pub const AV_PIX_FMT_GBRP14BE: AVPixelFormat = AVPixelFormat(136);
pub const AV_PIX_FMT_GBRP14LE: AVPixelFormat = AVPixelFormat(137);
pub const AV_PIX_FMT_YUVJ411P: AVPixelFormat = AVPixelFormat(138);
pub const AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = AVPixelFormat(139);
pub const AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = AVPixelFormat(140);
pub const AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = AVPixelFormat(141);
pub const AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = AVPixelFormat(142);
pub const AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = AVPixelFormat(143);
pub const AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = AVPixelFormat(144);
pub const AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = AVPixelFormat(145);
pub const AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = AVPixelFormat(146);
pub const AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = AVPixelFormat(147);
pub const AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = AVPixelFormat(148);
pub const AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = AVPixelFormat(149);
pub const AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = AVPixelFormat(150);
pub const AV_PIX_FMT_XVMC: AVPixelFormat = AVPixelFormat(151);
pub const AV_PIX_FMT_YUV440P10LE: AVPixelFormat = AVPixelFormat(152);
pub const AV_PIX_FMT_YUV440P10BE: AVPixelFormat = AVPixelFormat(153);
pub const AV_PIX_FMT_YUV440P12LE: AVPixelFormat = AVPixelFormat(154);
pub const AV_PIX_FMT_YUV440P12BE: AVPixelFormat = AVPixelFormat(155);
pub const AV_PIX_FMT_AYUV64LE: AVPixelFormat = AVPixelFormat(156);
pub const AV_PIX_FMT_AYUV64BE: AVPixelFormat = AVPixelFormat(157);
pub const AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = AVPixelFormat(158);
pub const AV_PIX_FMT_P010LE: AVPixelFormat = AVPixelFormat(159);
pub const AV_PIX_FMT_P010BE: AVPixelFormat = AVPixelFormat(160);
pub const AV_PIX_FMT_GBRAP12BE: AVPixelFormat = AVPixelFormat(161);
pub const AV_PIX_FMT_GBRAP12LE: AVPixelFormat = AVPixelFormat(162);
pub const AV_PIX_FMT_GBRAP10BE: AVPixelFormat = AVPixelFormat(163);
pub const AV_PIX_FMT_GBRAP10LE: AVPixelFormat = AVPixelFormat(164);
pub const AV_PIX_FMT_MEDIACODEC: AVPixelFormat = AVPixelFormat(165);
pub const AV_PIX_FMT_GRAY12BE: AVPixelFormat = AVPixelFormat(166);
pub const AV_PIX_FMT_GRAY12LE: AVPixelFormat = AVPixelFormat(167);
pub const AV_PIX_FMT_GRAY10BE: AVPixelFormat = AVPixelFormat(168);
pub const AV_PIX_FMT_GRAY10LE: AVPixelFormat = AVPixelFormat(169);
pub const AV_PIX_FMT_P016LE: AVPixelFormat = AVPixelFormat(170);
pub const AV_PIX_FMT_P016BE: AVPixelFormat = AVPixelFormat(171);
pub const AV_PIX_FMT_D3D11: AVPixelFormat = AVPixelFormat(172);
pub const AV_PIX_FMT_GRAY9BE: AVPixelFormat = AVPixelFormat(173);
pub const AV_PIX_FMT_GRAY9LE: AVPixelFormat = AVPixelFormat(174);
pub const AV_PIX_FMT_GBRPF32BE: AVPixelFormat = AVPixelFormat(175);
pub const AV_PIX_FMT_GBRPF32LE: AVPixelFormat = AVPixelFormat(176);
pub const AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = AVPixelFormat(177);
pub const AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = AVPixelFormat(178);
pub const AV_PIX_FMT_DRM_PRIME: AVPixelFormat = AVPixelFormat(179);
pub const AV_PIX_FMT_OPENCL: AVPixelFormat = AVPixelFormat(180);
pub const AV_PIX_FMT_GRAY14BE: AVPixelFormat = AVPixelFormat(181);
pub const AV_PIX_FMT_GRAY14LE: AVPixelFormat = AVPixelFormat(182);
pub const AV_PIX_FMT_GRAYF32BE: AVPixelFormat = AVPixelFormat(183);
pub const AV_PIX_FMT_GRAYF32LE: AVPixelFormat = AVPixelFormat(184);
pub const AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = AVPixelFormat(185);
pub const AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = AVPixelFormat(186);
pub const AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = AVPixelFormat(187);
pub const AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = AVPixelFormat(188);
pub const AV_PIX_FMT_NV24: AVPixelFormat = AVPixelFormat(189);
pub const AV_PIX_FMT_NV42: AVPixelFormat = AVPixelFormat(190);
pub const AV_PIX_FMT_VULKAN: AVPixelFormat = AVPixelFormat(191);
pub const AV_PIX_FMT_Y210BE: AVPixelFormat = AVPixelFormat(192);
pub const AV_PIX_FMT_Y210LE: AVPixelFormat = AVPixelFormat(193);
pub const AV_PIX_FMT_X2RGB10LE: AVPixelFormat = AVPixelFormat(194);
pub const AV_PIX_FMT_X2RGB10BE: AVPixelFormat = AVPixelFormat(195);
pub const AV_PIX_FMT_X2BGR10LE: AVPixelFormat = AVPixelFormat(196);
pub const AV_PIX_FMT_X2BGR10BE: AVPixelFormat = AVPixelFormat(197);
pub const AV_PIX_FMT_P210BE: AVPixelFormat = AVPixelFormat(198);
pub const AV_PIX_FMT_P210LE: AVPixelFormat = AVPixelFormat(199);
pub const AV_PIX_FMT_P410BE: AVPixelFormat = AVPixelFormat(200);
pub const AV_PIX_FMT_P410LE: AVPixelFormat = AVPixelFormat(201);
pub const AV_PIX_FMT_P216BE: AVPixelFormat = AVPixelFormat(202);
pub const AV_PIX_FMT_P216LE: AVPixelFormat = AVPixelFormat(203);
pub const AV_PIX_FMT_P416BE: AVPixelFormat = AVPixelFormat(204);
pub const AV_PIX_FMT_P416LE: AVPixelFormat = AVPixelFormat(205);
pub const AV_PIX_FMT_VUYA: AVPixelFormat = AVPixelFormat(206);
pub const AV_PIX_FMT_RGBAF16BE: AVPixelFormat = AVPixelFormat(207);
pub const AV_PIX_FMT_RGBAF16LE: AVPixelFormat = AVPixelFormat(208);
pub const AV_PIX_FMT_VUYX: AVPixelFormat = AVPixelFormat(209);
pub const AV_PIX_FMT_P012LE: AVPixelFormat = AVPixelFormat(210);
pub const AV_PIX_FMT_P012BE: AVPixelFormat = AVPixelFormat(211);
pub const AV_PIX_FMT_Y212BE: AVPixelFormat = AVPixelFormat(212);
pub const AV_PIX_FMT_Y212LE: AVPixelFormat = AVPixelFormat(213);
pub const AV_PIX_FMT_XV30BE: AVPixelFormat = AVPixelFormat(214);
pub const AV_PIX_FMT_XV30LE: AVPixelFormat = AVPixelFormat(215);
pub const AV_PIX_FMT_XV36BE: AVPixelFormat = AVPixelFormat(216);
pub const AV_PIX_FMT_XV36LE: AVPixelFormat = AVPixelFormat(217);
pub const AV_PIX_FMT_RGBF32BE: AVPixelFormat = AVPixelFormat(218);
pub const AV_PIX_FMT_RGBF32LE: AVPixelFormat = AVPixelFormat(219);
pub const AV_PIX_FMT_RGBAF32BE: AVPixelFormat = AVPixelFormat(220);
pub const AV_PIX_FMT_RGBAF32LE: AVPixelFormat = AVPixelFormat(221);
pub const AV_PIX_FMT_P212BE: AVPixelFormat = AVPixelFormat(222);
pub const AV_PIX_FMT_P212LE: AVPixelFormat = AVPixelFormat(223);
pub const AV_PIX_FMT_P412BE: AVPixelFormat = AVPixelFormat(224);
pub const AV_PIX_FMT_P412LE: AVPixelFormat = AVPixelFormat(225);
pub const AV_PIX_FMT_GBRAP14BE: AVPixelFormat = AVPixelFormat(226);
pub const AV_PIX_FMT_GBRAP14LE: AVPixelFormat = AVPixelFormat(227);
pub const AV_PIX_FMT_NB: AVPixelFormat = AVPixelFormat(228);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AVPixelFormat(pub ::std::os::raw::c_int);
pub const AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
pub const AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
pub const AVCOL_PRI_BT470M: AVColorPrimaries = 4;
pub const AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
pub const AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
pub const AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
pub const AVCOL_PRI_FILM: AVColorPrimaries = 8;
pub const AVCOL_PRI_BT2020: AVColorPrimaries = 9;
pub const AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
pub const AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
pub const AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
pub const AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
pub const AVCOL_PRI_NB: AVColorPrimaries = 23;
pub type AVColorPrimaries = ::std::os::raw::c_uint;
pub const AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
pub const AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
pub const AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
pub const AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
pub const AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
pub const AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
pub const AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
pub const AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
pub const AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
pub const AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
pub const AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
pub const AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
pub const AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
pub const AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
pub const AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
pub const AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
pub const AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
pub const AVCOL_SPC_RGB: AVColorSpace = 0;
pub const AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVCOL_SPC_RESERVED: AVColorSpace = 3;
pub const AVCOL_SPC_FCC: AVColorSpace = 4;
pub const AVCOL_SPC_BT470BG: AVColorSpace = 5;
pub const AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
pub const AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
pub const AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVCOL_SPC_YCOCG: AVColorSpace = 8;
pub const AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
pub const AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
pub const AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
pub const AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
pub const AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
pub const AVCOL_SPC_ICTCP: AVColorSpace = 14;
pub const AVCOL_SPC_NB: AVColorSpace = 15;
pub type AVColorSpace = ::std::os::raw::c_uint;
pub const AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
pub const AVCOL_RANGE_MPEG: AVColorRange = 1;
pub const AVCOL_RANGE_JPEG: AVColorRange = 2;
pub const AVCOL_RANGE_NB: AVColorRange = 3;
pub type AVColorRange = ::std::os::raw::c_uint;
pub const AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
pub const AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
pub const AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
pub const AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
pub const AVCHROMA_LOC_NB: AVChromaLocation = 7;
pub type AVChromaLocation = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    const UNINIT: ::std::mem::MaybeUninit<AVBufferRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBufferRef>(),
        24usize,
        concat!("Size of: ", stringify!(AVBufferRef))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn av_buffer_alloc(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(
        data: *mut u8,
        size: usize,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    pub fn av_buffer_ref(buf: *const AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_replace(
        dst: *mut *mut AVBufferRef,
        src: *const AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(
        size: usize,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(
        size: usize,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_pool_buffer_get_opaque(
        ref_: *const AVBufferRef,
    ) -> *mut ::std::os::raw::c_void;
}
pub const AV_CHAN_NONE: AVChannel = -1;
pub const AV_CHAN_FRONT_LEFT: AVChannel = 0;
pub const AV_CHAN_FRONT_RIGHT: AVChannel = 1;
pub const AV_CHAN_FRONT_CENTER: AVChannel = 2;
pub const AV_CHAN_LOW_FREQUENCY: AVChannel = 3;
pub const AV_CHAN_BACK_LEFT: AVChannel = 4;
pub const AV_CHAN_BACK_RIGHT: AVChannel = 5;
pub const AV_CHAN_FRONT_LEFT_OF_CENTER: AVChannel = 6;
pub const AV_CHAN_FRONT_RIGHT_OF_CENTER: AVChannel = 7;
pub const AV_CHAN_BACK_CENTER: AVChannel = 8;
pub const AV_CHAN_SIDE_LEFT: AVChannel = 9;
pub const AV_CHAN_SIDE_RIGHT: AVChannel = 10;
pub const AV_CHAN_TOP_CENTER: AVChannel = 11;
pub const AV_CHAN_TOP_FRONT_LEFT: AVChannel = 12;
pub const AV_CHAN_TOP_FRONT_CENTER: AVChannel = 13;
pub const AV_CHAN_TOP_FRONT_RIGHT: AVChannel = 14;
pub const AV_CHAN_TOP_BACK_LEFT: AVChannel = 15;
pub const AV_CHAN_TOP_BACK_CENTER: AVChannel = 16;
pub const AV_CHAN_TOP_BACK_RIGHT: AVChannel = 17;
pub const AV_CHAN_STEREO_LEFT: AVChannel = 29;
pub const AV_CHAN_STEREO_RIGHT: AVChannel = 30;
pub const AV_CHAN_WIDE_LEFT: AVChannel = 31;
pub const AV_CHAN_WIDE_RIGHT: AVChannel = 32;
pub const AV_CHAN_SURROUND_DIRECT_LEFT: AVChannel = 33;
pub const AV_CHAN_SURROUND_DIRECT_RIGHT: AVChannel = 34;
pub const AV_CHAN_LOW_FREQUENCY_2: AVChannel = 35;
pub const AV_CHAN_TOP_SIDE_LEFT: AVChannel = 36;
pub const AV_CHAN_TOP_SIDE_RIGHT: AVChannel = 37;
pub const AV_CHAN_BOTTOM_FRONT_CENTER: AVChannel = 38;
pub const AV_CHAN_BOTTOM_FRONT_LEFT: AVChannel = 39;
pub const AV_CHAN_BOTTOM_FRONT_RIGHT: AVChannel = 40;
pub const AV_CHAN_UNUSED: AVChannel = 512;
pub const AV_CHAN_UNKNOWN: AVChannel = 768;
pub const AV_CHAN_AMBISONIC_BASE: AVChannel = 1024;
pub const AV_CHAN_AMBISONIC_END: AVChannel = 2047;
pub type AVChannel = ::std::os::raw::c_int;
pub const AV_CHANNEL_ORDER_UNSPEC: AVChannelOrder = 0;
pub const AV_CHANNEL_ORDER_NATIVE: AVChannelOrder = 1;
pub const AV_CHANNEL_ORDER_CUSTOM: AVChannelOrder = 2;
pub const AV_CHANNEL_ORDER_AMBISONIC: AVChannelOrder = 3;
pub type AVChannelOrder = ::std::os::raw::c_uint;
pub const AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChannelCustom {
    pub id: AVChannel,
    pub name: [::std::os::raw::c_char; 16usize],
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AVChannelCustom() {
    const UNINIT: ::std::mem::MaybeUninit<AVChannelCustom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVChannelCustom>(),
        32usize,
        concat!("Size of: ", stringify!(AVChannelCustom))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelCustom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelCustom),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVChannelLayout {
    pub order: AVChannelOrder,
    pub nb_channels: ::std::os::raw::c_int,
    pub u: AVChannelLayout__bindgen_ty_1,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVChannelLayout__bindgen_ty_1 {
    pub mask: u64,
    pub map: *mut AVChannelCustom,
}
#[test]
fn bindgen_test_layout_AVChannelLayout__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AVChannelLayout__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVChannelLayout__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVChannelLayout__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelLayout__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelLayout__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
}
impl ::std::fmt::Debug for AVChannelLayout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "AVChannelLayout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_AVChannelLayout() {
    const UNINIT: ::std::mem::MaybeUninit<AVChannelLayout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVChannelLayout>(),
        24usize,
        concat!("Size of: ", stringify!(AVChannelLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChannelLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChannelLayout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(nb_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChannelLayout),
            "::",
            stringify!(opaque)
        )
    );
}
impl ::std::fmt::Debug for AVChannelLayout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "AVChannelLayout {{ order: {:?}, nb_channels: {:?}, u: {:?}, opaque: {:?} }}",
            self.order, self.nb_channels, self.u, self.opaque
        )
    }
}
extern "C" {
    pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn av_get_extended_channel_layout(
        name: *const ::std::os::raw::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_channel_layout_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn av_get_channel_layout_channel_index(
        channel_layout: u64,
        channel: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_extract_channel(
        channel_layout: u64,
        index: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_standard_channel_layout(
        index: ::std::os::raw::c_uint,
        layout: *mut u64,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_name(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_name_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    pub fn av_channel_description(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_description_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    pub fn av_channel_from_string(name: *const ::std::os::raw::c_char) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_from_mask(
        channel_layout: *mut AVChannelLayout,
        mask: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_from_string(
        channel_layout: *mut AVChannelLayout,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_default(
        ch_layout: *mut AVChannelLayout,
        nb_channels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_channel_layout_standard(
        opaque: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVChannelLayout;
}
extern "C" {
    pub fn av_channel_layout_uninit(channel_layout: *mut AVChannelLayout);
}
extern "C" {
    pub fn av_channel_layout_copy(
        dst: *mut AVChannelLayout,
        src: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_describe(
        channel_layout: *const AVChannelLayout,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_describe_bprint(
        channel_layout: *const AVChannelLayout,
        bp: *mut AVBPrint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_channel_from_index(
        channel_layout: *const AVChannelLayout,
        idx: ::std::os::raw::c_uint,
    ) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_index_from_channel(
        channel_layout: *const AVChannelLayout,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_index_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_channel_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> AVChannel;
}
extern "C" {
    pub fn av_channel_layout_subset(channel_layout: *const AVChannelLayout, mask: u64) -> u64;
}
extern "C" {
    pub fn av_channel_layout_check(channel_layout: *const AVChannelLayout)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_compare(
        chl: *const AVChannelLayout,
        chl1: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    const UNINIT: ::std::mem::MaybeUninit<AVDictionaryEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDictionaryEntry>(),
        16usize,
        concat!("Size of: ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDictionaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_iterate(
        m: *const AVDictionary,
        prev: *const AVDictionaryEntry,
    ) -> *const AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
pub const AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
pub const AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
pub const AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
pub const AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
pub const AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
pub const AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
pub const AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
pub const AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
pub const AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
pub const AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
pub const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
pub const AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
pub const AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
pub const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
pub const AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
pub const AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 16;
pub const AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 17;
pub const AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 18;
pub const AV_FRAME_DATA_VIDEO_ENC_PARAMS: AVFrameSideDataType = 19;
pub const AV_FRAME_DATA_SEI_UNREGISTERED: AVFrameSideDataType = 20;
pub const AV_FRAME_DATA_FILM_GRAIN_PARAMS: AVFrameSideDataType = 21;
pub const AV_FRAME_DATA_DETECTION_BBOXES: AVFrameSideDataType = 22;
pub const AV_FRAME_DATA_DOVI_RPU_BUFFER: AVFrameSideDataType = 23;
pub const AV_FRAME_DATA_DOVI_METADATA: AVFrameSideDataType = 24;
pub const AV_FRAME_DATA_DYNAMIC_HDR_VIVID: AVFrameSideDataType = 25;
pub const AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: AVFrameSideDataType = 26;
pub const AV_FRAME_DATA_VIDEO_HINT: AVFrameSideDataType = 27;
pub type AVFrameSideDataType = ::std::os::raw::c_uint;
pub const AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: usize,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    const UNINIT: ::std::mem::MaybeUninit<AVFrameSideData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFrameSideData>(),
        40usize,
        concat!("Size of: ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrameSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRegionOfInterest {
    pub self_size: u32,
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub qoffset: AVRational,
}
#[test]
fn bindgen_test_layout_AVRegionOfInterest() {
    const UNINIT: ::std::mem::MaybeUninit<AVRegionOfInterest> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVRegionOfInterest>(),
        28usize,
        concat!("Size of: ", stringify!(AVRegionOfInterest))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRegionOfInterest>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRegionOfInterest))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(self_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qoffset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRegionOfInterest),
            "::",
            stringify!(qoffset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFrame {
    pub data: [*mut u8; 8usize],
    pub linesize: [::std::os::raw::c_int; 8usize],
    pub extended_data: *mut *mut u8,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub nb_samples: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub key_frame: ::std::os::raw::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: i64,
    pub pkt_dts: i64,
    pub time_base: AVRational,
    pub coded_picture_number: ::std::os::raw::c_int,
    pub display_picture_number: ::std::os::raw::c_int,
    pub quality: ::std::os::raw::c_int,
    pub opaque: *mut ::std::os::raw::c_void,
    pub repeat_pict: ::std::os::raw::c_int,
    pub interlaced_frame: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub palette_has_changed: ::std::os::raw::c_int,
    pub reordered_opaque: i64,
    pub sample_rate: ::std::os::raw::c_int,
    pub channel_layout: u64,
    pub buf: [*mut AVBufferRef; 8usize],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: i64,
    pub pkt_pos: i64,
    pub pkt_duration: i64,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub pkt_size: ::std::os::raw::c_int,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub opaque_ref: *mut AVBufferRef,
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    pub private_ref: *mut AVBufferRef,
    pub ch_layout: AVChannelLayout,
    pub duration: i64,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    const UNINIT: ::std::mem::MaybeUninit<AVFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFrame>(),
        480usize,
        concat!("Size of: ", stringify!(AVFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_samples) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_frame) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pict_type) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_dts) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_picture_number) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(coded_picture_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_picture_number) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(display_picture_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat_pict) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced_frame) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(interlaced_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).palette_has_changed) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(palette_has_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reordered_opaque) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_buf) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_extended_buf) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_extended_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).side_data) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_side_data) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_trc) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_location) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).best_effort_timestamp) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(best_effort_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_pos) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_duration) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_error_flags) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(decode_error_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_size) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_frames_ctx) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque_ref) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_top) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_bottom) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_left) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_right) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_ref) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(private_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layout) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(ch_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(duration)
        )
    );
}
impl ::std::fmt::Debug for AVFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVFrame {{ data: {:?}, linesize: {:?}, extended_data: {:?}, width: {:?}, height: {:?}, nb_samples: {:?}, format: {:?}, key_frame: {:?}, pict_type: {:?}, sample_aspect_ratio: {:?}, pts: {:?}, pkt_dts: {:?}, time_base: {:?}, coded_picture_number: {:?}, display_picture_number: {:?}, quality: {:?}, opaque: {:?}, repeat_pict: {:?}, interlaced_frame: {:?}, top_field_first: {:?}, palette_has_changed: {:?}, reordered_opaque: {:?}, sample_rate: {:?}, channel_layout: {:?}, buf: {:?}, extended_buf: {:?}, nb_extended_buf: {:?}, side_data: {:?}, nb_side_data: {:?}, flags: {:?}, color_range: {:?}, color_primaries: {:?}, color_trc: {:?}, colorspace: {:?}, chroma_location: {:?}, best_effort_timestamp: {:?}, pkt_pos: {:?}, pkt_duration: {:?}, metadata: {:?}, decode_error_flags: {:?}, channels: {:?}, pkt_size: {:?}, hw_frames_ctx: {:?}, opaque_ref: {:?}, crop_top: {:?}, crop_bottom: {:?}, crop_left: {:?}, crop_right: {:?}, private_ref: {:?}, ch_layout: {:?}, duration: {:?} }}" , self . data , self . linesize , self . extended_data , self . width , self . height , self . nb_samples , self . format , self . key_frame , self . pict_type , self . sample_aspect_ratio , self . pts , self . pkt_dts , self . time_base , self . coded_picture_number , self . display_picture_number , self . quality , self . opaque , self . repeat_pict , self . interlaced_frame , self . top_field_first , self . palette_has_changed , self . reordered_opaque , self . sample_rate , self . channel_layout , self . buf , self . extended_buf , self . nb_extended_buf , self . side_data , self . nb_side_data , self . flags , self . color_range , self . color_primaries , self . color_trc , self . colorspace , self . chroma_location , self . best_effort_timestamp , self . pkt_pos , self . pkt_duration , self . metadata , self . decode_error_flags , self . channels , self . pkt_size , self . hw_frames_ctx , self . opaque_ref , self . crop_top , self . crop_bottom , self . crop_left , self . crop_right , self . private_ref , self . ch_layout , self . duration)
    }
}
extern "C" {
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_replace(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_plane_buffer(
        frame: *const AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: usize,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
pub const AV_HWDEVICE_TYPE_NONE: AVHWDeviceType = 0;
pub const AV_HWDEVICE_TYPE_VDPAU: AVHWDeviceType = 1;
pub const AV_HWDEVICE_TYPE_CUDA: AVHWDeviceType = 2;
pub const AV_HWDEVICE_TYPE_VAAPI: AVHWDeviceType = 3;
pub const AV_HWDEVICE_TYPE_DXVA2: AVHWDeviceType = 4;
pub const AV_HWDEVICE_TYPE_QSV: AVHWDeviceType = 5;
pub const AV_HWDEVICE_TYPE_VIDEOTOOLBOX: AVHWDeviceType = 6;
pub const AV_HWDEVICE_TYPE_D3D11VA: AVHWDeviceType = 7;
pub const AV_HWDEVICE_TYPE_DRM: AVHWDeviceType = 8;
pub const AV_HWDEVICE_TYPE_OPENCL: AVHWDeviceType = 9;
pub const AV_HWDEVICE_TYPE_MEDIACODEC: AVHWDeviceType = 10;
pub const AV_HWDEVICE_TYPE_VULKAN: AVHWDeviceType = 11;
pub type AVHWDeviceType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWDeviceInternal,
    pub type_: AVHWDeviceType,
    pub hwctx: *mut ::std::os::raw::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    pub user_opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AVHWDeviceContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVHWDeviceContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHWDeviceContext>(),
        48usize,
        concat!("Size of: ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWDeviceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWDeviceContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_opaque) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWDeviceContext),
            "::",
            stringify!(user_opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesContext {
    pub av_class: *const AVClass,
    pub internal: *mut AVHWFramesInternal,
    pub device_ref: *mut AVBufferRef,
    pub device_ctx: *mut AVHWDeviceContext,
    pub hwctx: *mut ::std::os::raw::c_void,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    pub user_opaque: *mut ::std::os::raw::c_void,
    pub pool: *mut AVBufferPool,
    pub initial_pool_size: ::std::os::raw::c_int,
    pub format: AVPixelFormat,
    pub sw_format: AVPixelFormat,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVHWFramesContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesContext>(),
        88usize,
        concat!("Size of: ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_ref) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(device_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwctx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(hwctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_opaque) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(user_opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_pool_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(initial_pool_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_format) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(sw_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesContext),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_find_type_by_name(name: *const ::std::os::raw::c_char) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const ::std::os::raw::c_char,
        opts: *mut AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwdevice_ctx_create_derived_opts(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        options: *mut AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AV_HWFRAME_TRANSFER_DIRECTION_FROM: AVHWFrameTransferDirection = 0;
pub const AV_HWFRAME_TRANSFER_DIRECTION_TO: AVHWFrameTransferDirection = 1;
pub type AVHWFrameTransferDirection = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesConstraints {
    pub valid_hw_formats: *mut AVPixelFormat,
    pub valid_sw_formats: *mut AVPixelFormat,
    pub min_width: ::std::os::raw::c_int,
    pub min_height: ::std::os::raw::c_int,
    pub max_width: ::std::os::raw::c_int,
    pub max_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVHWFramesConstraints() {
    const UNINIT: ::std::mem::MaybeUninit<AVHWFramesConstraints> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHWFramesConstraints>(),
        32usize,
        concat!("Size of: ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWFramesConstraints>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWFramesConstraints))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid_hw_formats) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_hw_formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid_sw_formats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(valid_sw_formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWFramesConstraints),
            "::",
            stringify!(max_height)
        )
    );
}
extern "C" {
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const ::std::os::raw::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_3 = 1;
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_3 = 2;
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_3 = 4;
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const AV_CODEC_ID_NONE: AVCodecID = 0;
pub const AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
pub const AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
pub const AV_CODEC_ID_H261: AVCodecID = 3;
pub const AV_CODEC_ID_H263: AVCodecID = 4;
pub const AV_CODEC_ID_RV10: AVCodecID = 5;
pub const AV_CODEC_ID_RV20: AVCodecID = 6;
pub const AV_CODEC_ID_MJPEG: AVCodecID = 7;
pub const AV_CODEC_ID_MJPEGB: AVCodecID = 8;
pub const AV_CODEC_ID_LJPEG: AVCodecID = 9;
pub const AV_CODEC_ID_SP5X: AVCodecID = 10;
pub const AV_CODEC_ID_JPEGLS: AVCodecID = 11;
pub const AV_CODEC_ID_MPEG4: AVCodecID = 12;
pub const AV_CODEC_ID_RAWVIDEO: AVCodecID = 13;
pub const AV_CODEC_ID_MSMPEG4V1: AVCodecID = 14;
pub const AV_CODEC_ID_MSMPEG4V2: AVCodecID = 15;
pub const AV_CODEC_ID_MSMPEG4V3: AVCodecID = 16;
pub const AV_CODEC_ID_WMV1: AVCodecID = 17;
pub const AV_CODEC_ID_WMV2: AVCodecID = 18;
pub const AV_CODEC_ID_H263P: AVCodecID = 19;
pub const AV_CODEC_ID_H263I: AVCodecID = 20;
pub const AV_CODEC_ID_FLV1: AVCodecID = 21;
pub const AV_CODEC_ID_SVQ1: AVCodecID = 22;
pub const AV_CODEC_ID_SVQ3: AVCodecID = 23;
pub const AV_CODEC_ID_DVVIDEO: AVCodecID = 24;
pub const AV_CODEC_ID_HUFFYUV: AVCodecID = 25;
pub const AV_CODEC_ID_CYUV: AVCodecID = 26;
pub const AV_CODEC_ID_H264: AVCodecID = 27;
pub const AV_CODEC_ID_INDEO3: AVCodecID = 28;
pub const AV_CODEC_ID_VP3: AVCodecID = 29;
pub const AV_CODEC_ID_THEORA: AVCodecID = 30;
pub const AV_CODEC_ID_ASV1: AVCodecID = 31;
pub const AV_CODEC_ID_ASV2: AVCodecID = 32;
pub const AV_CODEC_ID_FFV1: AVCodecID = 33;
pub const AV_CODEC_ID_4XM: AVCodecID = 34;
pub const AV_CODEC_ID_VCR1: AVCodecID = 35;
pub const AV_CODEC_ID_CLJR: AVCodecID = 36;
pub const AV_CODEC_ID_MDEC: AVCodecID = 37;
pub const AV_CODEC_ID_ROQ: AVCodecID = 38;
pub const AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 39;
pub const AV_CODEC_ID_XAN_WC3: AVCodecID = 40;
pub const AV_CODEC_ID_XAN_WC4: AVCodecID = 41;
pub const AV_CODEC_ID_RPZA: AVCodecID = 42;
pub const AV_CODEC_ID_CINEPAK: AVCodecID = 43;
pub const AV_CODEC_ID_WS_VQA: AVCodecID = 44;
pub const AV_CODEC_ID_MSRLE: AVCodecID = 45;
pub const AV_CODEC_ID_MSVIDEO1: AVCodecID = 46;
pub const AV_CODEC_ID_IDCIN: AVCodecID = 47;
pub const AV_CODEC_ID_8BPS: AVCodecID = 48;
pub const AV_CODEC_ID_SMC: AVCodecID = 49;
pub const AV_CODEC_ID_FLIC: AVCodecID = 50;
pub const AV_CODEC_ID_TRUEMOTION1: AVCodecID = 51;
pub const AV_CODEC_ID_VMDVIDEO: AVCodecID = 52;
pub const AV_CODEC_ID_MSZH: AVCodecID = 53;
pub const AV_CODEC_ID_ZLIB: AVCodecID = 54;
pub const AV_CODEC_ID_QTRLE: AVCodecID = 55;
pub const AV_CODEC_ID_TSCC: AVCodecID = 56;
pub const AV_CODEC_ID_ULTI: AVCodecID = 57;
pub const AV_CODEC_ID_QDRAW: AVCodecID = 58;
pub const AV_CODEC_ID_VIXL: AVCodecID = 59;
pub const AV_CODEC_ID_QPEG: AVCodecID = 60;
pub const AV_CODEC_ID_PNG: AVCodecID = 61;
pub const AV_CODEC_ID_PPM: AVCodecID = 62;
pub const AV_CODEC_ID_PBM: AVCodecID = 63;
pub const AV_CODEC_ID_PGM: AVCodecID = 64;
pub const AV_CODEC_ID_PGMYUV: AVCodecID = 65;
pub const AV_CODEC_ID_PAM: AVCodecID = 66;
pub const AV_CODEC_ID_FFVHUFF: AVCodecID = 67;
pub const AV_CODEC_ID_RV30: AVCodecID = 68;
pub const AV_CODEC_ID_RV40: AVCodecID = 69;
pub const AV_CODEC_ID_VC1: AVCodecID = 70;
pub const AV_CODEC_ID_WMV3: AVCodecID = 71;
pub const AV_CODEC_ID_LOCO: AVCodecID = 72;
pub const AV_CODEC_ID_WNV1: AVCodecID = 73;
pub const AV_CODEC_ID_AASC: AVCodecID = 74;
pub const AV_CODEC_ID_INDEO2: AVCodecID = 75;
pub const AV_CODEC_ID_FRAPS: AVCodecID = 76;
pub const AV_CODEC_ID_TRUEMOTION2: AVCodecID = 77;
pub const AV_CODEC_ID_BMP: AVCodecID = 78;
pub const AV_CODEC_ID_CSCD: AVCodecID = 79;
pub const AV_CODEC_ID_MMVIDEO: AVCodecID = 80;
pub const AV_CODEC_ID_ZMBV: AVCodecID = 81;
pub const AV_CODEC_ID_AVS: AVCodecID = 82;
pub const AV_CODEC_ID_SMACKVIDEO: AVCodecID = 83;
pub const AV_CODEC_ID_NUV: AVCodecID = 84;
pub const AV_CODEC_ID_KMVC: AVCodecID = 85;
pub const AV_CODEC_ID_FLASHSV: AVCodecID = 86;
pub const AV_CODEC_ID_CAVS: AVCodecID = 87;
pub const AV_CODEC_ID_JPEG2000: AVCodecID = 88;
pub const AV_CODEC_ID_VMNC: AVCodecID = 89;
pub const AV_CODEC_ID_VP5: AVCodecID = 90;
pub const AV_CODEC_ID_VP6: AVCodecID = 91;
pub const AV_CODEC_ID_VP6F: AVCodecID = 92;
pub const AV_CODEC_ID_TARGA: AVCodecID = 93;
pub const AV_CODEC_ID_DSICINVIDEO: AVCodecID = 94;
pub const AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 95;
pub const AV_CODEC_ID_TIFF: AVCodecID = 96;
pub const AV_CODEC_ID_GIF: AVCodecID = 97;
pub const AV_CODEC_ID_DXA: AVCodecID = 98;
pub const AV_CODEC_ID_DNXHD: AVCodecID = 99;
pub const AV_CODEC_ID_THP: AVCodecID = 100;
pub const AV_CODEC_ID_SGI: AVCodecID = 101;
pub const AV_CODEC_ID_C93: AVCodecID = 102;
pub const AV_CODEC_ID_BETHSOFTVID: AVCodecID = 103;
pub const AV_CODEC_ID_PTX: AVCodecID = 104;
pub const AV_CODEC_ID_TXD: AVCodecID = 105;
pub const AV_CODEC_ID_VP6A: AVCodecID = 106;
pub const AV_CODEC_ID_AMV: AVCodecID = 107;
pub const AV_CODEC_ID_VB: AVCodecID = 108;
pub const AV_CODEC_ID_PCX: AVCodecID = 109;
pub const AV_CODEC_ID_SUNRAST: AVCodecID = 110;
pub const AV_CODEC_ID_INDEO4: AVCodecID = 111;
pub const AV_CODEC_ID_INDEO5: AVCodecID = 112;
pub const AV_CODEC_ID_MIMIC: AVCodecID = 113;
pub const AV_CODEC_ID_RL2: AVCodecID = 114;
pub const AV_CODEC_ID_ESCAPE124: AVCodecID = 115;
pub const AV_CODEC_ID_DIRAC: AVCodecID = 116;
pub const AV_CODEC_ID_BFI: AVCodecID = 117;
pub const AV_CODEC_ID_CMV: AVCodecID = 118;
pub const AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 119;
pub const AV_CODEC_ID_TGV: AVCodecID = 120;
pub const AV_CODEC_ID_TGQ: AVCodecID = 121;
pub const AV_CODEC_ID_TQI: AVCodecID = 122;
pub const AV_CODEC_ID_AURA: AVCodecID = 123;
pub const AV_CODEC_ID_AURA2: AVCodecID = 124;
pub const AV_CODEC_ID_V210X: AVCodecID = 125;
pub const AV_CODEC_ID_TMV: AVCodecID = 126;
pub const AV_CODEC_ID_V210: AVCodecID = 127;
pub const AV_CODEC_ID_DPX: AVCodecID = 128;
pub const AV_CODEC_ID_MAD: AVCodecID = 129;
pub const AV_CODEC_ID_FRWU: AVCodecID = 130;
pub const AV_CODEC_ID_FLASHSV2: AVCodecID = 131;
pub const AV_CODEC_ID_CDGRAPHICS: AVCodecID = 132;
pub const AV_CODEC_ID_R210: AVCodecID = 133;
pub const AV_CODEC_ID_ANM: AVCodecID = 134;
pub const AV_CODEC_ID_BINKVIDEO: AVCodecID = 135;
pub const AV_CODEC_ID_IFF_ILBM: AVCodecID = 136;
pub const AV_CODEC_ID_KGV1: AVCodecID = 137;
pub const AV_CODEC_ID_YOP: AVCodecID = 138;
pub const AV_CODEC_ID_VP8: AVCodecID = 139;
pub const AV_CODEC_ID_PICTOR: AVCodecID = 140;
pub const AV_CODEC_ID_ANSI: AVCodecID = 141;
pub const AV_CODEC_ID_A64_MULTI: AVCodecID = 142;
pub const AV_CODEC_ID_A64_MULTI5: AVCodecID = 143;
pub const AV_CODEC_ID_R10K: AVCodecID = 144;
pub const AV_CODEC_ID_MXPEG: AVCodecID = 145;
pub const AV_CODEC_ID_LAGARITH: AVCodecID = 146;
pub const AV_CODEC_ID_PRORES: AVCodecID = 147;
pub const AV_CODEC_ID_JV: AVCodecID = 148;
pub const AV_CODEC_ID_DFA: AVCodecID = 149;
pub const AV_CODEC_ID_WMV3IMAGE: AVCodecID = 150;
pub const AV_CODEC_ID_VC1IMAGE: AVCodecID = 151;
pub const AV_CODEC_ID_UTVIDEO: AVCodecID = 152;
pub const AV_CODEC_ID_BMV_VIDEO: AVCodecID = 153;
pub const AV_CODEC_ID_VBLE: AVCodecID = 154;
pub const AV_CODEC_ID_DXTORY: AVCodecID = 155;
pub const AV_CODEC_ID_V410: AVCodecID = 156;
pub const AV_CODEC_ID_XWD: AVCodecID = 157;
pub const AV_CODEC_ID_CDXL: AVCodecID = 158;
pub const AV_CODEC_ID_XBM: AVCodecID = 159;
pub const AV_CODEC_ID_ZEROCODEC: AVCodecID = 160;
pub const AV_CODEC_ID_MSS1: AVCodecID = 161;
pub const AV_CODEC_ID_MSA1: AVCodecID = 162;
pub const AV_CODEC_ID_TSCC2: AVCodecID = 163;
pub const AV_CODEC_ID_MTS2: AVCodecID = 164;
pub const AV_CODEC_ID_CLLC: AVCodecID = 165;
pub const AV_CODEC_ID_MSS2: AVCodecID = 166;
pub const AV_CODEC_ID_VP9: AVCodecID = 167;
pub const AV_CODEC_ID_AIC: AVCodecID = 168;
pub const AV_CODEC_ID_ESCAPE130: AVCodecID = 169;
pub const AV_CODEC_ID_G2M: AVCodecID = 170;
pub const AV_CODEC_ID_WEBP: AVCodecID = 171;
pub const AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 172;
pub const AV_CODEC_ID_HEVC: AVCodecID = 173;
pub const AV_CODEC_ID_FIC: AVCodecID = 174;
pub const AV_CODEC_ID_ALIAS_PIX: AVCodecID = 175;
pub const AV_CODEC_ID_BRENDER_PIX: AVCodecID = 176;
pub const AV_CODEC_ID_PAF_VIDEO: AVCodecID = 177;
pub const AV_CODEC_ID_EXR: AVCodecID = 178;
pub const AV_CODEC_ID_VP7: AVCodecID = 179;
pub const AV_CODEC_ID_SANM: AVCodecID = 180;
pub const AV_CODEC_ID_SGIRLE: AVCodecID = 181;
pub const AV_CODEC_ID_MVC1: AVCodecID = 182;
pub const AV_CODEC_ID_MVC2: AVCodecID = 183;
pub const AV_CODEC_ID_HQX: AVCodecID = 184;
pub const AV_CODEC_ID_TDSC: AVCodecID = 185;
pub const AV_CODEC_ID_HQ_HQA: AVCodecID = 186;
pub const AV_CODEC_ID_HAP: AVCodecID = 187;
pub const AV_CODEC_ID_DDS: AVCodecID = 188;
pub const AV_CODEC_ID_DXV: AVCodecID = 189;
pub const AV_CODEC_ID_SCREENPRESSO: AVCodecID = 190;
pub const AV_CODEC_ID_RSCC: AVCodecID = 191;
pub const AV_CODEC_ID_AVS2: AVCodecID = 192;
pub const AV_CODEC_ID_PGX: AVCodecID = 193;
pub const AV_CODEC_ID_AVS3: AVCodecID = 194;
pub const AV_CODEC_ID_MSP2: AVCodecID = 195;
pub const AV_CODEC_ID_VVC: AVCodecID = 196;
pub const AV_CODEC_ID_Y41P: AVCodecID = 197;
pub const AV_CODEC_ID_AVRP: AVCodecID = 198;
pub const AV_CODEC_ID_012V: AVCodecID = 199;
pub const AV_CODEC_ID_AVUI: AVCodecID = 200;
pub const AV_CODEC_ID_AYUV: AVCodecID = 201;
pub const AV_CODEC_ID_TARGA_Y216: AVCodecID = 202;
pub const AV_CODEC_ID_V308: AVCodecID = 203;
pub const AV_CODEC_ID_V408: AVCodecID = 204;
pub const AV_CODEC_ID_YUV4: AVCodecID = 205;
pub const AV_CODEC_ID_AVRN: AVCodecID = 206;
pub const AV_CODEC_ID_CPIA: AVCodecID = 207;
pub const AV_CODEC_ID_XFACE: AVCodecID = 208;
pub const AV_CODEC_ID_SNOW: AVCodecID = 209;
pub const AV_CODEC_ID_SMVJPEG: AVCodecID = 210;
pub const AV_CODEC_ID_APNG: AVCodecID = 211;
pub const AV_CODEC_ID_DAALA: AVCodecID = 212;
pub const AV_CODEC_ID_CFHD: AVCodecID = 213;
pub const AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 214;
pub const AV_CODEC_ID_M101: AVCodecID = 215;
pub const AV_CODEC_ID_MAGICYUV: AVCodecID = 216;
pub const AV_CODEC_ID_SHEERVIDEO: AVCodecID = 217;
pub const AV_CODEC_ID_YLC: AVCodecID = 218;
pub const AV_CODEC_ID_PSD: AVCodecID = 219;
pub const AV_CODEC_ID_PIXLET: AVCodecID = 220;
pub const AV_CODEC_ID_SPEEDHQ: AVCodecID = 221;
pub const AV_CODEC_ID_FMVC: AVCodecID = 222;
pub const AV_CODEC_ID_SCPR: AVCodecID = 223;
pub const AV_CODEC_ID_CLEARVIDEO: AVCodecID = 224;
pub const AV_CODEC_ID_XPM: AVCodecID = 225;
pub const AV_CODEC_ID_AV1: AVCodecID = 226;
pub const AV_CODEC_ID_BITPACKED: AVCodecID = 227;
pub const AV_CODEC_ID_MSCC: AVCodecID = 228;
pub const AV_CODEC_ID_SRGC: AVCodecID = 229;
pub const AV_CODEC_ID_SVG: AVCodecID = 230;
pub const AV_CODEC_ID_GDV: AVCodecID = 231;
pub const AV_CODEC_ID_FITS: AVCodecID = 232;
pub const AV_CODEC_ID_IMM4: AVCodecID = 233;
pub const AV_CODEC_ID_PROSUMER: AVCodecID = 234;
pub const AV_CODEC_ID_MWSC: AVCodecID = 235;
pub const AV_CODEC_ID_WCMV: AVCodecID = 236;
pub const AV_CODEC_ID_RASC: AVCodecID = 237;
pub const AV_CODEC_ID_HYMT: AVCodecID = 238;
pub const AV_CODEC_ID_ARBC: AVCodecID = 239;
pub const AV_CODEC_ID_AGM: AVCodecID = 240;
pub const AV_CODEC_ID_LSCR: AVCodecID = 241;
pub const AV_CODEC_ID_VP4: AVCodecID = 242;
pub const AV_CODEC_ID_IMM5: AVCodecID = 243;
pub const AV_CODEC_ID_MVDV: AVCodecID = 244;
pub const AV_CODEC_ID_MVHA: AVCodecID = 245;
pub const AV_CODEC_ID_CDTOONS: AVCodecID = 246;
pub const AV_CODEC_ID_MV30: AVCodecID = 247;
pub const AV_CODEC_ID_NOTCHLC: AVCodecID = 248;
pub const AV_CODEC_ID_PFM: AVCodecID = 249;
pub const AV_CODEC_ID_MOBICLIP: AVCodecID = 250;
pub const AV_CODEC_ID_PHOTOCD: AVCodecID = 251;
pub const AV_CODEC_ID_IPU: AVCodecID = 252;
pub const AV_CODEC_ID_ARGO: AVCodecID = 253;
pub const AV_CODEC_ID_CRI: AVCodecID = 254;
pub const AV_CODEC_ID_SIMBIOSIS_IMX: AVCodecID = 255;
pub const AV_CODEC_ID_SGA_VIDEO: AVCodecID = 256;
pub const AV_CODEC_ID_GEM: AVCodecID = 257;
pub const AV_CODEC_ID_VBN: AVCodecID = 258;
pub const AV_CODEC_ID_JPEGXL: AVCodecID = 259;
pub const AV_CODEC_ID_QOI: AVCodecID = 260;
pub const AV_CODEC_ID_PHM: AVCodecID = 261;
pub const AV_CODEC_ID_RADIANCE_HDR: AVCodecID = 262;
pub const AV_CODEC_ID_WBMP: AVCodecID = 263;
pub const AV_CODEC_ID_MEDIA100: AVCodecID = 264;
pub const AV_CODEC_ID_VQC: AVCodecID = 265;
pub const AV_CODEC_ID_PDV: AVCodecID = 266;
pub const AV_CODEC_ID_EVC: AVCodecID = 267;
pub const AV_CODEC_ID_RTV1: AVCodecID = 268;
pub const AV_CODEC_ID_VMIX: AVCodecID = 269;
pub const AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
pub const AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
pub const AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
pub const AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
pub const AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
pub const AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
pub const AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
pub const AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
pub const AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
pub const AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
pub const AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
pub const AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
pub const AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
pub const AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
pub const AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
pub const AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
pub const AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
pub const AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
pub const AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
pub const AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
pub const AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
pub const AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
pub const AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
pub const AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
pub const AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
pub const AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
pub const AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
pub const AV_CODEC_ID_S302M: AVCodecID = 65562;
pub const AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
pub const AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
pub const AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
pub const AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
pub const AV_CODEC_ID_PCM_S64LE: AVCodecID = 65567;
pub const AV_CODEC_ID_PCM_S64BE: AVCodecID = 65568;
pub const AV_CODEC_ID_PCM_F16LE: AVCodecID = 65569;
pub const AV_CODEC_ID_PCM_F24LE: AVCodecID = 65570;
pub const AV_CODEC_ID_PCM_VIDC: AVCodecID = 65571;
pub const AV_CODEC_ID_PCM_SGA: AVCodecID = 65572;
pub const AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
pub const AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
pub const AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
pub const AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
pub const AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
pub const AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
pub const AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
pub const AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
pub const AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
pub const AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
pub const AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
pub const AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
pub const AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
pub const AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
pub const AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
pub const AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
pub const AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
pub const AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
pub const AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
pub const AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
pub const AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
pub const AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
pub const AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
pub const AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
pub const AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
pub const AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
pub const AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
pub const AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
pub const AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
pub const AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
pub const AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
pub const AV_CODEC_ID_ADPCM_AFC: AVCodecID = 69663;
pub const AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 69664;
pub const AV_CODEC_ID_ADPCM_DTK: AVCodecID = 69665;
pub const AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 69666;
pub const AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 69667;
pub const AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 69668;
pub const AV_CODEC_ID_ADPCM_PSX: AVCodecID = 69669;
pub const AV_CODEC_ID_ADPCM_AICA: AVCodecID = 69670;
pub const AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 69671;
pub const AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 69672;
pub const AV_CODEC_ID_ADPCM_AGM: AVCodecID = 69673;
pub const AV_CODEC_ID_ADPCM_ARGO: AVCodecID = 69674;
pub const AV_CODEC_ID_ADPCM_IMA_SSI: AVCodecID = 69675;
pub const AV_CODEC_ID_ADPCM_ZORK: AVCodecID = 69676;
pub const AV_CODEC_ID_ADPCM_IMA_APM: AVCodecID = 69677;
pub const AV_CODEC_ID_ADPCM_IMA_ALP: AVCodecID = 69678;
pub const AV_CODEC_ID_ADPCM_IMA_MTF: AVCodecID = 69679;
pub const AV_CODEC_ID_ADPCM_IMA_CUNNING: AVCodecID = 69680;
pub const AV_CODEC_ID_ADPCM_IMA_MOFLEX: AVCodecID = 69681;
pub const AV_CODEC_ID_ADPCM_IMA_ACORN: AVCodecID = 69682;
pub const AV_CODEC_ID_ADPCM_XMD: AVCodecID = 69683;
pub const AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
pub const AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
pub const AV_CODEC_ID_RA_144: AVCodecID = 77824;
pub const AV_CODEC_ID_RA_288: AVCodecID = 77825;
pub const AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
pub const AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
pub const AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
pub const AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
pub const AV_CODEC_ID_SDX2_DPCM: AVCodecID = 81924;
pub const AV_CODEC_ID_GREMLIN_DPCM: AVCodecID = 81925;
pub const AV_CODEC_ID_DERF_DPCM: AVCodecID = 81926;
pub const AV_CODEC_ID_WADY_DPCM: AVCodecID = 81927;
pub const AV_CODEC_ID_CBD2_DPCM: AVCodecID = 81928;
pub const AV_CODEC_ID_MP2: AVCodecID = 86016;
pub const AV_CODEC_ID_MP3: AVCodecID = 86017;
pub const AV_CODEC_ID_AAC: AVCodecID = 86018;
pub const AV_CODEC_ID_AC3: AVCodecID = 86019;
pub const AV_CODEC_ID_DTS: AVCodecID = 86020;
pub const AV_CODEC_ID_VORBIS: AVCodecID = 86021;
pub const AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
pub const AV_CODEC_ID_WMAV1: AVCodecID = 86023;
pub const AV_CODEC_ID_WMAV2: AVCodecID = 86024;
pub const AV_CODEC_ID_MACE3: AVCodecID = 86025;
pub const AV_CODEC_ID_MACE6: AVCodecID = 86026;
pub const AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
pub const AV_CODEC_ID_FLAC: AVCodecID = 86028;
pub const AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
pub const AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
pub const AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
pub const AV_CODEC_ID_ALAC: AVCodecID = 86032;
pub const AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
pub const AV_CODEC_ID_GSM: AVCodecID = 86034;
pub const AV_CODEC_ID_QDM2: AVCodecID = 86035;
pub const AV_CODEC_ID_COOK: AVCodecID = 86036;
pub const AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
pub const AV_CODEC_ID_TTA: AVCodecID = 86038;
pub const AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
pub const AV_CODEC_ID_QCELP: AVCodecID = 86040;
pub const AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
pub const AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
pub const AV_CODEC_ID_IMC: AVCodecID = 86043;
pub const AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
pub const AV_CODEC_ID_MLP: AVCodecID = 86045;
pub const AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
pub const AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
pub const AV_CODEC_ID_APE: AVCodecID = 86048;
pub const AV_CODEC_ID_NELLYMOSER: AVCodecID = 86049;
pub const AV_CODEC_ID_MUSEPACK8: AVCodecID = 86050;
pub const AV_CODEC_ID_SPEEX: AVCodecID = 86051;
pub const AV_CODEC_ID_WMAVOICE: AVCodecID = 86052;
pub const AV_CODEC_ID_WMAPRO: AVCodecID = 86053;
pub const AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86054;
pub const AV_CODEC_ID_ATRAC3P: AVCodecID = 86055;
pub const AV_CODEC_ID_EAC3: AVCodecID = 86056;
pub const AV_CODEC_ID_SIPR: AVCodecID = 86057;
pub const AV_CODEC_ID_MP1: AVCodecID = 86058;
pub const AV_CODEC_ID_TWINVQ: AVCodecID = 86059;
pub const AV_CODEC_ID_TRUEHD: AVCodecID = 86060;
pub const AV_CODEC_ID_MP4ALS: AVCodecID = 86061;
pub const AV_CODEC_ID_ATRAC1: AVCodecID = 86062;
pub const AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86063;
pub const AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86064;
pub const AV_CODEC_ID_AAC_LATM: AVCodecID = 86065;
pub const AV_CODEC_ID_QDMC: AVCodecID = 86066;
pub const AV_CODEC_ID_CELT: AVCodecID = 86067;
pub const AV_CODEC_ID_G723_1: AVCodecID = 86068;
pub const AV_CODEC_ID_G729: AVCodecID = 86069;
pub const AV_CODEC_ID_8SVX_EXP: AVCodecID = 86070;
pub const AV_CODEC_ID_8SVX_FIB: AVCodecID = 86071;
pub const AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86072;
pub const AV_CODEC_ID_RALF: AVCodecID = 86073;
pub const AV_CODEC_ID_IAC: AVCodecID = 86074;
pub const AV_CODEC_ID_ILBC: AVCodecID = 86075;
pub const AV_CODEC_ID_OPUS: AVCodecID = 86076;
pub const AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86077;
pub const AV_CODEC_ID_TAK: AVCodecID = 86078;
pub const AV_CODEC_ID_METASOUND: AVCodecID = 86079;
pub const AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86080;
pub const AV_CODEC_ID_ON2AVC: AVCodecID = 86081;
pub const AV_CODEC_ID_DSS_SP: AVCodecID = 86082;
pub const AV_CODEC_ID_CODEC2: AVCodecID = 86083;
pub const AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 86084;
pub const AV_CODEC_ID_SONIC: AVCodecID = 86085;
pub const AV_CODEC_ID_SONIC_LS: AVCodecID = 86086;
pub const AV_CODEC_ID_EVRC: AVCodecID = 86087;
pub const AV_CODEC_ID_SMV: AVCodecID = 86088;
pub const AV_CODEC_ID_DSD_LSBF: AVCodecID = 86089;
pub const AV_CODEC_ID_DSD_MSBF: AVCodecID = 86090;
pub const AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 86091;
pub const AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 86092;
pub const AV_CODEC_ID_4GV: AVCodecID = 86093;
pub const AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 86094;
pub const AV_CODEC_ID_XMA1: AVCodecID = 86095;
pub const AV_CODEC_ID_XMA2: AVCodecID = 86096;
pub const AV_CODEC_ID_DST: AVCodecID = 86097;
pub const AV_CODEC_ID_ATRAC3AL: AVCodecID = 86098;
pub const AV_CODEC_ID_ATRAC3PAL: AVCodecID = 86099;
pub const AV_CODEC_ID_DOLBY_E: AVCodecID = 86100;
pub const AV_CODEC_ID_APTX: AVCodecID = 86101;
pub const AV_CODEC_ID_APTX_HD: AVCodecID = 86102;
pub const AV_CODEC_ID_SBC: AVCodecID = 86103;
pub const AV_CODEC_ID_ATRAC9: AVCodecID = 86104;
pub const AV_CODEC_ID_HCOM: AVCodecID = 86105;
pub const AV_CODEC_ID_ACELP_KELVIN: AVCodecID = 86106;
pub const AV_CODEC_ID_MPEGH_3D_AUDIO: AVCodecID = 86107;
pub const AV_CODEC_ID_SIREN: AVCodecID = 86108;
pub const AV_CODEC_ID_HCA: AVCodecID = 86109;
pub const AV_CODEC_ID_FASTAUDIO: AVCodecID = 86110;
pub const AV_CODEC_ID_MSNSIREN: AVCodecID = 86111;
pub const AV_CODEC_ID_DFPWM: AVCodecID = 86112;
pub const AV_CODEC_ID_BONK: AVCodecID = 86113;
pub const AV_CODEC_ID_MISC4: AVCodecID = 86114;
pub const AV_CODEC_ID_APAC: AVCodecID = 86115;
pub const AV_CODEC_ID_FTR: AVCodecID = 86116;
pub const AV_CODEC_ID_WAVARC: AVCodecID = 86117;
pub const AV_CODEC_ID_RKA: AVCodecID = 86118;
pub const AV_CODEC_ID_AC4: AVCodecID = 86119;
pub const AV_CODEC_ID_OSQ: AVCodecID = 86120;
pub const AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
pub const AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
pub const AV_CODEC_ID_TEXT: AVCodecID = 94210;
pub const AV_CODEC_ID_XSUB: AVCodecID = 94211;
pub const AV_CODEC_ID_SSA: AVCodecID = 94212;
pub const AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
pub const AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
pub const AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
pub const AV_CODEC_ID_SRT: AVCodecID = 94216;
pub const AV_CODEC_ID_MICRODVD: AVCodecID = 94217;
pub const AV_CODEC_ID_EIA_608: AVCodecID = 94218;
pub const AV_CODEC_ID_JACOSUB: AVCodecID = 94219;
pub const AV_CODEC_ID_SAMI: AVCodecID = 94220;
pub const AV_CODEC_ID_REALTEXT: AVCodecID = 94221;
pub const AV_CODEC_ID_STL: AVCodecID = 94222;
pub const AV_CODEC_ID_SUBVIEWER1: AVCodecID = 94223;
pub const AV_CODEC_ID_SUBVIEWER: AVCodecID = 94224;
pub const AV_CODEC_ID_SUBRIP: AVCodecID = 94225;
pub const AV_CODEC_ID_WEBVTT: AVCodecID = 94226;
pub const AV_CODEC_ID_MPL2: AVCodecID = 94227;
pub const AV_CODEC_ID_VPLAYER: AVCodecID = 94228;
pub const AV_CODEC_ID_PJS: AVCodecID = 94229;
pub const AV_CODEC_ID_ASS: AVCodecID = 94230;
pub const AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 94231;
pub const AV_CODEC_ID_TTML: AVCodecID = 94232;
pub const AV_CODEC_ID_ARIB_CAPTION: AVCodecID = 94233;
pub const AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
pub const AV_CODEC_ID_TTF: AVCodecID = 98304;
pub const AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
pub const AV_CODEC_ID_EPG: AVCodecID = 98306;
pub const AV_CODEC_ID_BINTEXT: AVCodecID = 98307;
pub const AV_CODEC_ID_XBIN: AVCodecID = 98308;
pub const AV_CODEC_ID_IDF: AVCodecID = 98309;
pub const AV_CODEC_ID_OTF: AVCodecID = 98310;
pub const AV_CODEC_ID_SMPTE_KLV: AVCodecID = 98311;
pub const AV_CODEC_ID_DVD_NAV: AVCodecID = 98312;
pub const AV_CODEC_ID_TIMED_ID3: AVCodecID = 98313;
pub const AV_CODEC_ID_BIN_DATA: AVCodecID = 98314;
pub const AV_CODEC_ID_SMPTE_2038: AVCodecID = 98315;
pub const AV_CODEC_ID_PROBE: AVCodecID = 102400;
pub const AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
pub const AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
pub const AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
pub const AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
pub const AV_CODEC_ID_VNULL: AVCodecID = 135170;
pub const AV_CODEC_ID_ANULL: AVCodecID = 135171;
pub type AVCodecID = ::std::os::raw::c_uint;
extern "C" {
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    pub fn avcodec_get_name(id: AVCodecID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_profile_name(
        codec_id: AVCodecID,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: ::std::os::raw::c_int) -> AVCodecID;
}
#[doc = " AVProfile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProfile {
    pub profile: ::std::os::raw::c_int,
    #[doc = "< short name for the profile"]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    const UNINIT: ::std::mem::MaybeUninit<AVProfile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVProfile>(),
        16usize,
        concat!("Size of: ", stringify!(AVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProfile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " AVCodec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodec {
    #[doc = " Name of the codec implementation.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name).\n This is the primary way to find a codec from the user perspective."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the codec, meant to be more human readable than name.\n You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    #[doc = " Codec capabilities.\n see AV_CODEC_CAP_*"]
    pub capabilities: ::std::os::raw::c_int,
    #[doc = "< maximum value for lowres supported by the decoder"]
    pub max_lowres: u8,
    #[doc = "< array of supported framerates, or NULL if any, array is terminated by {0,0}"]
    pub supported_framerates: *const AVRational,
    #[doc = "< array of supported pixel formats, or NULL if unknown, array is terminated by -1"]
    pub pix_fmts: *const AVPixelFormat,
    #[doc = "< array of supported audio samplerates, or NULL if unknown, array is terminated by 0"]
    pub supported_samplerates: *const ::std::os::raw::c_int,
    #[doc = "< array of supported sample formats, or NULL if unknown, array is terminated by -1"]
    pub sample_fmts: *const AVSampleFormat,
    #[doc = "< array of support channel layouts, or NULL if unknown. array is terminated by 0"]
    pub channel_layouts: *const u64,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = "< array of recognized profiles, or NULL if unknown, array is terminated by {AV_PROFILE_UNKNOWN}"]
    pub profiles: *const AVProfile,
    #[doc = " Group name of the codec implementation.\n This is a short symbolic name of the wrapper backing this codec. A\n wrapper uses some kind of external implementation for the codec, such\n as an external library, or a codec implementation provided by the OS or\n the hardware.\n If this field is NULL, this is a builtin, libavcodec native codec.\n If non-NULL, this will be the suffix in AVCodec.name in most cases\n (usually AVCodec.name will be of the form \"<codec_name>_<wrapper_name>\")."]
    pub wrapper_name: *const ::std::os::raw::c_char,
    #[doc = " Array of supported channel layouts, terminated with a zeroed layout."]
    pub ch_layouts: *const AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodec>(),
        104usize,
        concat!("Size of: ", stringify!(AVCodec))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_lowres) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(max_lowres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_framerates) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_framerates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(pix_fmts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_samplerates) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_samplerates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_fmts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layouts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profiles) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapper_name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(wrapper_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layouts) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(ch_layouts)
        )
    );
}
extern "C" {
    #[doc = " Iterate over all registered codecs.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec or NULL when the iteration is\n         finished"]
    pub fn av_codec_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with a matching codec ID.\n\n @param id AVCodecID of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with the specified name.\n\n @param name name of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder_by_name(name: *const ::std::os::raw::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with a matching codec ID.\n\n @param id AVCodecID of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with the specified name.\n\n @param name name of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder_by_name(name: *const ::std::os::raw::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is an encoder, zero otherwise"]
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is a decoder, zero otherwise"]
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available.\n\n @param codec the codec that is searched for the given profile\n @param profile the profile value for which a name is requested\n @return A name for the profile if found, NULL otherwise."]
    pub fn av_get_profile_name(
        codec: *const AVCodec,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " The codec supports this format via the hw_device_ctx interface.\n\n When selecting this format, AVCodecContext.hw_device_ctx should\n have been set to a device of the specified type before calling\n avcodec_open2()."]
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_4 = 1;
#[doc = " The codec supports this format via the hw_frames_ctx interface.\n\n When selecting this format for a decoder,\n AVCodecContext.hw_frames_ctx should be set to a suitable frames\n context inside the get_format() callback.  The frames context\n must have been created on a device of the specified type.\n\n When selecting this format for an encoder,\n AVCodecContext.hw_frames_ctx should be set to the context which\n will be used for the input frames before calling avcodec_open2()."]
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_4 = 2;
#[doc = " The codec supports this format by some internal method.\n\n This format can be selected without any additional configuration -\n no device or frames context is required."]
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_4 = 4;
#[doc = " The codec supports this format by some ad-hoc method.\n\n Additional settings and/or function calls are required.  See the\n codec-specific documentation for details.  (Methods requiring\n this sort of configuration are deprecated and others should be\n used in preference.)"]
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_4 = 8;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfig {
    #[doc = " For decoders, a hardware pixel format which that decoder may be\n able to decode to if suitable hardware is available.\n\n For encoders, a pixel format which the encoder may be able to\n accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel\n formats supported by the codec."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible\n setup methods which can be used with this configuration."]
    pub methods: ::std::os::raw::c_int,
    #[doc = " The device type associated with the configuration.\n\n Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and\n AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused."]
    pub device_type: AVHWDeviceType,
}
#[test]
fn bindgen_test_layout_AVCodecHWConfig() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecHWConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecHWConfig>(),
        12usize,
        concat!("Size of: ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecHWConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AVCodecHWConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecHWConfig),
            "::",
            stringify!(device_type)
        )
    );
}
extern "C" {
    #[doc = " Retrieve supported hardware configurations for a codec.\n\n Values of index from zero to some maximum return the indexed configuration\n descriptor; all other values return NULL.  If the codec does not support\n any hardware configurations then it will always return NULL."]
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: ::std::os::raw::c_int,
    ) -> *const AVCodecHWConfig;
}
pub const AV_FIELD_UNKNOWN: AVFieldOrder = 0;
pub const AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
#[doc = "< Top coded_first, top displayed first"]
pub const AV_FIELD_TT: AVFieldOrder = 2;
#[doc = "< Bottom coded first, bottom displayed first"]
pub const AV_FIELD_BB: AVFieldOrder = 3;
#[doc = "< Top coded first, bottom displayed first"]
pub const AV_FIELD_TB: AVFieldOrder = 4;
#[doc = "< Bottom coded first, top displayed first"]
pub const AV_FIELD_BT: AVFieldOrder = 5;
pub type AVFieldOrder = ::std::os::raw::c_uint;
#[doc = "< discard nothing"]
pub const AVDISCARD_NONE: AVDiscard = -16;
#[doc = "< discard useless packets like 0 size packets in avi"]
pub const AVDISCARD_DEFAULT: AVDiscard = 0;
#[doc = "< discard all non reference"]
pub const AVDISCARD_NONREF: AVDiscard = 8;
#[doc = "< discard all bidirectional frames"]
pub const AVDISCARD_BIDIR: AVDiscard = 16;
#[doc = "< discard all non intra frames"]
pub const AVDISCARD_NONINTRA: AVDiscard = 24;
#[doc = "< discard all frames except keyframes"]
pub const AVDISCARD_NONKEY: AVDiscard = 32;
#[doc = "< discard all"]
pub const AVDISCARD_ALL: AVDiscard = 48;
#[doc = " @ingroup lavc_decoding"]
pub type AVDiscard = ::std::os::raw::c_int;
pub const AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
pub const AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
pub const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
pub const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
pub const AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
pub const AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
pub const AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
pub const AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
pub const AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
#[doc = "< Not part of ABI"]
pub const AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
pub type AVAudioServiceType = ::std::os::raw::c_uint;
#[doc = " Pan Scan area.\n This specifies the area which should be displayed.\n Note there may be multiple such areas for one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPanScan {
    #[doc = " id\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub id: ::std::os::raw::c_int,
    #[doc = " width and height in 1/16 pel\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " position of the top left corner in 1/16 pel for up to 3 fields/frames\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    const UNINIT: ::std::mem::MaybeUninit<AVPanScan> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPanScan>(),
        24usize,
        concat!("Size of: ", stringify!(AVPanScan))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPanScan>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPanScan))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(position)
        )
    );
}
#[doc = " This structure describes the bitrate properties of an encoded bitstream. It\n roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD\n parameters for H.264/HEVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCPBProperties {
    #[doc = " Maximum bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub max_bitrate: i64,
    #[doc = " Minimum bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub min_bitrate: i64,
    #[doc = " Average bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub avg_bitrate: i64,
    #[doc = " The size of the buffer to which the ratecontrol is applied, in bits.\n Zero if unknown or unspecified."]
    pub buffer_size: i64,
    #[doc = " The delay between the time the packet this structure is associated with\n is received and the time when it should be decoded, in periods of a 27MHz\n clock.\n\n UINT64_MAX when unknown or unspecified."]
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    const UNINIT: ::std::mem::MaybeUninit<AVCPBProperties> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCPBProperties>(),
        40usize,
        concat!("Size of: ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCPBProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bitrate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(max_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_bitrate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(min_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avg_bitrate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(avg_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbv_delay) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(vbv_delay)
        )
    );
}
extern "C" {
    #[doc = " Allocate a CPB properties structure and initialize its fields to default\n values.\n\n @param size if non-NULL, the size of the allocated struct will be written\n             here. This is useful for embedding it in side data.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[doc = " This structure supplies correlation between a packet timestamp and a wall clock\n production time. The definition follows the Producer Reference Time ('prft')\n as defined in ISO/IEC 14496-12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProducerReferenceTime {
    #[doc = " A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime())."]
    pub wallclock: i64,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVProducerReferenceTime() {
    const UNINIT: ::std::mem::MaybeUninit<AVProducerReferenceTime> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVProducerReferenceTime>(),
        16usize,
        concat!("Size of: ", stringify!(AVProducerReferenceTime))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProducerReferenceTime>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProducerReferenceTime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wallclock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProducerReferenceTime),
            "::",
            stringify!(wallclock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProducerReferenceTime),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Encode extradata length to a buffer. Used by xiph codecs.\n\n @param s buffer to write to; must be at least (v/255+1) bytes long\n @param v size of extradata in bytes\n @return number of bytes written to the buffer."]
    pub fn av_xiphlacing(
        s: *mut ::std::os::raw::c_uchar,
        v: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE\n bytes worth of palette. This side data signals that a new palette is\n present."]
pub const AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
#[doc = " The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format\n that the extradata buffer was changed and the receiving side should\n act upon it appropriately. The new extradata is embedded in the side\n data buffer and should be immediately used for processing the current\n frame or packet."]
pub const AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
#[doc = " An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:\n @code\n u32le param_flags\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)\n     s32le channel_count\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)\n     u64le channel_layout\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)\n     s32le sample_rate\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)\n     s32le width\n     s32le height\n @endcode"]
pub const AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
#[doc = " An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of\n structures with info about macroblocks relevant to splitting the\n packet into smaller packets on macroblock edges (e.g. as for RFC 2190).\n That is, it does not necessarily contain info about all macroblocks,\n as long as the distance between macroblocks in the info is smaller\n than the target payload size.\n Each MB info structure is 12 bytes, and is laid out as follows:\n @code\n u32le bit offset from the start of the packet\n u8    current quantizer at the start of the macroblock\n u8    GOB number\n u16le macroblock address within the GOB\n u8    horizontal MV predictor\n u8    vertical MV predictor\n u8    horizontal MV predictor for block number 3\n u8    vertical MV predictor for block number 3\n @endcode"]
pub const AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
#[doc = " This side data should be associated with an audio stream and contains\n ReplayGain information in form of the AVReplayGain struct."]
pub const AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
#[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the decoded video frames for\n correct presentation.\n\n See libavutil/display.h for a detailed description of the data."]
pub const AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
#[doc = " This side data should be associated with a video stream and contains\n Stereoscopic 3D information in form of the AVStereo3D struct."]
pub const AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
#[doc = " This side data should be associated with an audio stream and corresponds\n to enum AVAudioServiceType."]
pub const AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
#[doc = " This side data contains quality related information from the encoder.\n @code\n u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).\n u8    picture type\n u8    error count\n u16   reserved\n u64le[error count] sum of squared differences between encoder in and output\n @endcode"]
pub const AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
#[doc = " This side data contains an integer value representing the stream index\n of a \"fallback\" track.  A fallback track indicates an alternate\n track to use when the current track can not be decoded for some reason.\n e.g. no decoder available for codec."]
pub const AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
#[doc = " This side data corresponds to the AVCPBProperties struct."]
pub const AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
#[doc = " Recommmends skipping the specified number of samples\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
pub const AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 11;
#[doc = " An AV_PKT_DATA_JP_DUALMONO side data packet indicates that\n the packet may contain \"dual mono\" audio specific to Japanese DTV\n and if it is true, recommends only the selected channel to be used.\n @code\n u8    selected channels (0=main/left, 1=sub/right, 2=both)\n @endcode"]
pub const AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 12;
#[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop."]
pub const AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 13;
#[doc = " Subtitle event position\n @code\n u32le x1\n u32le y1\n u32le x2\n u32le y2\n @endcode"]
pub const AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 14;
#[doc = " Data found in BlockAdditional element of matroska container. There is\n no end marker for the data, so it is required to rely on the side data\n size to recognize the end. 8 byte id (as found in BlockAddId) followed\n by data."]
pub const AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 15;
#[doc = " The optional first identifier line of a WebVTT cue."]
pub const AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 16;
#[doc = " The optional settings (rendering instructions) that immediately\n follow the timestamp specifier of a WebVTT cue."]
pub const AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 17;
#[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop. This\n side data includes updated metadata which appeared in the stream."]
pub const AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 18;
#[doc = " MPEGTS stream ID as uint8_t, this is required to pass the stream ID\n information from the demuxer to the corresponding muxer."]
pub const AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 19;
#[doc = " Mastering display metadata (based on SMPTE-2086:2014). This metadata\n should be associated with a video stream and contains data in the form\n of the AVMasteringDisplayMetadata struct."]
pub const AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 20;
#[doc = " This side data should be associated with a video stream and corresponds\n to the AVSphericalMapping structure."]
pub const AV_PKT_DATA_SPHERICAL: AVPacketSideDataType = 21;
#[doc = " Content light level (based on CTA-861.3). This metadata should be\n associated with a video stream and contains data in the form of the\n AVContentLightMetadata struct."]
pub const AV_PKT_DATA_CONTENT_LIGHT_LEVEL: AVPacketSideDataType = 22;
#[doc = " ATSC A53 Part 4 Closed Captions. This metadata should be associated with\n a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.\n The number of bytes of CC data is AVPacketSideData.size."]
pub const AV_PKT_DATA_A53_CC: AVPacketSideDataType = 23;
#[doc = " This side data is encryption initialization data.\n The format is not part of ABI, use av_encryption_init_info_* methods to\n access."]
pub const AV_PKT_DATA_ENCRYPTION_INIT_INFO: AVPacketSideDataType = 24;
#[doc = " This side data contains encryption info for how to decrypt the packet.\n The format is not part of ABI, use av_encryption_info_* methods to access."]
pub const AV_PKT_DATA_ENCRYPTION_INFO: AVPacketSideDataType = 25;
#[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
pub const AV_PKT_DATA_AFD: AVPacketSideDataType = 26;
#[doc = " Producer Reference Time data corresponding to the AVProducerReferenceTime struct,\n usually exported by some encoders (on demand through the prft flag set in the\n AVCodecContext export_side_data field)."]
pub const AV_PKT_DATA_PRFT: AVPacketSideDataType = 27;
#[doc = " ICC profile data consisting of an opaque octet buffer following the\n format described by ISO 15076-1."]
pub const AV_PKT_DATA_ICC_PROFILE: AVPacketSideDataType = 28;
#[doc = " DOVI configuration\n ref:\n dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2\n dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3\n Tags are stored in struct AVDOVIDecoderConfigurationRecord."]
pub const AV_PKT_DATA_DOVI_CONF: AVPacketSideDataType = 29;
#[doc = " Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
pub const AV_PKT_DATA_S12M_TIMECODE: AVPacketSideDataType = 30;
#[doc = " HDR10+ dynamic metadata associated with a video frame. The metadata is in\n the form of the AVDynamicHDRPlus struct and contains\n information for color volume transform - application 4 of\n SMPTE 2094-40:2016 standard."]
pub const AV_PKT_DATA_DYNAMIC_HDR10_PLUS: AVPacketSideDataType = 31;
#[doc = " The number of side data types.\n This is not part of the public API/ABI in the sense that it may\n change when new side data types are added.\n This must stay the last enum value.\n If its value becomes huge, some code using it\n needs to be updated as it assumes it to be smaller than other limits."]
pub const AV_PKT_DATA_NB: AVPacketSideDataType = 32;
#[doc = " @defgroup lavc_packet_side_data AVPacketSideData\n\n Types and functions for working with AVPacketSideData.\n @{"]
pub type AVPacketSideDataType = ::std::os::raw::c_uint;
#[doc = " This structure stores auxiliary information for decoding, presenting, or\n otherwise processing the coded stream. It is typically exported by demuxers\n and encoders and can be fed to decoders and muxers either in a per packet\n basis, or as global side data (applying to the entire coded stream).\n\n Global side data is handled as follows:\n - During demuxing, it may be exported through\n   @ref AVStream.codecpar.side_data \"AVStream's codec parameters\", which can\n   then be passed as input to decoders through the\n   @ref AVCodecContext.coded_side_data \"decoder context's side data\", for\n   initialization.\n - For muxing, it can be fed through @ref AVStream.codecpar.side_data\n   \"AVStream's codec parameters\", typically  the output of encoders through\n   the @ref AVCodecContext.coded_side_data \"encoder context's side data\", for\n   initialization.\n\n Packet specific side data is handled as follows:\n - During demuxing, it may be exported through @ref AVPacket.side_data\n   \"AVPacket's side data\", which can then be passed as input to decoders.\n - For muxing, it can be fed through @ref AVPacket.side_data \"AVPacket's\n   side data\", typically the output of encoders.\n\n Different modules may accept or export different types of side data\n depending on media type and codec. Refer to @ref AVPacketSideDataType for a\n list of defined types and where they may be found or used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: usize,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    const UNINIT: ::std::mem::MaybeUninit<AVPacketSideData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPacketSideData>(),
        24usize,
        concat!("Size of: ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Allocate a new packet side data.\n\n @param sd    pointer to an array of side data to which the side data should\n              be added. *sd may be NULL, in which case the array will be\n              initialized.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array. The integer value will be increased by 1 on success.\n @param type  side data type\n @param size  desired side data size\n @param flags currently unused. Must be zero\n\n @return pointer to freshly allocated side data on success, or NULL otherwise."]
    pub fn av_packet_side_data_new(
        psd: *mut *mut AVPacketSideData,
        pnb_sd: *mut ::std::os::raw::c_int,
        type_: AVPacketSideDataType,
        size: usize,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVPacketSideData;
}
extern "C" {
    #[doc = " Wrap existing data as packet side data.\n\n @param sd    pointer to an array of side data to which the side data should\n              be added. *sd may be NULL, in which case the array will be\n              initialized\n @param nb_sd pointer to an integer containing the number of entries in\n              the array. The integer value will be increased by 1 on success.\n @param type  side data type\n @param data  a data array. It must be allocated with the av_malloc() family\n              of functions. The ownership of the data is transferred to the\n              side data array on success\n @param size  size of the data array\n @param flags currently unused. Must be zero\n\n @return pointer to freshly allocated side data on success, or NULL otherwise\n         On failure, the side data array is unchanged and the data remains\n         owned by the caller."]
    pub fn av_packet_side_data_add(
        sd: *mut *mut AVPacketSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        type_: AVPacketSideDataType,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVPacketSideData;
}
extern "C" {
    #[doc = " Get side information from a side data array.\n\n @param sd    the array from which the side data should be fetched\n @param nb_sd value containing the number of entries in the array.\n @param type  desired side information type\n\n @return pointer to side data if present or NULL otherwise"]
    pub fn av_packet_side_data_get(
        sd: *const AVPacketSideData,
        nb_sd: ::std::os::raw::c_int,
        type_: AVPacketSideDataType,
    ) -> *const AVPacketSideData;
}
extern "C" {
    #[doc = " Remove side data of the given type from a side data array.\n\n @param sd    the array from which the side data should be removed\n @param nb_sd pointer to an integer containing the number of entries in\n              the array. Will be reduced by the amount of entries removed\n              upon return\n @param type  side information type"]
    pub fn av_packet_side_data_remove(
        sd: *mut AVPacketSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        type_: AVPacketSideDataType,
    );
}
extern "C" {
    #[doc = " Convenience function to free all the side data stored in an array, and\n the array itself.\n\n @param sd    pointer to array of side data to free. Will be set to NULL\n              upon return.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array. Will be set to 0 upon return."]
    pub fn av_packet_side_data_free(
        sd: *mut *mut AVPacketSideData,
        nb_sd: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const ::std::os::raw::c_char;
}
#[doc = " This structure stores compressed data. It is typically exported by demuxers\n and then passed as input to decoders, or received as output from encoders and\n then passed to muxers.\n\n For video, it should typically contain one compressed frame. For audio it may\n contain several compressed frames. Encoders are allowed to output empty\n packets, with no compressed data, containing only side data\n (e.g. to update some stream parameters at the end of encoding).\n\n The semantics of data ownership depends on the buf field.\n If it is set, the packet data is dynamically allocated and is\n valid indefinitely until a call to av_packet_unref() reduces the\n reference count to 0.\n\n If the buf field is not set av_packet_ref() would make a copy instead\n of increasing the reference count.\n\n The side data is always allocated with av_malloc(), copied by\n av_packet_ref() and freed by av_packet_unref().\n\n sizeof(AVPacket) being a part of the public ABI is deprecated. once\n av_init_packet() is removed, new packets will only be able to be allocated\n with av_packet_alloc(), and new fields may be added to the end of the struct\n with a minor bump.\n\n @see av_packet_alloc\n @see av_packet_ref\n @see av_packet_unref"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacket {
    #[doc = " A reference to the reference-counted buffer where the packet data is\n stored.\n May be NULL, then the packet data is not reference-counted."]
    pub buf: *mut AVBufferRef,
    #[doc = " Presentation timestamp in AVStream->time_base units; the time at which\n the decompressed packet will be presented to the user.\n Can be AV_NOPTS_VALUE if it is not stored in the file.\n pts MUST be larger or equal to dts as presentation cannot happen before\n decompression, unless one wants to view hex dumps. Some formats misuse\n the terms dts and pts/cts to mean something different. Such timestamps\n must be converted to true pts/dts before they are stored in AVPacket."]
    pub pts: i64,
    #[doc = " Decompression timestamp in AVStream->time_base units; the time at which\n the packet is decompressed.\n Can be AV_NOPTS_VALUE if it is not stored in the file."]
    pub dts: i64,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub stream_index: ::std::os::raw::c_int,
    #[doc = " A combination of AV_PKT_FLAG values"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Additional packet data that can be provided by the container.\n Packet can contain several types of side information."]
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: ::std::os::raw::c_int,
    #[doc = " Duration of this packet in AVStream->time_base units, 0 if unknown.\n Equals next_pts - this_pts in presentation order."]
    pub duration: i64,
    #[doc = "< byte position in stream, -1 if unknown"]
    pub pos: i64,
    #[doc = " for some private data of the user"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the\n contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when\n the packet is unreferenced. av_packet_copy_props() calls create a new\n reference with av_buffer_ref() for the target packet's opaque_ref field.\n\n This is unrelated to the opaque field, although it serves a similar\n purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " Time base of the packet's timestamps.\n In the future, this field may be set on packets output by encoders or\n demuxers, but its value will be by default ignored on input to decoders\n or muxers."]
    pub time_base: AVRational,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    const UNINIT: ::std::mem::MaybeUninit<AVPacket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPacket>(),
        104usize,
        concat!("Size of: ", stringify!(AVPacket))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacket>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_index) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).side_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).side_data_elems) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data_elems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque_ref) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(time_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[test]
fn bindgen_test_layout_AVPacketList() {
    const UNINIT: ::std::mem::MaybeUninit<AVPacketList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPacketList>(),
        112usize,
        concat!("Size of: ", stringify!(AVPacketList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(pkt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " @deprecated those are not used by any decoder"]
pub const AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT: AVSideDataParamChangeFlags = 1;
#[doc = " @deprecated those are not used by any decoder"]
pub const AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT: AVSideDataParamChangeFlags = 2;
pub const AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE: AVSideDataParamChangeFlags = 4;
pub const AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS: AVSideDataParamChangeFlags = 8;
pub type AVSideDataParamChangeFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Allocate an AVPacket and set its fields to default values.  The resulting\n struct must be freed using av_packet_free().\n\n @return An AVPacket filled with default values or NULL on failure.\n\n @note this only allocates the AVPacket itself, not the data buffers. Those\n must be allocated through other means such as av_new_packet.\n\n @see av_new_packet"]
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    #[doc = " Create a new packet that references the same data as src.\n\n This is a shortcut for av_packet_alloc()+av_packet_ref().\n\n @return newly created AVPacket on success, NULL on error.\n\n @see av_packet_alloc\n @see av_packet_ref"]
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    #[doc = " Free the packet, if the packet is reference counted, it will be\n unreferenced first.\n\n @param pkt packet to be freed. The pointer will be set to NULL.\n @note passing NULL is a no-op."]
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    #[doc = " Initialize optional fields of a packet with default values.\n\n Note, this does not touch the data and size members, which have to be\n initialized separately.\n\n @param pkt packet\n\n @see av_packet_alloc\n @see av_packet_unref\n\n @deprecated This function is deprecated. Once it's removed,\nsizeof(AVPacket) will not be a part of the ABI anymore."]
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Allocate the payload of a packet and initialize its fields with\n default values.\n\n @param pkt packet\n @param size wanted payload size\n @return 0 if OK, AVERROR_xxx otherwise"]
    pub fn av_new_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reduce packet size, correctly zeroing padding\n\n @param pkt packet\n @param size new size"]
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Increase packet size, correctly zeroing padding\n\n @param pkt packet\n @param grow_by number of bytes by which to increase the size of the packet"]
    pub fn av_grow_packet(
        pkt: *mut AVPacket,
        grow_by: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a reference-counted packet from av_malloc()ed data.\n\n @param pkt packet to be initialized. This function will set the data, size,\n        and buf fields, all others are left untouched.\n @param data Data allocated by av_malloc() to be used as packet data. If this\n        function returns successfully, the data is owned by the underlying AVBuffer.\n        The caller may not access the data through other means.\n @param size size of data in bytes, without the padding. I.e. the full buffer\n        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate new information of a packet.\n\n @param pkt packet\n @param type side information type\n @param size side information size\n @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Wrap an existing array as a packet side data.\n\n @param pkt packet\n @param type side information type\n @param data the side data array. It must be allocated with the av_malloc()\n             family of functions. The ownership of the data is transferred to\n             pkt.\n @param size side information size\n @return a non-negative number on success, a negative AVERROR code on\n         failure. On failure, the packet is unchanged and the data remains\n         owned by the caller."]
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrink the already allocated side data buffer\n\n @param pkt packet\n @param type side information type\n @param size new side information size\n @return 0 on success, < 0 on failure"]
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get side information from packet.\n\n @param pkt packet\n @param type desired side information type\n @param size If supplied, *size will be set to the size of the side data\n             or to zero if the desired side data is not present.\n @return pointer to data if present or NULL otherwise"]
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Pack a dictionary for use in side_data.\n\n @param dict The dictionary to pack.\n @param size pointer to store the size of the returned data\n @return pointer to data if successful, NULL otherwise"]
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary, size: *mut usize) -> *mut u8;
}
extern "C" {
    #[doc = " Unpack a dictionary from side_data.\n\n @param data data from side_data\n @param size size of the data\n @param dict the metadata storage dictionary\n @return 0 on success, < 0 on failure"]
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: usize,
        dict: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function to free all the side data stored.\n All the other fields stay untouched.\n\n @param pkt packet"]
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Setup a new reference to the data described by a given packet\n\n If src is reference-counted, setup dst as a new reference to the\n buffer in src. Otherwise allocate a new buffer in dst and copy the\n data from src into it.\n\n All the other fields are copied from src.\n\n @see av_packet_unref\n\n @param dst Destination packet. Will be completely overwritten.\n @param src Source packet\n\n @return 0 on success, a negative AVERROR on error. On error, dst\n         will be blank (as if returned by av_packet_alloc())."]
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wipe the packet.\n\n Unreference the buffer referenced by the packet and reset the\n remaining packet fields to their default values.\n\n @param pkt The packet to be unreferenced."]
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Move every field in src to dst and reset src.\n\n @see av_packet_unref\n\n @param src Source packet, will be reset\n @param dst Destination packet"]
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    #[doc = " Copy only \"properties\" fields from src to dst.\n\n Properties for the purpose of this function are all the fields\n beside those related to the packet data (buf, data, size)\n\n @param dst Destination packet\n @param src Source packet\n\n @return 0 on success AVERROR on failure."]
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure the data described by a given packet is reference counted.\n\n @note This function does not ensure that the reference will be writable.\n       Use av_packet_make_writable instead for that purpose.\n\n @see av_packet_ref\n @see av_packet_make_writable\n\n @param pkt packet whose data should be made reference counted.\n\n @return 0 on success, a negative AVERROR on error. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a writable reference for the data described by a given packet,\n avoiding data copy if possible.\n\n @param pkt Packet whose data should be made writable.\n\n @return 0 on success, a negative AVERROR on failure. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert valid timing fields (timestamps / durations) in a packet from one\n timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be\n ignored.\n\n @param pkt packet on which the conversion will be performed\n @param tb_src source timebase, in which the timing fields in pkt are\n               expressed\n @param tb_dst destination timebase, to which the timing fields will be\n               converted"]
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
#[doc = " This struct describes the properties of a single codec described by an\n AVCodecID.\n @see avcodec_descriptor_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    #[doc = " Name of the codec described by this descriptor. It is non-empty and\n unique for each codec descriptor. It should contain alphanumeric\n characters and '_' only."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A more descriptive name for this codec. May be NULL."]
    pub long_name: *const ::std::os::raw::c_char,
    #[doc = " Codec properties, a combination of AV_CODEC_PROP_* flags."]
    pub props: ::std::os::raw::c_int,
    #[doc = " MIME type(s) associated with the codec.\n May be NULL; if not, a NULL-terminated array of MIME types.\n The first item is always non-NULL and is the preferred MIME type."]
    pub mime_types: *const *const ::std::os::raw::c_char,
    #[doc = " If non-NULL, an array of profiles recognized for this codec.\n Terminated with AV_PROFILE_UNKNOWN."]
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecDescriptor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecDescriptor>(),
        48usize,
        concat!("Size of: ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mime_types) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profiles) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(profiles)
        )
    );
}
extern "C" {
    #[doc = " @return descriptor for given codec ID or NULL if no descriptor exists."]
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " Iterate over all codec descriptors known to libavcodec.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " @return codec descriptor with the given name or NULL if no such descriptor\n         exists."]
    pub fn avcodec_descriptor_get_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const AVCodecDescriptor;
}
#[doc = " This struct describes the properties of an encoded stream.\n\n sizeof(AVCodecParameters) is not a part of the public ABI, this struct must\n be allocated with avcodec_parameters_alloc() and freed with\n avcodec_parameters_free()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecParameters {
    #[doc = " General type of the encoded data."]
    pub codec_type: AVMediaType,
    #[doc = " Specific type of the encoded data (the codec used)."]
    pub codec_id: AVCodecID,
    #[doc = " Additional information about the codec (corresponds to the AVI FOURCC)."]
    pub codec_tag: u32,
    #[doc = " Extra binary data needed for initializing the decoder, codec-dependent.\n\n Must be allocated with av_malloc() and will be freed by\n avcodec_parameters_free(). The allocated size of extradata must be at\n least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding\n bytes zeroed."]
    pub extradata: *mut u8,
    #[doc = " Size of the extradata content in bytes."]
    pub extradata_size: ::std::os::raw::c_int,
    #[doc = " - video: the pixel format, the value corresponds to enum AVPixelFormat.\n - audio: the sample format, the value corresponds to enum AVSampleFormat."]
    pub format: ::std::os::raw::c_int,
    #[doc = " The average bitrate of the encoded data (in bits per second)."]
    pub bit_rate: i64,
    #[doc = " The number of bits per sample in the codedwords.\n\n This is basically the bitrate per sample. It is mandatory for a bunch of\n formats to actually decode them. It's the number of bits for one sample in\n the actual coded bitstream.\n\n This could be for example 4 for ADPCM\n For PCM formats this matches bits_per_raw_sample\n Can be 0"]
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    #[doc = " This is the number of valid bits in each output sample. If the\n sample format has more bits, the least significant bits are additional\n padding bits, which are always 0. Use right shifts to reduce the sample\n to its actual size. For example, audio formats with 24 bit samples will\n have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.\n To get the original sample use \"(int32_t)sample >> 8\".\"\n\n For ADPCM this might be 12 or 16 or similar\n Can be 0"]
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    #[doc = " Codec-specific bitstream restrictions that the stream conforms to."]
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    #[doc = " Video only. The dimensions of the video frame in pixels."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Video only. The aspect ratio (width / height) which a single pixel\n should have when displayed.\n\n When the aspect ratio is unknown / undefined, the numerator should be\n set to 0 (the denominator may have any value)."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only. The order of the fields in interlaced video."]
    pub field_order: AVFieldOrder,
    #[doc = " Video only. Additional colorspace characteristics."]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " Video only. Number of delayed frames."]
    pub video_delay: ::std::os::raw::c_int,
    #[doc = " Audio only. The channel layout bitmask. May be 0 if the channel layout is\n unknown or unspecified, otherwise the number of bits set must be equal to\n the channels field.\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Audio only. The number of audio channels.\n @deprecated use ch_layout.nb_channels"]
    pub channels: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of audio samples per second."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of bytes per coded audio frame, required by some\n formats.\n\n Corresponds to nBlockAlign in WAVEFORMATEX."]
    pub block_align: ::std::os::raw::c_int,
    #[doc = " Audio only. Audio frame size, if known. Required by some formats to be static."]
    pub frame_size: ::std::os::raw::c_int,
    #[doc = " Audio only. The amount of padding (in samples) inserted by the encoder at\n the beginning of the audio. I.e. this number of leading decoded samples\n must be discarded by the caller to get the original audio without leading\n padding."]
    pub initial_padding: ::std::os::raw::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding."]
    pub trailing_padding: ::std::os::raw::c_int,
    #[doc = " Audio only. Number of samples to skip after a discontinuity."]
    pub seek_preroll: ::std::os::raw::c_int,
    #[doc = " Audio only. The channel layout and number of channels."]
    pub ch_layout: AVChannelLayout,
    #[doc = " Video only. Number of frames per second, for streams with constant frame\n durations. Should be set to { 0, 1 } when some frames have differing\n durations or if the value is not known.\n\n @note This field correponds to values that are stored in codec-level\n headers and is typically overridden by container/transport-layer\n timestamps, when available. It should thus be used only as a last resort,\n when no higher-level timing information is available."]
    pub framerate: AVRational,
    #[doc = " Additional data associated with the entire stream."]
    pub coded_side_data: *mut AVPacketSideData,
    #[doc = " Amount of entries in @ref coded_side_data."]
    pub nb_coded_side_data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecParameters> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecParameters>(),
        192usize,
        concat!("Size of: ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_rate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_coded_sample) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_raw_sample) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_order) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_trc) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_space) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_location) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_delay) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(video_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_size) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_padding) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailing_padding) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek_preroll) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layout) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(ch_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_side_data) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_coded_side_data) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
}
impl ::std::fmt::Debug for AVCodecParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVCodecParameters {{ codec_type: {:?}, codec_id: {:?}, codec_tag: {:?}, extradata: {:?}, extradata_size: {:?}, format: {:?}, bit_rate: {:?}, bits_per_coded_sample: {:?}, bits_per_raw_sample: {:?}, profile: {:?}, level: {:?}, width: {:?}, height: {:?}, sample_aspect_ratio: {:?}, field_order: {:?}, color_range: {:?}, color_primaries: {:?}, color_trc: {:?}, color_space: {:?}, chroma_location: {:?}, video_delay: {:?}, channel_layout: {:?}, channels: {:?}, sample_rate: {:?}, block_align: {:?}, frame_size: {:?}, initial_padding: {:?}, trailing_padding: {:?}, seek_preroll: {:?}, ch_layout: {:?}, framerate: {:?}, coded_side_data: {:?}, nb_coded_side_data: {:?} }}" , self . codec_type , self . codec_id , self . codec_tag , self . extradata , self . extradata_size , self . format , self . bit_rate , self . bits_per_coded_sample , self . bits_per_raw_sample , self . profile , self . level , self . width , self . height , self . sample_aspect_ratio , self . field_order , self . color_range , self . color_primaries , self . color_trc , self . color_space , self . chroma_location , self . video_delay , self . channel_layout , self . channels , self . sample_rate , self . block_align , self . frame_size , self . initial_padding , self . trailing_padding , self . seek_preroll , self . ch_layout , self . framerate , self . coded_side_data , self . nb_coded_side_data)
    }
}
extern "C" {
    #[doc = " Allocate a new AVCodecParameters and set its fields to default values\n (unknown/invalid/0). The returned struct must be freed with\n avcodec_parameters_free()."]
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    #[doc = " Free an AVCodecParameters instance and everything associated with it and\n write NULL to the supplied pointer."]
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    #[doc = " Copy the contents of src to dst. Any allocated fields in dst are freed and\n replaced with newly allocated duplicates of the corresponding fields in src.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as av_get_audio_frame_duration(), except it works\n with AVCodecParameters instead of an AVCodecContext."]
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @ingroup lavc_encoding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RcOverride {
    pub start_frame: ::std::os::raw::c_int,
    pub end_frame: ::std::os::raw::c_int,
    pub qscale: ::std::os::raw::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    const UNINIT: ::std::mem::MaybeUninit<RcOverride> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RcOverride>(),
        16usize,
        concat!("Size of: ", stringify!(RcOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<RcOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(RcOverride))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qscale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(qscale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality_factor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(quality_factor)
        )
    );
}
#[doc = " main external API structure.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user\n applications.\n The name string for AVOptions options matches the associated command line\n parameter name and can be found in libavcodec/options_table.h\n The AVOption/command line parameter names differ in some cases from the C\n structure field names for historic reasons or brevity.\n sizeof(AVCodecContext) must not be used outside libav*."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecContext {
    #[doc = " information on struct for av_log\n - set by avcodec_alloc_context3"]
    pub av_class: *const AVClass,
    pub log_level_offset: ::std::os::raw::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    #[doc = " fourcc (LSB first, so \"ABCD\" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').\n This is used to work around some encoder bugs.\n A demuxer should set this to what is stored in the field used to identify the codec.\n If there are multiple such fields in a container then the demuxer should choose the one\n which maximizes the information about the used codec.\n If the codec tag field in a container is larger than 32 bits then the demuxer should\n remap the longer ID to 32 bits with a table or other structure. Alternatively a new\n extra_codec_tag + size could be added but for this a clear advantage must be demonstrated\n first.\n - encoding: Set by user, if not then the default based on codec_id will be used.\n - decoding: Set by user, will be converted to uppercase by libavcodec during init."]
    pub codec_tag: ::std::os::raw::c_uint,
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Private context used for internal data.\n\n Unlike priv_data, this is not codec-specific. It is used in general\n libavcodec functions."]
    pub internal: *mut AVCodecInternal,
    #[doc = " Private data of the user, can be used to carry app specific stuff.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " the average bitrate\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: Set by user, may be overwritten by libavcodec\n             if this info is available in the stream"]
    pub bit_rate: i64,
    #[doc = " number of bits the bitstream is allowed to diverge from the reference.\n           the reference can be CBR (for CBR pass1) or VBR (for pass2)\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: unused"]
    pub bit_rate_tolerance: ::std::os::raw::c_int,
    #[doc = " Global quality for codecs which cannot change it per frame.\n This should be proportional to MPEG-1/2/4 qscale.\n - encoding: Set by user.\n - decoding: unused"]
    pub global_quality: ::std::os::raw::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub compression_level: ::std::os::raw::c_int,
    #[doc = " AV_CODEC_FLAG_*.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " AV_CODEC_FLAG2_*\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags2: ::std::os::raw::c_int,
    #[doc = " some codecs need / can use extradata like Huffman tables.\n MJPEG: Huffman tables\n rv10: additional flags\n MPEG-4: global headers (they can be in the bitstream or here)\n The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger\n than extradata_size to avoid problems if it is read with the bitstream reader.\n The bytewise contents of extradata must not depend on the architecture or CPU endianness.\n Must be allocated with the av_malloc() family of functions.\n - encoding: Set/allocated/freed by libavcodec.\n - decoding: Set/allocated/freed by user."]
    pub extradata: *mut u8,
    pub extradata_size: ::std::os::raw::c_int,
    #[doc = " This is the fundamental unit of time (in seconds) in terms\n of which frame timestamps are represented. For fixed-fps content,\n timebase should be 1/framerate and timestamp increments should be\n identically 1.\n This often, but not always is the inverse of the frame rate or field rate\n for video. 1/time_base is not the average frame rate if the frame rate is not\n constant.\n\n Like containers, elementary streams also can store timestamps, 1/time_base\n is the unit in which these timestamps are specified.\n As example of such codec time base see ISO/IEC 14496-2:2001(E)\n vop_time_increment_resolution and fixed_vop_rate\n (fixed_vop_rate == 0 implies that it is different from the framerate)\n\n - encoding: MUST be set by user.\n - decoding: unused."]
    pub time_base: AVRational,
    #[doc = " For some codecs, the time base is closer to the field rate than the frame rate.\n Most notably, H.264 and MPEG-2 specify time_base as half of frame duration\n if no telecine is used ...\n\n Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.\n\n @deprecated\n - decoding: Use AVCodecDescriptor.props & AV_CODEC_PROP_FIELDS\n - encoding: Set AVCodecContext.framerate instead\n"]
    pub ticks_per_frame: ::std::os::raw::c_int,
    #[doc = " Codec delay.\n\n Encoding: Number of frames delay there will be from the encoder input to\n           the decoder output. (we assume the decoder matches the spec)\n Decoding: Number of frames delay in addition to what a standard decoder\n           as specified in the spec would produce.\n\n Video:\n   Number of frames the decoded output will be delayed relative to the\n   encoded input.\n\n Audio:\n   For encoding, this field is unused (see initial_padding).\n\n   For decoding, this is the number of samples the decoder needs to\n   output before the decoder's output is valid. When seeking, you should\n   start decoding this many samples prior to your desired seek point.\n\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub delay: ::std::os::raw::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub width: ::std::os::raw::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub height: ::std::os::raw::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_width: ::std::os::raw::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_height: ::std::os::raw::c_int,
    #[doc = " the number of pictures in a group of pictures, or 0 for intra_only\n - encoding: Set by user.\n - decoding: unused"]
    pub gop_size: ::std::os::raw::c_int,
    #[doc = " Pixel format, see AV_PIX_FMT_xxx.\n May be set by the demuxer if known from headers.\n May be overridden by the decoder if it knows better.\n\n @note This field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: Set by user.\n - decoding: Set by user if known, overridden by libavcodec while\n             parsing the data."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " If non NULL, 'draw_horiz_band' is called by the libavcodec\n decoder to draw a horizontal band. It improves cache usage. Not\n all codecs can do that. You must check the codec capabilities\n beforehand.\n When multithreading is used, it may be called from multiple threads\n at the same time; threads might draw different parts of the same AVFrame,\n or multiple AVFrames, and there is no guarantee that slices will be drawn\n in order.\n The function is also used by hardware acceleration APIs.\n It is called at least once during frame decoding to pass\n the data needed for hardware render.\n In that mode instead of pixel data, AVFrame points to\n a structure specific to the acceleration API. The application\n reads the structure and can change some fields to indicate progress\n or mark state.\n - encoding: unused\n - decoding: Set by user.\n @param height the height of the slice\n @param y the y position of the slice\n @param type 1->top field, 2->bottom field, 3->frame\n @param offset offset into the AVFrame.data from which the slice should be read"]
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Callback to negotiate the pixel format. Decoding only, may be set by the\n caller before avcodec_open2().\n\n Called by some decoders to select the pixel format that will be used for\n the output frames. This is mainly used to set up hardware acceleration,\n then the provided format list contains the corresponding hwaccel pixel\n formats alongside the \"software\" one. The software pixel format may also\n be retrieved from \\ref sw_pix_fmt.\n\n This callback will be called when the coded frame properties (such as\n resolution, pixel format, etc.) change and more than one output format is\n supported for those new properties. If a hardware pixel format is chosen\n and initialization for it fails, the callback may be called again\n immediately.\n\n This callback may be called from different threads if the decoder is\n multi-threaded, but not from more than one thread simultaneously.\n\n @param fmt list of formats which may be used in the current\n            configuration, terminated by AV_PIX_FMT_NONE.\n @warning Behavior is undefined if the callback returns a value other\n          than one of the formats in fmt or AV_PIX_FMT_NONE.\n @return the chosen format or AV_PIX_FMT_NONE"]
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    #[doc = " maximum number of B-frames between non-B-frames\n Note: The output will be delayed by max_b_frames+1 relative to the input.\n - encoding: Set by user.\n - decoding: unused"]
    pub max_b_frames: ::std::os::raw::c_int,
    #[doc = " qscale factor between IP and B-frames\n If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_factor: f32,
    #[doc = " qscale offset between IP and B-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_offset: f32,
    #[doc = " Size of the frame reordering buffer in the decoder.\n For MPEG-2 it is 1 IPB or 0 low delay IP.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub has_b_frames: ::std::os::raw::c_int,
    #[doc = " qscale factor between P- and I-frames\n If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_factor: f32,
    #[doc = " qscale offset between P and I-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_offset: f32,
    #[doc = " luminance masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub lumi_masking: f32,
    #[doc = " temporary complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub temporal_cplx_masking: f32,
    #[doc = " spatial complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub spatial_cplx_masking: f32,
    #[doc = " p block masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub p_masking: f32,
    #[doc = " darkness masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub dark_masking: f32,
    #[doc = " slice count\n - encoding: Set by libavcodec.\n - decoding: Set by user (or 0)."]
    pub slice_count: ::std::os::raw::c_int,
    #[doc = " slice offsets in the frame in bytes\n - encoding: Set/allocated by libavcodec.\n - decoding: Set/allocated by user (or NULL)."]
    pub slice_offset: *mut ::std::os::raw::c_int,
    #[doc = " sample aspect ratio (0 if unknown)\n That is the width of a pixel divided by the height of the pixel.\n Numerator and denominator must be relatively prime and smaller than 256 for some video standards.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_cmp: ::std::os::raw::c_int,
    #[doc = " subpixel motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_sub_cmp: ::std::os::raw::c_int,
    #[doc = " macroblock comparison function (not supported yet)\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_cmp: ::std::os::raw::c_int,
    #[doc = " interlaced DCT comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub ildct_cmp: ::std::os::raw::c_int,
    #[doc = " ME diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub dia_size: ::std::os::raw::c_int,
    #[doc = " amount of previous MV predictors (2a+1 x 2a+1 square)\n - encoding: Set by user.\n - decoding: unused"]
    pub last_predictor_count: ::std::os::raw::c_int,
    #[doc = " motion estimation prepass comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_pre_cmp: ::std::os::raw::c_int,
    #[doc = " ME prepass diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub pre_dia_size: ::std::os::raw::c_int,
    #[doc = " subpel ME quality\n - encoding: Set by user.\n - decoding: unused"]
    pub me_subpel_quality: ::std::os::raw::c_int,
    #[doc = " maximum motion estimation search range in subpel units\n If 0 then no limit.\n\n - encoding: Set by user.\n - decoding: unused"]
    pub me_range: ::std::os::raw::c_int,
    #[doc = " slice flags\n - encoding: unused\n - decoding: Set by user."]
    pub slice_flags: ::std::os::raw::c_int,
    #[doc = " macroblock decision mode\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_decision: ::std::os::raw::c_int,
    #[doc = " custom intra quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub intra_matrix: *mut u16,
    #[doc = " custom inter quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub inter_matrix: *mut u16,
    #[doc = " precision of the intra DC coefficient - 8\n - encoding: Set by user.\n - decoding: Set by libavcodec"]
    pub intra_dc_precision: ::std::os::raw::c_int,
    #[doc = " Number of macroblock rows at the top which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_top: ::std::os::raw::c_int,
    #[doc = " Number of macroblock rows at the bottom which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_bottom: ::std::os::raw::c_int,
    #[doc = " minimum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmin: ::std::os::raw::c_int,
    #[doc = " maximum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmax: ::std::os::raw::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub bidir_refine: ::std::os::raw::c_int,
    #[doc = " minimum GOP size\n - encoding: Set by user.\n - decoding: unused"]
    pub keyint_min: ::std::os::raw::c_int,
    #[doc = " number of reference frames\n - encoding: Set by user.\n - decoding: Set by lavc."]
    pub refs: ::std::os::raw::c_int,
    #[doc = " Note: Value depends upon the compare function used for fullpel ME.\n - encoding: Set by user.\n - decoding: unused"]
    pub mv0_threshold: ::std::os::raw::c_int,
    #[doc = " Chromaticity coordinates of the source primaries.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_primaries: AVColorPrimaries,
    #[doc = " Color Transfer Characteristic.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user to override the default output color range value,\n   If not specified, libavcodec sets the color range depending on the\n   output format.\n - decoding: Set by libavcodec, can be set by the user to propagate the\n   color range to components reading from the decoder context."]
    pub color_range: AVColorRange,
    #[doc = " This defines the location of chroma samples.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub chroma_sample_location: AVChromaLocation,
    #[doc = " Number of slices.\n Indicates number of picture subdivisions. Used for parallelized\n decoding.\n - encoding: Set by user\n - decoding: unused"]
    pub slices: ::std::os::raw::c_int,
    #[doc = " Field order\n - encoding: set by libavcodec\n - decoding: Set by user."]
    pub field_order: AVFieldOrder,
    #[doc = "< samples per second"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " number of audio channels\n @deprecated use ch_layout.nb_channels"]
    pub channels: ::std::os::raw::c_int,
    #[doc = "< sample format"]
    pub sample_fmt: AVSampleFormat,
    #[doc = " Number of samples per channel in an audio frame.\n\n - encoding: set by libavcodec in avcodec_open2(). Each submitted frame\n   except the last must contain exactly frame_size samples per channel.\n   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the\n   frame size is not restricted.\n - decoding: may be set by some decoders to indicate constant frame size"]
    pub frame_size: ::std::os::raw::c_int,
    #[doc = " Frame counter, set by libavcodec.\n\n - decoding: total number of frames returned from the decoder so far.\n - encoding: total number of frames passed to the encoder so far.\n\n   @note the counter is not incremented if encoding/decoding resulted in\n   an error.\n   @deprecated use frame_num instead"]
    pub frame_number: ::std::os::raw::c_int,
    #[doc = " number of bytes per packet if constant and known or 0\n Used by some WAV based audio codecs."]
    pub block_align: ::std::os::raw::c_int,
    #[doc = " Audio cutoff bandwidth (0 means \"automatic\")\n - encoding: Set by user.\n - decoding: unused"]
    pub cutoff: ::std::os::raw::c_int,
    #[doc = " Audio channel layout.\n - encoding: set by user.\n - decoding: set by user, may be overwritten by libavcodec.\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Request decoder to use this channel layout if it can (0 for default)\n - encoding: unused\n - decoding: Set by user.\n @deprecated use \"downmix\" codec private option"]
    pub request_channel_layout: u64,
    #[doc = " Type of service that the audio stream conveys.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub audio_service_type: AVAudioServiceType,
    #[doc = " desired sample format\n - encoding: Not used.\n - decoding: Set by user.\n Decoder will decode to this format if it can."]
    pub request_sample_fmt: AVSampleFormat,
    #[doc = " This callback is called at the beginning of each frame to get data\n buffer(s) for it. There may be one contiguous buffer for all the data or\n there may be a buffer per each data plane or anything in between. What\n this means is, you may set however many entries in buf[] you feel necessary.\n Each buffer must be reference-counted using the AVBuffer API (see description\n of buf[] below).\n\n The following fields will be set in the frame before this callback is\n called:\n - format\n - width, height (video only)\n - sample_rate, channel_layout, nb_samples (audio only)\n Their values may differ from the corresponding values in\n AVCodecContext. This callback must use the frame values, not the codec\n context values, to calculate the required buffer size.\n\n This callback must fill the following fields in the frame:\n - data[]\n - linesize[]\n - extended_data:\n   * if the data is planar audio with more than 8 channels, then this\n     callback must allocate and fill extended_data to contain all pointers\n     to all data planes. data[] must hold as many pointers as it can.\n     extended_data must be allocated with av_malloc() and will be freed in\n     av_frame_unref().\n   * otherwise extended_data must point to data\n - buf[] must contain one or more pointers to AVBufferRef structures. Each of\n   the frame's data and extended_data pointers must be contained in these. That\n   is, one AVBufferRef for each allocated chunk of memory, not necessarily one\n   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n - extended_buf and nb_extended_buf must be allocated with av_malloc() by\n   this callback and filled with the extra buffers if there are more\n   buffers than buf[] can hold. extended_buf will be freed in\n   av_frame_unref().\n\n If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call\n avcodec_default_get_buffer2() instead of providing buffers allocated by\n some other means.\n\n Each data plane must be aligned to the maximum required by the target\n CPU.\n\n @see avcodec_default_get_buffer2()\n\n Video:\n\n If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n avcodec_align_dimensions2() should be used to find the required width and\n height, as they normally need to be rounded up to the next multiple of 16.\n\n Some decoders do not support linesizes changing between frames.\n\n If frame multithreading is used, this callback may be called from a\n different thread, but not from more than one at once. Does not need to be\n reentrant.\n\n @see avcodec_align_dimensions2()\n\n Audio:\n\n Decoders request a buffer of a particular size by setting\n AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,\n however, utilize only part of the buffer by setting AVFrame.nb_samples\n to a smaller value in the output frame.\n\n As a convenience, av_samples_get_buffer_size() and\n av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()\n functions to find the required data size and to fill data pointers and\n linesize. In AVFrame.linesize, only linesize[0] may be set for audio\n since all planes must be the same size.\n\n @see av_samples_get_buffer_size(), av_samples_fill_arrays()\n\n - encoding: unused\n - decoding: Set by libavcodec, user can override."]
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< amount of qscale change between easy & hard scenes (0.0-1.0)"]
    pub qcompress: f32,
    #[doc = "< amount of qscale smoothing over time (0.0-1.0)"]
    pub qblur: f32,
    #[doc = " minimum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmin: ::std::os::raw::c_int,
    #[doc = " maximum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmax: ::std::os::raw::c_int,
    #[doc = " maximum quantizer difference between frames\n - encoding: Set by user.\n - decoding: unused"]
    pub max_qdiff: ::std::os::raw::c_int,
    #[doc = " decoder bitstream buffer size\n - encoding: Set by user.\n - decoding: May be set by libavcodec."]
    pub rc_buffer_size: ::std::os::raw::c_int,
    #[doc = " ratecontrol override, see RcOverride\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub rc_override_count: ::std::os::raw::c_int,
    pub rc_override: *mut RcOverride,
    #[doc = " maximum bitrate\n - encoding: Set by user.\n - decoding: Set by user, may be overwritten by libavcodec."]
    pub rc_max_rate: i64,
    #[doc = " minimum bitrate\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_min_rate: i64,
    #[doc = " Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_max_available_vbv_use: f32,
    #[doc = " Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_min_vbv_overflow_use: f32,
    #[doc = " Number of bits which should be loaded into the rc buffer before decoding starts.\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_initial_buffer_occupancy: ::std::os::raw::c_int,
    #[doc = " trellis RD quantization\n - encoding: Set by user.\n - decoding: unused"]
    pub trellis: ::std::os::raw::c_int,
    #[doc = " pass1 encoding statistics output buffer\n - encoding: Set by libavcodec.\n - decoding: unused"]
    pub stats_out: *mut ::std::os::raw::c_char,
    #[doc = " pass2 encoding statistics input buffer\n Concatenated stuff from stats_out of pass1 should be placed here.\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub stats_in: *mut ::std::os::raw::c_char,
    #[doc = " Work around bugs in encoders which sometimes cannot be detected automatically.\n - encoding: Set by user\n - decoding: Set by user"]
    pub workaround_bugs: ::std::os::raw::c_int,
    #[doc = " strictly follow the standard (MPEG-4, ...).\n - encoding: Set by user.\n - decoding: Set by user.\n Setting this to STRICT or higher means the encoder and decoder will\n generally do stupid things, whereas setting it to unofficial or lower\n will mean the encoder might produce output that is not supported by all\n spec-compliant decoders. Decoders don't differentiate between normal,\n unofficial and experimental (that is, they always try to decode things\n when they can) unless they are explicitly asked to behave stupidly\n (=strictly conform to the specs)\n This may only be set to one of the FF_COMPLIANCE_* values in defs.h."]
    pub strict_std_compliance: ::std::os::raw::c_int,
    #[doc = " error concealment flags\n - encoding: unused\n - decoding: Set by user."]
    pub error_concealment: ::std::os::raw::c_int,
    #[doc = " debug\n - encoding: Set by user.\n - decoding: Set by user."]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Error recognition; may misdetect some more or less valid parts as errors.\n This is a bitfield of the AV_EF_* values defined in defs.h.\n\n - encoding: Set by user.\n - decoding: Set by user."]
    pub err_recognition: ::std::os::raw::c_int,
    #[doc = " opaque 64-bit number (generally a PTS) that will be reordered and\n output in AVFrame.reordered_opaque\n - encoding: Set by libavcodec to the reordered_opaque of the input\n             frame corresponding to the last returned packet. Only\n             supported by encoders with the\n             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.\n - decoding: Set by user.\n\n @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead"]
    pub reordered_opaque: i64,
    #[doc = " Hardware accelerator in use\n - encoding: unused.\n - decoding: Set by libavcodec"]
    pub hwaccel: *const AVHWAccel,
    #[doc = " Legacy hardware accelerator context.\n\n For some hardware acceleration methods, the caller may use this field to\n signal hwaccel-specific data to the codec. The struct pointed to by this\n pointer is hwaccel-dependent and defined in the respective header. Please\n refer to the FFmpeg HW accelerator documentation to know how to fill\n this.\n\n In most cases this field is optional - the necessary information may also\n be provided to libavcodec through @ref hw_frames_ctx or @ref\n hw_device_ctx (see avcodec_get_hw_config()). However, in some cases it\n may be the only method of signalling some (optional) information.\n\n The struct and its contents are owned by the caller.\n\n - encoding: May be set by the caller before avcodec_open2(). Must remain\n             valid until avcodec_free_context().\n - decoding: May be set by the caller in the get_format() callback.\n             Must remain valid until the next get_format() call,\n             or avcodec_free_context() (whichever comes first)."]
    pub hwaccel_context: *mut ::std::os::raw::c_void,
    #[doc = " error\n - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.\n - decoding: unused"]
    pub error: [u64; 8usize],
    #[doc = " DCT algorithm, see FF_DCT_* below\n - encoding: Set by user.\n - decoding: unused"]
    pub dct_algo: ::std::os::raw::c_int,
    #[doc = " IDCT algorithm, see FF_IDCT_* below.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub idct_algo: ::std::os::raw::c_int,
    #[doc = " bits per sample/pixel from the demuxer (needed for huffyuv).\n - encoding: Set by libavcodec.\n - decoding: Set by user."]
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    #[doc = " Bits per sample/pixel of internal libavcodec pixel/sample format.\n - encoding: set by user.\n - decoding: set by libavcodec."]
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    #[doc = " low resolution decoding, 1-> 1/2 size, 2->1/4 size\n - encoding: unused\n - decoding: Set by user."]
    pub lowres: ::std::os::raw::c_int,
    #[doc = " thread count\n is used to decide how many independent tasks should be passed to execute()\n - encoding: Set by user.\n - decoding: Set by user."]
    pub thread_count: ::std::os::raw::c_int,
    #[doc = " Which multithreading methods to use.\n Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,\n so clients which cannot provide future frames should not use it.\n\n - encoding: Set by user, otherwise the default is used.\n - decoding: Set by user, otherwise the default is used."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " Which multithreading methods are in use by the codec.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub active_thread_type: ::std::os::raw::c_int,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n @param count the number of things to execute\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n @param c context passed also to func\n @param count the number of things to execute\n @param arg2 argument passed unchanged to func\n @param ret return values of executed functions, must have space for \"count\" values. May be NULL.\n @param func function that will be called count times, with jobnr from 0 to count-1.\n             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no\n             two instances of func executing at the same time will have the same threadnr.\n @return always 0 currently, but code should handle a future improvement where when any call to func\n         returns < 0 no further calls to func may be done and < 0 is returned.\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                    jobnr: ::std::os::raw::c_int,
                    threadnr: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " noise vs. sse weight for the nsse comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub nsse_weight: ::std::os::raw::c_int,
    #[doc = " profile\n - encoding: Set by user.\n - decoding: Set by libavcodec.\n See the AV_PROFILE_* defines in defs.h."]
    pub profile: ::std::os::raw::c_int,
    #[doc = " Encoding level descriptor.\n - encoding: Set by user, corresponds to a specific level defined by the\n   codec, usually corresponding to the profile level, if not specified it\n   is set to FF_LEVEL_UNKNOWN.\n - decoding: Set by libavcodec.\n See AV_LEVEL_* in defs.h."]
    pub level: ::std::os::raw::c_int,
    #[doc = " Skip loop filtering for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_loop_filter: AVDiscard,
    #[doc = " Skip IDCT/dequantization for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_idct: AVDiscard,
    #[doc = " Skip decoding for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_frame: AVDiscard,
    #[doc = " Header containing style information for text subtitles.\n For SUBTITLE_ASS subtitle type, it should contain the whole ASS\n [Script Info] and [V4+ Styles] section, plus the [Events] line and\n the Format line following. It shouldn't include any Dialogue line.\n - encoding: Set/allocated/freed by user (before avcodec_open2())\n - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())"]
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of \"priming\" samples (padding) inserted by the\n encoder at the beginning of the audio. I.e. this number of leading\n decoded samples must be discarded by the caller to get the original audio\n without leading padding.\n\n - decoding: unused\n - encoding: Set by libavcodec. The timestamps on the output packets are\n             adjusted by the encoder so that they always refer to the\n             first sample of the data actually contained in the packet,\n             including any added padding.  E.g. if the timebase is\n             1/samplerate and the timestamp of the first input sample is\n             0, the timestamp of the first output packet will be\n             -initial_padding."]
    pub initial_padding: ::std::os::raw::c_int,
    #[doc = " - decoding: For codecs that store a framerate value in the compressed\n             bitstream, the decoder may export it here. { 0, 1} when\n             unknown.\n - encoding: May be used to signal the framerate of CFR content to an\n             encoder."]
    pub framerate: AVRational,
    #[doc = " Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.\n - encoding: unused.\n - decoding: Set by libavcodec before calling get_format()"]
    pub sw_pix_fmt: AVPixelFormat,
    #[doc = " Timebase in which pkt_dts/pts and AVPacket.dts/pts are expressed.\n - encoding: unused.\n - decoding: set by user."]
    pub pkt_timebase: AVRational,
    #[doc = " AVCodecDescriptor\n - encoding: unused.\n - decoding: set by libavcodec."]
    pub codec_descriptor: *const AVCodecDescriptor,
    #[doc = " Current statistics for PTS correction.\n - decoding: maintained and used by libavcodec, not intended to be used by user apps\n - encoding: unused"]
    pub pts_correction_num_faulty_pts: i64,
    #[doc = " Number of incorrect PTS values so far"]
    pub pts_correction_num_faulty_dts: i64,
    #[doc = " Number of incorrect DTS values so far"]
    pub pts_correction_last_pts: i64,
    #[doc = " PTS of the last frame"]
    pub pts_correction_last_dts: i64,
    #[doc = " Character encoding of the input subtitles file.\n - decoding: set by user\n - encoding: unused"]
    pub sub_charenc: *mut ::std::os::raw::c_char,
    #[doc = " Subtitles character encoding mode. Formats or codecs might be adjusting\n this setting (if they are doing the conversion themselves for instance).\n - decoding: set by libavcodec\n - encoding: unused"]
    pub sub_charenc_mode: ::std::os::raw::c_int,
    #[doc = " Skip processing alpha if supported by codec.\n Note that if the format uses pre-multiplied alpha (common with VP6,\n and recommended due to better video quality/compression)\n the image will look as if alpha-blended onto a black background.\n However for formats that do not use pre-multiplied alpha\n there might be serious artefacts (though e.g. libswscale currently\n assumes pre-multiplied alpha anyway).\n\n - decoding: set by user\n - encoding: unused"]
    pub skip_alpha: ::std::os::raw::c_int,
    #[doc = " Number of samples to skip after a discontinuity\n - decoding: unused\n - encoding: set by libavcodec"]
    pub seek_preroll: ::std::os::raw::c_int,
    #[doc = " custom intra quantization matrix\n - encoding: Set by user, can be NULL.\n - decoding: unused."]
    pub chroma_intra_matrix: *mut u16,
    #[doc = " dump format separator.\n can be \", \" or \"\\n      \" or anything else\n - encoding: Set by user.\n - decoding: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " ',' separated list of allowed decoders.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " Properties of the stream that gets decoded\n - encoding: unused\n - decoding: set by libavcodec"]
    pub properties: ::std::os::raw::c_uint,
    #[doc = " Additional data associated with the entire coded stream.\n\n - decoding: may be set by user before calling avcodec_open2().\n - encoding: may be set by libavcodec after avcodec_open2()."]
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: ::std::os::raw::c_int,
    #[doc = " A reference to the AVHWFramesContext describing the input (for encoding)\n or output (decoding) frames. The reference is set by the caller and\n afterwards owned (and freed) by libavcodec - it should never be read by\n the caller after being set.\n\n - decoding: This field should be set by the caller from the get_format()\n             callback. The previous reference (if any) will always be\n             unreffed by libavcodec before the get_format() call.\n\n             If the default get_buffer2() is used with a hwaccel pixel\n             format, then this AVHWFramesContext will be used for\n             allocating the frame buffers.\n\n - encoding: For hardware encoders configured to use a hwaccel pixel\n             format, this field should be set by the caller to a reference\n             to the AVHWFramesContext describing input frames.\n             AVHWFramesContext.format must be equal to\n             AVCodecContext.pix_fmt.\n\n             This field should be set before avcodec_open2() is called."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding.\n\n - decoding: unused\n - encoding: unused"]
    pub trailing_padding: ::std::os::raw::c_int,
    #[doc = " The number of pixels per image to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_pixels: i64,
    #[doc = " A reference to the AVHWDeviceContext describing the device which will\n be used by a hardware encoder/decoder.  The reference is set by the\n caller and afterwards owned (and freed) by libavcodec.\n\n This should be used if either the codec device does not require\n hardware frames or any that are used are to be allocated internally by\n libavcodec.  If the user wishes to supply any of the frames used as\n encoder input or decoder output then hw_frames_ctx should be used\n instead.  When hw_frames_ctx is set in get_format() for a decoder, this\n field will be ignored while decoding the associated stream segment, but\n may again be used on a following one after another get_format() call.\n\n For both encoders and decoders this field should be set before\n avcodec_open2() is called and must not be written to thereafter.\n\n Note that some decoders may require this field to be set initially in\n order to support hw_frames_ctx at all - in that case, all frames\n contexts used must be created on the same device."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated\n decoding (if active).\n - encoding: unused\n - decoding: Set by user (either before avcodec_open2(), or in the\n             AVCodecContext.get_format callback)"]
    pub hwaccel_flags: ::std::os::raw::c_int,
    #[doc = " Video decoding only. Certain video codecs support cropping, meaning that\n only a sub-rectangle of the decoded frame is intended for display.  This\n option controls how cropping is handled by libavcodec.\n\n When set to 1 (the default), libavcodec will apply cropping internally.\n I.e. it will modify the output frame width/height fields and offset the\n data pointers (only by as much as possible while preserving alignment, or\n by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that\n the frames output by the decoder refer only to the cropped area. The\n crop_* fields of the output frames will be zero.\n\n When set to 0, the width/height fields of the output frames will be set\n to the coded dimensions and the crop_* fields will describe the cropping\n rectangle. Applying the cropping is left to the caller.\n\n @warning When hardware acceleration with opaque output frames is used,\n libavcodec is unable to apply cropping from the top/left border.\n\n @note when this option is set to zero, the width/height fields of the\n AVCodecContext and output AVFrames have different meanings. The codec\n context fields store display dimensions (with the coded dimensions in\n coded_width/height), while the frame fields store the coded dimensions\n (with the display dimensions being determined by the crop_* fields)."]
    pub apply_cropping: ::std::os::raw::c_int,
    pub extra_hw_frames: ::std::os::raw::c_int,
    #[doc = " The percentage of damaged samples to discard a frame.\n\n - decoding: set by user\n - encoding: unused"]
    pub discard_damaged_percentage: ::std::os::raw::c_int,
    #[doc = " The number of samples per frame to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_samples: i64,
    #[doc = " Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of\n metadata exported in frame, packet, or coded stream side data by\n decoders and encoders.\n\n - decoding: set by user\n - encoding: set by user"]
    pub export_side_data: ::std::os::raw::c_int,
    #[doc = " This callback is called at the beginning of each packet to get a data\n buffer for it.\n\n The following field will be set in the packet before this callback is\n called:\n - size\n This callback must use the above value to calculate the required buffer size,\n which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.\n\n In some specific cases, the encoder may not use the entire buffer allocated by this\n callback. This will be reflected in the size value in the packet once returned by\n avcodec_receive_packet().\n\n This callback must fill the following fields in the packet:\n - data: alignment requirements for AVPacket apply, if any. Some architectures and\n   encoders may benefit from having aligned data.\n - buf: must contain a pointer to an AVBufferRef structure. The packet's\n   data pointer must be contained in it. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n\n If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call\n avcodec_default_get_encode_buffer() instead of providing a buffer allocated by\n some other means.\n\n The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_ flags.\n They may be used for example to hint what use the buffer may get after being\n created.\n Implementations of this callback may ignore flags they don't understand.\n If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the packet may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n This callback must be thread-safe, as when frame threading is used, it may\n be called from multiple threads simultaneously.\n\n @see avcodec_default_get_encode_buffer()\n\n - encoding: Set by libavcodec, user can override.\n - decoding: unused"]
    pub get_encode_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            pkt: *mut AVPacket,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Audio channel layout.\n - encoding: must be set by the caller, to one of AVCodec.ch_layouts.\n - decoding: may be set by the caller if known e.g. from the container.\n             The decoder can then override during decoding as needed."]
    pub ch_layout: AVChannelLayout,
    #[doc = " Frame counter, set by libavcodec.\n\n - decoding: total number of frames returned from the decoder so far.\n - encoding: total number of frames passed to the encoder so far.\n\n   @note the counter is not incremented if encoding/decoding resulted in\n   an error."]
    pub frame_num: i64,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecContext>(),
        944usize,
        concat!("Size of: ", stringify!(AVCodecContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(log_level_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_tag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_rate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_rate_tolerance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate_tolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_quality) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(global_quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression_level) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(compression_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ticks_per_frame) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ticks_per_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_width) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_height) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gop_size) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(gop_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).draw_horiz_band) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(draw_horiz_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_format) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_b_frames) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_b_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_quant_factor) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_quant_offset) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_b_frames) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(has_b_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_quant_factor) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_quant_offset) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lumi_masking) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lumi_masking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporal_cplx_masking) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(temporal_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spatial_cplx_masking) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(spatial_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_masking) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_masking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dark_masking) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dark_masking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_count) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_offset) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).me_cmp) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).me_sub_cmp) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_sub_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_cmp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ildct_cmp) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ildct_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dia_size) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dia_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_predictor_count) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(last_predictor_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).me_pre_cmp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_pre_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_dia_size) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_dia_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).me_subpel_quality) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_subpel_quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).me_range) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_flags) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_decision) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_decision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_matrix) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inter_matrix) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_dc_precision) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_top) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_bottom) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_lmin) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_lmax) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bidir_refine) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bidir_refine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyint_min) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(keyint_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mv0_threshold) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv0_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_trc) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_sample_location) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_sample_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slices) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_order) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_fmt) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_size) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_number) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_align) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cutoff) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_channel_layout) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_service_type) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(audio_service_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_sample_fmt) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_sample_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_buffer2) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_buffer2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qcompress) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qcompress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qblur) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qblur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qmin) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qmax) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_qdiff) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_qdiff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_buffer_size) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_override_count) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_override) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_max_rate) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_min_rate) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_max_available_vbv_use) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_available_vbv_use)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_min_vbv_overflow_use) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_vbv_overflow_use)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_initial_buffer_occupancy) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_buffer_occupancy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trellis) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trellis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats_out) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats_in) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workaround_bugs) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(workaround_bugs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_std_compliance) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_concealment) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_concealment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_recognition) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(err_recognition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reordered_opaque) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwaccel) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwaccel_context) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dct_algo) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idct_algo) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_coded_sample) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_raw_sample) as usize - ptr as usize },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowres) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lowres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_count) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_type) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_thread_type) as usize - ptr as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(active_thread_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute2) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsse_weight) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nsse_weight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_loop_filter) as usize - ptr as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_loop_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_idct) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_idct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_frame) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtitle_header) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtitle_header_size) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_padding) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw_pix_fmt) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sw_pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_timebase) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pkt_timebase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_descriptor) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pts_correction_num_faulty_pts) as usize - ptr as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_pts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pts_correction_num_faulty_dts) as usize - ptr as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_correction_last_pts) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_correction_last_dts) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_charenc) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_charenc_mode) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_alpha) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek_preroll) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_intra_matrix) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_intra_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_separator) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_whitelist) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_side_data) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_coded_side_data) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_frames_ctx) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailing_padding) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_pixels) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_device_ctx) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwaccel_flags) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply_cropping) as usize - ptr as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(apply_cropping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_hw_frames) as usize - ptr as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discard_damaged_percentage) as usize - ptr as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(discard_damaged_percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_samples) as usize - ptr as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).export_side_data) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(export_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_encode_buffer) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_encode_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layout) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ch_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_num)
        )
    );
}
impl ::std::fmt::Debug for AVCodecContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVCodecContext {{ av_class: {:?}, log_level_offset: {:?}, codec_type: {:?}, codec: {:?}, codec_id: {:?}, codec_tag: {:?}, priv_data: {:?}, internal: {:?}, opaque: {:?}, bit_rate: {:?}, bit_rate_tolerance: {:?}, global_quality: {:?}, compression_level: {:?}, flags: {:?}, flags2: {:?}, extradata: {:?}, extradata_size: {:?}, time_base: {:?}, ticks_per_frame: {:?}, delay: {:?}, width: {:?}, height: {:?}, coded_width: {:?}, coded_height: {:?}, gop_size: {:?}, pix_fmt: {:?}, draw_horiz_band: {:?}, get_format: {:?}, max_b_frames: {:?}, b_quant_factor: {:?}, b_quant_offset: {:?}, has_b_frames: {:?}, i_quant_factor: {:?}, i_quant_offset: {:?}, lumi_masking: {:?}, temporal_cplx_masking: {:?}, spatial_cplx_masking: {:?}, p_masking: {:?}, dark_masking: {:?}, slice_count: {:?}, slice_offset: {:?}, sample_aspect_ratio: {:?}, me_cmp: {:?}, me_sub_cmp: {:?}, mb_cmp: {:?}, ildct_cmp: {:?}, dia_size: {:?}, last_predictor_count: {:?}, me_pre_cmp: {:?}, pre_dia_size: {:?}, me_subpel_quality: {:?}, me_range: {:?}, slice_flags: {:?}, mb_decision: {:?}, intra_matrix: {:?}, inter_matrix: {:?}, intra_dc_precision: {:?}, skip_top: {:?}, skip_bottom: {:?}, mb_lmin: {:?}, mb_lmax: {:?}, bidir_refine: {:?}, keyint_min: {:?}, refs: {:?}, mv0_threshold: {:?}, color_primaries: {:?}, color_trc: {:?}, colorspace: {:?}, color_range: {:?}, chroma_sample_location: {:?}, slices: {:?}, field_order: {:?}, sample_rate: {:?}, channels: {:?}, sample_fmt: {:?}, frame_size: {:?}, frame_number: {:?}, block_align: {:?}, cutoff: {:?}, channel_layout: {:?}, request_channel_layout: {:?}, audio_service_type: {:?}, request_sample_fmt: {:?}, get_buffer2: {:?}, qcompress: {:?}, qblur: {:?}, qmin: {:?}, qmax: {:?}, max_qdiff: {:?}, rc_buffer_size: {:?}, rc_override_count: {:?}, rc_override: {:?}, rc_max_rate: {:?}, rc_min_rate: {:?}, rc_max_available_vbv_use: {:?}, rc_min_vbv_overflow_use: {:?}, rc_initial_buffer_occupancy: {:?}, trellis: {:?}, stats_out: {:?}, stats_in: {:?}, workaround_bugs: {:?}, strict_std_compliance: {:?}, error_concealment: {:?}, debug: {:?}, err_recognition: {:?}, reordered_opaque: {:?}, hwaccel: {:?}, hwaccel_context: {:?}, error: {:?}, dct_algo: {:?}, idct_algo: {:?}, bits_per_coded_sample: {:?}, bits_per_raw_sample: {:?}, lowres: {:?}, thread_count: {:?}, thread_type: {:?}, active_thread_type: {:?}, execute: {:?}, execute2: {:?}, nsse_weight: {:?}, profile: {:?}, level: {:?}, skip_loop_filter: {:?}, skip_idct: {:?}, skip_frame: {:?}, subtitle_header: {:?}, subtitle_header_size: {:?}, initial_padding: {:?}, framerate: {:?}, sw_pix_fmt: {:?}, pkt_timebase: {:?}, codec_descriptor: {:?}, pts_correction_num_faulty_pts: {:?}, pts_correction_num_faulty_dts: {:?}, pts_correction_last_pts: {:?}, pts_correction_last_dts: {:?}, sub_charenc: {:?}, sub_charenc_mode: {:?}, skip_alpha: {:?}, seek_preroll: {:?}, chroma_intra_matrix: {:?}, dump_separator: {:?}, codec_whitelist: {:?}, properties: {:?}, coded_side_data: {:?}, nb_coded_side_data: {:?}, hw_frames_ctx: {:?}, trailing_padding: {:?}, max_pixels: {:?}, hw_device_ctx: {:?}, hwaccel_flags: {:?}, apply_cropping: {:?}, extra_hw_frames: {:?}, discard_damaged_percentage: {:?}, max_samples: {:?}, export_side_data: {:?}, get_encode_buffer: {:?}, ch_layout: {:?}, frame_num: {:?} }}" , self . av_class , self . log_level_offset , self . codec_type , self . codec , self . codec_id , self . codec_tag , self . priv_data , self . internal , self . opaque , self . bit_rate , self . bit_rate_tolerance , self . global_quality , self . compression_level , self . flags , self . flags2 , self . extradata , self . extradata_size , self . time_base , self . ticks_per_frame , self . delay , self . width , self . height , self . coded_width , self . coded_height , self . gop_size , self . pix_fmt , self . draw_horiz_band , self . get_format , self . max_b_frames , self . b_quant_factor , self . b_quant_offset , self . has_b_frames , self . i_quant_factor , self . i_quant_offset , self . lumi_masking , self . temporal_cplx_masking , self . spatial_cplx_masking , self . p_masking , self . dark_masking , self . slice_count , self . slice_offset , self . sample_aspect_ratio , self . me_cmp , self . me_sub_cmp , self . mb_cmp , self . ildct_cmp , self . dia_size , self . last_predictor_count , self . me_pre_cmp , self . pre_dia_size , self . me_subpel_quality , self . me_range , self . slice_flags , self . mb_decision , self . intra_matrix , self . inter_matrix , self . intra_dc_precision , self . skip_top , self . skip_bottom , self . mb_lmin , self . mb_lmax , self . bidir_refine , self . keyint_min , self . refs , self . mv0_threshold , self . color_primaries , self . color_trc , self . colorspace , self . color_range , self . chroma_sample_location , self . slices , self . field_order , self . sample_rate , self . channels , self . sample_fmt , self . frame_size , self . frame_number , self . block_align , self . cutoff , self . channel_layout , self . request_channel_layout , self . audio_service_type , self . request_sample_fmt , self . get_buffer2 , self . qcompress , self . qblur , self . qmin , self . qmax , self . max_qdiff , self . rc_buffer_size , self . rc_override_count , self . rc_override , self . rc_max_rate , self . rc_min_rate , self . rc_max_available_vbv_use , self . rc_min_vbv_overflow_use , self . rc_initial_buffer_occupancy , self . trellis , self . stats_out , self . stats_in , self . workaround_bugs , self . strict_std_compliance , self . error_concealment , self . debug , self . err_recognition , self . reordered_opaque , self . hwaccel , self . hwaccel_context , self . error , self . dct_algo , self . idct_algo , self . bits_per_coded_sample , self . bits_per_raw_sample , self . lowres , self . thread_count , self . thread_type , self . active_thread_type , self . execute , self . execute2 , self . nsse_weight , self . profile , self . level , self . skip_loop_filter , self . skip_idct , self . skip_frame , self . subtitle_header , self . subtitle_header_size , self . initial_padding , self . framerate , self . sw_pix_fmt , self . pkt_timebase , self . codec_descriptor , self . pts_correction_num_faulty_pts , self . pts_correction_num_faulty_dts , self . pts_correction_last_pts , self . pts_correction_last_dts , self . sub_charenc , self . sub_charenc_mode , self . skip_alpha , self . seek_preroll , self . chroma_intra_matrix , self . dump_separator , self . codec_whitelist , self . properties , self . coded_side_data , self . nb_coded_side_data , self . hw_frames_ctx , self . trailing_padding , self . max_pixels , self . hw_device_ctx , self . hwaccel_flags , self . apply_cropping , self . extra_hw_frames , self . discard_damaged_percentage , self . max_samples , self . export_side_data , self . get_encode_buffer , self . ch_layout , self . frame_num)
    }
}
#[doc = " @defgroup lavc_hwaccel AVHWAccel\n\n @note  Nothing in this structure should be accessed by the user.  At some\n        point in future it will not be externally visible at all.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWAccel {
    #[doc = " Name of the hardware accelerated codec.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name)."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Type of codec implemented by the hardware accelerator.\n\n See AVMEDIA_TYPE_xxx"]
    pub type_: AVMediaType,
    #[doc = " Codec implemented by the hardware accelerator.\n\n See AV_CODEC_ID_xxx"]
    pub id: AVCodecID,
    #[doc = " Supported pixel format.\n\n Only hardware accelerated formats are supported here."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Hardware accelerated codec capabilities.\n see AV_HWACCEL_CODEC_CAP_*"]
    pub capabilities: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    const UNINIT: ::std::mem::MaybeUninit<AVHWAccel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHWAccel>(),
        24usize,
        concat!("Size of: ", stringify!(AVHWAccel))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWAccel>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWAccel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(capabilities)
        )
    );
}
pub const SUBTITLE_NONE: AVSubtitleType = 0;
#[doc = "< A bitmap, pict will be set"]
pub const SUBTITLE_BITMAP: AVSubtitleType = 1;
#[doc = " Plain text, the text field must be set by the decoder and is\n authoritative. ass and pict fields may contain approximations."]
pub const SUBTITLE_TEXT: AVSubtitleType = 2;
#[doc = " Formatted text, the ass field must be set by the decoder and is\n authoritative. pict and text fields may contain approximations."]
pub const SUBTITLE_ASS: AVSubtitleType = 3;
#[doc = " @}"]
pub type AVSubtitleType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitleRect {
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< width            of pict, undefined when pict is not set"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< height           of pict, undefined when pict is not set"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< number of colors in pict, undefined when pict is not set"]
    pub nb_colors: ::std::os::raw::c_int,
    #[doc = " data+linesize for the bitmap of this subtitle.\n Can be set for text/ass as well once they are rendered."]
    pub data: [*mut u8; 4usize],
    pub linesize: [::std::os::raw::c_int; 4usize],
    pub type_: AVSubtitleType,
    #[doc = "< 0 terminated plain UTF-8 text"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = " 0 terminated ASS/SSA compatible event line.\n The presentation of this is unaffected by the other values in this\n struct."]
    pub ass: *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    const UNINIT: ::std::mem::MaybeUninit<AVSubtitleRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVSubtitleRect>(),
        104usize,
        concat!("Size of: ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitleRect>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_colors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(nb_colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ass) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(ass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    #[doc = "< Same as packet pts, in AV_TIME_BASE"]
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    const UNINIT: ::std::mem::MaybeUninit<AVSubtitle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVSubtitle>(),
        32usize,
        concat!("Size of: ", stringify!(AVSubtitle))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitle>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_display_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(start_display_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_display_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(end_display_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_rects) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(rects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(pts)
        )
    );
}
extern "C" {
    #[doc = " Return the LIBAVCODEC_VERSION_INT constant."]
    pub fn avcodec_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavcodec build-time configuration."]
    pub fn avcodec_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavcodec license."]
    pub fn avcodec_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocate an AVCodecContext and set its fields to default values. The\n resulting struct should be freed with avcodec_free_context().\n\n @param codec if non-NULL, allocate private data and initialize defaults\n              for the given codec. It is illegal to then call avcodec_open2()\n              with a different codec.\n              If NULL, then the codec-specific defaults won't be initialized,\n              which may result in suboptimal default settings (this is\n              important mainly for encoders, e.g. libx264).\n\n @return An AVCodecContext filled with default values or NULL on failure."]
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    #[doc = " Free the codec context and everything associated with it and write NULL to\n the provided pointer."]
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVCodecContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Get the AVClass for AVSubtitleRect. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Fill the parameters struct based on the values from the supplied codec\n context. Any allocated fields in par are freed and replaced with duplicates\n of the corresponding fields in codec.\n\n @return >= 0 on success, a negative AVERROR code on failure"]
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill the codec context based on the values from the supplied codec\n parameters. Any allocated fields in codec that have a corresponding field in\n par are freed and replaced with duplicates of the corresponding field in par.\n Fields in codec that do not have a counterpart in par are not touched.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the AVCodecContext to use the given AVCodec. Prior to using this\n function the context has to be allocated with avcodec_alloc_context3().\n\n The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),\n avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for\n retrieving a codec.\n\n Depending on the codec, you might need to set options in the codec context\n also for decoding (e.g. width, height, or the pixel or audio sample format in\n the case the information is not available in the bitstream, as when decoding\n raw audio or video).\n\n Options in the codec context can be set either by setting them in the options\n AVDictionary, or by setting the values in the context itself, directly or by\n using the av_opt_set() API before calling this function.\n\n Example:\n @code\n av_dict_set(&opts, \"b\", \"2.5M\", 0);\n codec = avcodec_find_decoder(AV_CODEC_ID_H264);\n if (!codec)\n     exit(1);\n\n context = avcodec_alloc_context3(codec);\n\n if (avcodec_open2(context, codec, opts) < 0)\n     exit(1);\n @endcode\n\n In the case AVCodecParameters are available (e.g. when demuxing a stream\n using libavformat, and accessing the AVStream contained in the demuxer), the\n codec parameters can be copied to the codec context using\n avcodec_parameters_to_context(), as in the following example:\n\n @code\n AVStream *stream = ...;\n context = avcodec_alloc_context3(codec);\n if (avcodec_parameters_to_context(context, stream->codecpar) < 0)\n     exit(1);\n if (avcodec_open2(context, codec, NULL) < 0)\n     exit(1);\n @endcode\n\n @note Always call this function before using decoding routines (such as\n @ref avcodec_receive_frame()).\n\n @param avctx The context to initialize.\n @param codec The codec to open this context for. If a non-NULL codec has been\n              previously passed to avcodec_alloc_context3() or\n              for this context, then this parameter MUST be either NULL or\n              equal to the previously passed codec.\n @param options A dictionary filled with AVCodecContext and codec-private\n                options, which are set on top of the options already set in\n                avctx, can be NULL. On return this object will be filled with\n                options that were not found in the avctx codec context.\n\n @return zero on success, a negative value on error\n @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),\n      av_dict_set(), av_opt_set(), av_opt_find(), avcodec_parameters_to_context()"]
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a given AVCodecContext and free all the data associated with it\n (but not the AVCodecContext itself).\n\n Calling this function on an AVCodecContext that hasn't been opened will free\n the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL\n codec. Subsequent calls will do nothing.\n\n @note Do not use this function. Use avcodec_free_context() to destroy a\n codec context (either open or closed). Opening and closing a codec context\n multiple times is not supported anymore -- use multiple codec contexts\n instead."]
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all allocated data in the given subtitle struct.\n\n @param sub AVSubtitle to free."]
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_buffer2(). It is made public so\n it can be called by custom get_buffer2() implementations for decoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_encode_buffer(). It is made public so\n it can be called by custom get_encode_buffer() implementations for encoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_encode_buffer(
        s: *mut AVCodecContext,
        pkt: *mut AVPacket,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you do not use any horizontal\n padding.\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you also ensure that all\n line sizes are a multiple of the respective linesize_align[i].\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        linesize_align: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position\n @deprecated Use av_chroma_location_enum_to_pos() instead."]
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position\n @deprecated Use av_chroma_location_pos_to_enum() instead."]
    pub fn avcodec_chroma_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Decode a subtitle message.\n Return a negative value on error, otherwise return the number of bytes used.\n If no subtitle could be decompressed, got_sub_ptr is zero.\n Otherwise, the subtitle is stored in *sub.\n Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for\n simplicity, because the performance difference is expected to be negligible\n and reusing a get_buffer written for video codecs would probably perform badly\n due to a potentially very different allocation pattern.\n\n Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n and output. This means that for some packets they will not immediately\n produce decoded output and need to be flushed at the end of decoding to get\n all the decoded data. Flushing is done by calling this function with packets\n with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n returning subtitles. It is safe to flush even those decoders that are not\n marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n before packets may be fed to the decoder.\n\n @param avctx the codec context\n @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,\n                 must be freed with avsubtitle_free if *got_sub_ptr is set.\n @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.\n @param[in] avpkt The input AVPacket containing the input buffer."]
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut ::std::os::raw::c_int,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Supply raw packet data as input to a decoder.\n\n Internally, this call will copy relevant AVCodecContext fields, which can\n influence decoding per-packet, and apply them when the packet is actually\n decoded. (For example AVCodecContext.skip_frame, which might direct the\n decoder to drop the frame contained by the packet sent with this function.)\n\n @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n          larger than the actual read bytes because some optimized bitstream\n          readers read 32 or 64 bits at once and could read over the end.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n       before packets may be fed to the decoder.\n\n @param avctx codec context\n @param[in] avpkt The input AVPacket. Usually, this will be a single video\n                  frame, or several complete audio frames.\n                  Ownership of the packet remains with the caller, and the\n                  decoder will not write to the packet. The decoder may create\n                  a reference to the packet data (or copy it if the packet is\n                  not reference-counted).\n                  Unlike with older APIs, the packet is always fully consumed,\n                  and if it contains multiple frames (e.g. some audio codecs),\n                  will require you to call avcodec_receive_frame() multiple\n                  times afterwards before you can send a new packet.\n                  It can be NULL (or an AVPacket with data set to NULL and\n                  size set to 0); in this case, it is considered a flush\n                  packet, which signals the end of the stream. Sending the\n                  first flush packet will return success. Subsequent ones are\n                  unnecessary and will return AVERROR_EOF. If the decoder\n                  still has frames buffered, it will return them after sending\n                  a flush packet.\n\n @retval 0                 success\n @retval AVERROR(EAGAIN)   input is not accepted in the current state - user\n                           must read output with avcodec_receive_frame() (once\n                           all output is read, the packet should be resent,\n                           and the call will not fail with EAGAIN).\n @retval AVERROR_EOF       the decoder has been flushed, and no new packets can be\n                           sent to it (also returned if more than 1 flush\n                           packet is sent)\n @retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires flush\n @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar\n @retval \"another negative error code\" legitimate decoding errors"]
    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return decoded output data from a decoder or encoder (when the\n @ref AV_CODEC_FLAG_RECON_FRAME flag is used).\n\n @param avctx codec context\n @param frame This will be set to a reference-counted video or audio\n              frame (depending on the decoder type) allocated by the\n              codec. Note that the function will always call\n              av_frame_unref(frame) before doing anything else.\n\n @retval 0                success, a frame was returned\n @retval AVERROR(EAGAIN)  output is not available in this state - user must\n                          try to send new input\n @retval AVERROR_EOF      the codec has been fully flushed, and there will be\n                          no more output frames\n @retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the\n                          @ref AV_CODEC_FLAG_RECON_FRAME flag enabled\n @retval \"other negative error code\" legitimate decoding errors"]
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()\n to retrieve buffered output packets.\n\n @param avctx     codec context\n @param[in] frame AVFrame containing the raw audio or video frame to be encoded.\n                  Ownership of the frame remains with the caller, and the\n                  encoder will not write to the frame. The encoder may create\n                  a reference to the frame data (or copy it if the frame is\n                  not reference-counted).\n                  It can be NULL, in which case it is considered a flush\n                  packet.  This signals the end of the stream. If the encoder\n                  still has packets buffered, it will return them after this\n                  call. Once flushing mode has been entered, additional flush\n                  packets are ignored, and sending frames will return\n                  AVERROR_EOF.\n\n                  For audio:\n                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n                  can have any number of samples.\n                  If it is not set, frame->nb_samples must be equal to\n                  avctx->frame_size for all frames except the last.\n                  The final frame may be smaller than avctx->frame_size.\n @retval 0                 success\n @retval AVERROR(EAGAIN)   input is not accepted in the current state - user must\n                           read output with avcodec_receive_packet() (once all\n                           output is read, the packet should be resent, and the\n                           call will not fail with EAGAIN).\n @retval AVERROR_EOF       the encoder has been flushed, and no new frames can\n                           be sent to it\n @retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush\n @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar\n @retval \"another negative error code\" legitimate encoding errors"]
    pub fn avcodec_send_frame(
        avctx: *mut AVCodecContext,
        frame: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read encoded data from the encoder.\n\n @param avctx codec context\n @param avpkt This will be set to a reference-counted packet allocated by the\n              encoder. Note that the function will always call\n              av_packet_unref(avpkt) before doing anything else.\n @retval 0               success\n @retval AVERROR(EAGAIN) output is not available in the current state - user must\n                         try to send input\n @retval AVERROR_EOF     the encoder has been fully flushed, and there will be no\n                         more output packets\n @retval AVERROR(EINVAL) codec not opened, or it is a decoder\n @retval \"another negative error code\" legitimate encoding errors"]
    pub fn avcodec_receive_packet(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and return a AVHWFramesContext with values adequate for hardware\n decoding. This is meant to get called from the get_format callback, and is\n a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.\n This API is for decoding with certain hardware acceleration modes/APIs only.\n\n The returned AVHWFramesContext is not initialized. The caller must do this\n with av_hwframe_ctx_init().\n\n Calling this function is not a requirement, but makes it simpler to avoid\n codec or hardware API specific details when manually allocating frames.\n\n Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,\n which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes\n it unnecessary to call this function or having to care about\n AVHWFramesContext initialization at all.\n\n There are a number of requirements for calling this function:\n\n - It must be called from get_format with the same avctx parameter that was\n   passed to get_format. Calling it outside of get_format is not allowed, and\n   can trigger undefined behavior.\n - The function is not always supported (see description of return values).\n   Even if this function returns successfully, hwaccel initialization could\n   fail later. (The degree to which implementations check whether the stream\n   is actually supported varies. Some do this check only after the user's\n   get_format callback returns.)\n - The hw_pix_fmt must be one of the choices suggested by get_format. If the\n   user decides to use a AVHWFramesContext prepared with this API function,\n   the user must return the same hw_pix_fmt from get_format.\n - The device_ref passed to this function must support the given hw_pix_fmt.\n - After calling this API function, it is the user's responsibility to\n   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),\n   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done\n   before returning from get_format (this is implied by the normal\n   AVCodecContext.hw_frames_ctx API rules).\n - The AVHWFramesContext parameters may change every time time get_format is\n   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So\n   you are inherently required to go through this process again on every\n   get_format call.\n - It is perfectly possible to call this function without actually using\n   the resulting AVHWFramesContext. One use-case might be trying to reuse a\n   previously initialized AVHWFramesContext, and calling this API function\n   only to test whether the required frame parameters have changed.\n - Fields that use dynamically allocated values of any kind must not be set\n   by the user unless setting them is explicitly allowed by the documentation.\n   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,\n   the new free callback must call the potentially set previous free callback.\n   This API call may set any dynamically allocated fields, including the free\n   callback.\n\n The function will set at least the following fields on AVHWFramesContext\n (potentially more, depending on hwaccel API):\n\n - All fields set by av_hwframe_ctx_alloc().\n - Set the format field to hw_pix_fmt.\n - Set the sw_format field to the most suited and most versatile format. (An\n   implication is that this will prefer generic formats over opaque formats\n   with arbitrary restrictions, if possible.)\n - Set the width/height fields to the coded frame size, rounded up to the\n   API-specific minimum alignment.\n - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size\n   field to the number of maximum reference surfaces possible with the codec,\n   plus 1 surface for the user to work (meaning the user can safely reference\n   at most 1 decoded surface at a time), plus additional buffering introduced\n   by frame threading. If the hwaccel does not require pre-allocation, the\n   field is left to 0, and the decoder will allocate new surfaces on demand\n   during decoding.\n - Possibly AVHWFramesContext.hwctx fields, depending on the underlying\n   hardware API.\n\n Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but\n with basic frame parameters set.\n\n The function is stateless, and does not change the AVCodecContext or the\n device_ref AVHWDeviceContext.\n\n @param avctx The context which is currently calling get_format, and which\n              implicitly contains all state needed for filling the returned\n              AVHWFramesContext properly.\n @param device_ref A reference to the AVHWDeviceContext describing the device\n                   which will be used by the hardware decoder.\n @param hw_pix_fmt The hwaccel format you are going to return from get_format.\n @param out_frames_ref On success, set to a reference to an _uninitialized_\n                       AVHWFramesContext, created from the given device_ref.\n                       Fields will be set to values required for decoding.\n                       Not changed if an error is returned.\n @return zero on success, a negative value on error. The following error codes\n         have special semantics:\n      AVERROR(ENOENT): the decoder does not support this functionality. Setup\n                       is always manual, or it is a decoder which does not\n                       support setting AVCodecContext.hw_frames_ctx at all,\n                       or it is a software format.\n      AVERROR(EINVAL): it is known that hardware decoding is not supported for\n                       this configuration, or the device_ref is not supported\n                       for the hwaccel referenced by hw_pix_fmt."]
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< unknown"]
pub const AV_PICTURE_STRUCTURE_UNKNOWN: AVPictureStructure = 0;
#[doc = "< coded as top field"]
pub const AV_PICTURE_STRUCTURE_TOP_FIELD: AVPictureStructure = 1;
#[doc = "< coded as bottom field"]
pub const AV_PICTURE_STRUCTURE_BOTTOM_FIELD: AVPictureStructure = 2;
#[doc = "< coded as frame"]
pub const AV_PICTURE_STRUCTURE_FRAME: AVPictureStructure = 3;
#[doc = " @defgroup lavc_parsing Frame parsing\n @{"]
pub type AVPictureStructure = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParserContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub parser: *const AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: ::std::os::raw::c_int,
    #[doc = " This field is used for proper frame duration computation in lavf.\n It signals, how much longer the frame duration of the current frame\n is compared to normal frame duration.\n\n frame_duration = (1 + repeat_pict) * time_base\n\n It is used by codecs like H.264 to display telecined material."]
    pub repeat_pict: ::std::os::raw::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: ::std::os::raw::c_int,
    pub cur_frame_start_index: ::std::os::raw::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: ::std::os::raw::c_int,
    #[doc = "< byte offset from starting packet start"]
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    #[doc = " Set by parser to 1 for key frames and 0 for non-key frames.\n It is initialized to -1, so if the parser doesn't set this flag,\n old-style fallback using AV_PICTURE_TYPE_I picture type as key frames\n will be used."]
    pub key_frame: ::std::os::raw::c_int,
    #[doc = " Synchronization point for start of timestamp generation.\n\n Set to >0 for sync point, 0 for no sync point and <0 for undefined\n (default).\n\n For example, this corresponds to presence of H.264 buffering period\n SEI message."]
    pub dts_sync_point: ::std::os::raw::c_int,
    #[doc = " Offset of the current timestamp against last timestamp sync point in\n units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain a valid timestamp offset.\n\n Note that the timestamp of sync point has usually a nonzero\n dts_ref_dts_delta, which refers to the previous sync point. Offset of\n the next frame after timestamp sync point will be usually 1.\n\n For example, this corresponds to H.264 cpb_removal_delay."]
    pub dts_ref_dts_delta: ::std::os::raw::c_int,
    #[doc = " Presentation delay of current frame in units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain valid non-negative timestamp delta (presentation time of a frame\n must not lie in the past).\n\n This delay represents the difference between decoding and presentation\n time of the frame.\n\n For example, this corresponds to H.264 dpb_output_delay."]
    pub pts_dts_delta: ::std::os::raw::c_int,
    #[doc = " Position of the packet in file.\n\n Analogous to cur_frame_pts/dts"]
    pub cur_frame_pos: [i64; 4usize],
    #[doc = " Byte position of currently parsed frame in stream."]
    pub pos: i64,
    #[doc = " Previous frame byte position."]
    pub last_pos: i64,
    #[doc = " Duration of the current frame.\n For audio, this is in units of 1 / AVCodecContext.sample_rate.\n For all other types, this is in units of AVCodecContext.time_base."]
    pub duration: ::std::os::raw::c_int,
    pub field_order: AVFieldOrder,
    #[doc = " Indicate whether a picture is coded as a frame, top field or bottom field.\n\n For example, H.264 field_pic_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag\n equal to 1 and bottom_field_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_TOP_FIELD."]
    pub picture_structure: AVPictureStructure,
    #[doc = " Picture number incremented in presentation or output order.\n This field may be reinitialized at the first picture of a new sequence.\n\n For example, this corresponds to H.264 PicOrderCnt."]
    pub output_picture_number: ::std::os::raw::c_int,
    #[doc = " Dimensions of the decoded video intended for presentation."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Dimensions of the coded video."]
    pub coded_width: ::std::os::raw::c_int,
    pub coded_height: ::std::os::raw::c_int,
    #[doc = " The format of the coded data, corresponds to enum AVPixelFormat for video\n and for enum AVSampleFormat for audio.\n\n Note that a decoder can have considerable freedom in how exactly it\n decodes the data, so the format reported here might be different from the\n one returned by a decoder."]
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecParserContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecParserContext>(),
        336usize,
        concat!("Size of: ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_frame_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(next_frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pict_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat_pict) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_pts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_dts) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_timestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(fetch_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_start_index) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_start_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_offset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_pts) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_dts) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_end) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_frame) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts_sync_point) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_sync_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts_ref_dts_delta) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_ref_dts_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_dts_delta) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts_dts_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame_pos) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_pos) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_order) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_structure) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_picture_number) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(output_picture_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_width) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_height) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParser {
    pub codec_ids: [::std::os::raw::c_int; 7usize],
    pub priv_data_size: ::std::os::raw::c_int,
    pub parser_init: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecParserContext) -> ::std::os::raw::c_int,
    >,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    const UNINIT: ::std::mem::MaybeUninit<AVCodecParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCodecParser>(),
        64usize,
        concat!("Size of: ", stringify!(AVCodecParser))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParser>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_parse) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_parse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(split)
        )
    );
}
extern "C" {
    #[doc = " Iterate over all registered codec parsers.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec parser or NULL when the iteration is\n         finished"]
    pub fn av_parser_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_init(codec_id: ::std::os::raw::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Parse a packet.\n\n @param s             parser context.\n @param avctx         codec context.\n @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n @param buf           input buffer.\n @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\nsize is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\nTo signal EOF, this should be 0 (so that the last frame\ncan be output).\n @param pts           input presentation timestamp.\n @param dts           input decoding timestamp.\n @param pos           input byte position in stream.\n @return the number of bytes of the input bitstream used.\n\n Example:\n @code\n   while(in_len){\n       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n                                        in_data, in_len,\n                                        pts, dts, pos);\n       in_data += len;\n       in_len  -= len;\n\n       if(size)\n          decode_frame(data, size);\n   }\n @endcode"]
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    #[doc = " @addtogroup lavc_encoding\n @{"]
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: ::std::os::raw::c_int,
        sub: *const AVSubtitle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a value representing the fourCC code associated to the\n pixel format pix_fmt, or 0 if no associated fourCC code can be\n found."]
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Find the best pixel format to convert to given a certain source pixel\n format.  When converting from one pixel format to another, information loss\n may occur.  For example, when converting from RGB24 to GRAY, the color\n information will be lost. Similarly, other losses occur when converting from\n some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n the given pixel formats should be used to suffer the least amount of loss.\n The pixel formats from which it chooses one, are determined by the\n pix_fmt_list parameter.\n\n\n @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n @return The best pixel format to convert to or -1 if none was found."]
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " @}"]
    pub fn avcodec_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        enc: *mut AVCodecContext,
        encode: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill AVFrame audio data and linesize pointers.\n\n The buffer buf must be a preallocated buffer with a size big enough\n to contain the specified samples amount. The filled AVFrame data\n pointers will point to this buffer.\n\n AVFrame extended_data channel pointers are allocated if necessary for\n planar audio.\n\n @param frame       the AVFrame\n                    frame->nb_samples must be set prior to calling the\n                    function. This function fills in frame->data,\n                    frame->extended_data, frame->linesize[0].\n @param nb_channels channel count\n @param sample_fmt  sample format\n @param buf         buffer to use for frame data\n @param buf_size    size of buffer\n @param align       plane size sample alignment (0 = default)\n @return            >=0 on success, negative error code on failure\n @todo return the size in bytes required to store the samples in\n case of success, at the next libavutil bump"]
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the internal codec state / flush internal buffers. Should be called\n e.g. when seeking or when switching to a different stream.\n\n @note for decoders, this function just releases any references the decoder\n might keep internally, but the caller's references remain valid.\n\n @note for encoders, this function will only do something if the encoder\n declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder\n will drain any remaining packets, and can then be re-used for a different\n stream (as opposed to sending a null frame which will leave the encoder\n in a permanent EOF state after draining). This can be desirable if the\n cost of tearing down and replacing the encoder instance is high."]
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    #[doc = " Return audio frame duration.\n\n @param avctx        codec context\n @param frame_bytes  size of the frame, or 0 if unknown\n @return             frame duration, in samples, if known. 0 if not able to\n                     determine."]
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same behaviour av_fast_malloc but the buffer has additional\n AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n\n In addition the whole buffer will initially and after resizes\n be 0-initialized so that no uninitialized data will ever appear."]
    pub fn av_fast_padded_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Same behaviour av_fast_padded_malloc except that buffer will always\n be 0-initialized after call."]
    pub fn av_fast_padded_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " @return a positive value if s is open (i.e. avcodec_open2() was called on it\n with no corresponding avcodec_close()), 0 otherwise."]
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
pub const AV_OPT_TYPE_FLAGS: AVOptionType = 0;
pub const AV_OPT_TYPE_INT: AVOptionType = 1;
pub const AV_OPT_TYPE_INT64: AVOptionType = 2;
pub const AV_OPT_TYPE_DOUBLE: AVOptionType = 3;
pub const AV_OPT_TYPE_FLOAT: AVOptionType = 4;
pub const AV_OPT_TYPE_STRING: AVOptionType = 5;
pub const AV_OPT_TYPE_RATIONAL: AVOptionType = 6;
pub const AV_OPT_TYPE_BINARY: AVOptionType = 7;
pub const AV_OPT_TYPE_DICT: AVOptionType = 8;
pub const AV_OPT_TYPE_UINT64: AVOptionType = 9;
pub const AV_OPT_TYPE_CONST: AVOptionType = 10;
pub const AV_OPT_TYPE_IMAGE_SIZE: AVOptionType = 11;
pub const AV_OPT_TYPE_PIXEL_FMT: AVOptionType = 12;
pub const AV_OPT_TYPE_SAMPLE_FMT: AVOptionType = 13;
pub const AV_OPT_TYPE_VIDEO_RATE: AVOptionType = 14;
pub const AV_OPT_TYPE_DURATION: AVOptionType = 15;
pub const AV_OPT_TYPE_COLOR: AVOptionType = 16;
pub const AV_OPT_TYPE_CHANNEL_LAYOUT: AVOptionType = 17;
pub const AV_OPT_TYPE_BOOL: AVOptionType = 18;
pub const AV_OPT_TYPE_CHLAYOUT: AVOptionType = 19;
pub type AVOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
    pub offset: ::std::os::raw::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    pub min: f64,
    pub max: f64,
    pub flags: ::std::os::raw::c_int,
    pub unit: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64_: i64,
    pub dbl: f64,
    pub str_: *const ::std::os::raw::c_char,
    pub q: AVRational,
}
#[test]
fn bindgen_test_layout_AVOption__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AVOption__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(dbl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
impl ::std::fmt::Debug for AVOption__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "AVOption__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_AVOption() {
    const UNINIT: ::std::mem::MaybeUninit<AVOption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVOption>(),
        64usize,
        concat!("Size of: ", stringify!(AVOption))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).help) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(default_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(unit)
        )
    );
}
impl ::std::fmt::Debug for AVOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVOption {{ name: {:?}, help: {:?}, offset: {:?}, type: {:?}, default_val: {:?}, min: {:?}, max: {:?}, flags: {:?}, unit: {:?} }}" , self . name , self . help , self . offset , self . type_ , self . default_val , self . min , self . max , self . flags , self . unit)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRange {
    pub str_: *const ::std::os::raw::c_char,
    pub value_min: f64,
    pub value_max: f64,
    pub component_min: f64,
    pub component_max: f64,
    pub is_range: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRange() {
    const UNINIT: ::std::mem::MaybeUninit<AVOptionRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVOptionRange>(),
        48usize,
        concat!("Size of: ", stringify!(AVOptionRange))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRange>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_min) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_max) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_range) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(is_range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    pub range: *mut *mut AVOptionRange,
    pub nb_ranges: ::std::os::raw::c_int,
    pub nb_components: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRanges() {
    const UNINIT: ::std::mem::MaybeUninit<AVOptionRanges> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVOptionRanges>(),
        16usize,
        concat!("Size of: ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRanges>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_ranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_components) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_components)
        )
    );
}
extern "C" {
    pub fn av_opt_show2(
        obj: *mut ::std::os::raw::c_void,
        av_log_obj: *mut ::std::os::raw::c_void,
        req_flags: ::std::os::raw::c_int,
        rej_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_defaults(s: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_opt_set_defaults2(
        s: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_set_options_string(
        ctx: *mut ::std::os::raw::c_void,
        opts: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_from_string(
        ctx: *mut ::std::os::raw::c_void,
        opts: *const ::std::os::raw::c_char,
        shorthand: *const *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_free(obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_opt_flag_is_set(
        obj: *mut ::std::os::raw::c_void,
        field_name: *const ::std::os::raw::c_char,
        flag_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_dict(
        obj: *mut ::std::os::raw::c_void,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_dict2(
        obj: *mut ::std::os::raw::c_void,
        options: *mut *mut AVDictionary,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_key_value(
        ropts: *mut *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        rkey: *mut *mut ::std::os::raw::c_char,
        rval: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
extern "C" {
    pub fn av_opt_eval_flags(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        flags_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        int_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        int64_out: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        float_out: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        double_out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        q_out: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_find(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        opt_flags: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_find2(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        opt_flags: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
        target_obj: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_next(
        obj: *const ::std::os::raw::c_void,
        prev: *const AVOption,
    ) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_child_next(
        obj: *mut ::std::os::raw::c_void,
        prev: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_opt_child_class_iterate(
        parent: *const AVClass,
        iter: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVClass;
}
extern "C" {
    pub fn av_opt_set(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: i64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: f64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: AVRational,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const u8,
        size: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        fmt: AVPixelFormat,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        fmt: AVSampleFormat,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: AVRational,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        ch_layout: i64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_chlayout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        layout: *const AVChannelLayout,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_dict_val(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const AVDictionary,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        w_out: *mut ::std::os::raw::c_int,
        h_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        ch_layout: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_chlayout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        layout: *mut AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_dict_val(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_copy(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_serialize(
        obj: *mut ::std::os::raw::c_void,
        opt_flags: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " AVDCT context.\n @note function pointers can be NULL if the specific features have been\n       disabled at build time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDCT {
    pub av_class: *const AVClass,
    pub idct: ::std::option::Option<unsafe extern "C" fn(block: *mut i16)>,
    #[doc = " IDCT input permutation.\n Several optimized IDCTs need a permutated input (relative to the\n normal order of the reference IDCT).\n This permutation must be performed before the idct_put/add.\n Note, normally this can be merged with the zigzag/alternate scan<br>\n An example to avoid confusion:\n - (->decode coeffs -> zigzag reorder -> dequant -> reference IDCT -> ...)\n - (x -> reference DCT -> reference IDCT -> x)\n - (x -> reference DCT -> simple_mmx_perm = idct_permutation\n    -> simple_idct_mmx -> x)\n - (-> decode coeffs -> zigzag reorder -> simple_mmx_perm -> dequant\n    -> simple_idct_mmx -> ...)"]
    pub idct_permutation: [u8; 64usize],
    pub fdct: ::std::option::Option<unsafe extern "C" fn(block: *mut i16)>,
    #[doc = " DCT algorithm.\n must use AVOptions to set this field."]
    pub dct_algo: ::std::os::raw::c_int,
    #[doc = " IDCT algorithm.\n must use AVOptions to set this field."]
    pub idct_algo: ::std::os::raw::c_int,
    pub get_pixels: ::std::option::Option<
        unsafe extern "C" fn(block: *mut i16, pixels: *const u8, line_size: isize),
    >,
    pub bits_per_sample: ::std::os::raw::c_int,
    pub get_pixels_unaligned: ::std::option::Option<
        unsafe extern "C" fn(block: *mut i16, pixels: *const u8, line_size: isize),
    >,
}
#[test]
fn bindgen_test_layout_AVDCT() {
    const UNINIT: ::std::mem::MaybeUninit<AVDCT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDCT>(),
        120usize,
        concat!("Size of: ", stringify!(AVDCT))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDCT>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDCT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idct) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(idct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idct_permutation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(idct_permutation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdct) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(fdct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dct_algo) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idct_algo) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pixels) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(get_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_pixels_unaligned) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDCT),
            "::",
            stringify!(get_pixels_unaligned)
        )
    );
}
extern "C" {
    #[doc = " Allocates a AVDCT context.\n This needs to be initialized with avcodec_dct_init() after optionally\n configuring it with AVOptions.\n\n To free it use av_free()"]
    pub fn avcodec_dct_alloc() -> *mut AVDCT;
}
extern "C" {
    pub fn avcodec_dct_init(arg1: *mut AVDCT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_dct_get_class() -> *const AVClass;
}
#[doc = " @defgroup lavc_fft FFT functions\n @ingroup lavc_misc\n\n @{"]
pub type FFTSample = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTComplex {
    pub re: FFTSample,
    pub im: FFTSample,
}
#[test]
fn bindgen_test_layout_FFTComplex() {
    const UNINIT: ::std::mem::MaybeUninit<FFTComplex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FFTComplex>(),
        8usize,
        concat!("Size of: ", stringify!(FFTComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<FFTComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(FFTComplex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a complex FFT.\n @param nbits           log2 of the length of the input array\n @param inverse         if 0 perform the forward transform, if 1 perform the inverse\n @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_FFT"]
    pub fn av_fft_init(
        nbits: ::std::os::raw::c_int,
        inverse: ::std::os::raw::c_int,
    ) -> *mut FFTContext;
}
extern "C" {
    #[doc = " Do the permutation needed BEFORE calling ff_fft_calc().\n @deprecated without replacement"]
    pub fn av_fft_permute(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    #[doc = " Do a complex FFT with the parameters defined in av_fft_init(). The\n input data must be permuted before. No 1.0/sqrt(n) normalization is done.\n @deprecated use the av_tx_fn value returned by av_tx_init, which also does permutation"]
    pub fn av_fft_calc(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    pub fn av_fft_end(s: *mut FFTContext);
}
extern "C" {
    #[doc = " @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc."]
    pub fn av_mdct_init(
        nbits: ::std::os::raw::c_int,
        inverse: ::std::os::raw::c_int,
        scale: f64,
    ) -> *mut FFTContext;
}
extern "C" {
    pub fn av_imdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_imdct_half(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_end(s: *mut FFTContext);
}
pub const DFT_R2C: RDFTransformType = 0;
pub const IDFT_C2R: RDFTransformType = 1;
pub const IDFT_R2C: RDFTransformType = 2;
pub const DFT_C2R: RDFTransformType = 3;
pub type RDFTransformType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RDFTContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set up a real FFT.\n @param nbits           log2 of the length of the input array\n @param trans           the type of transform\n\n @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT"]
    pub fn av_rdft_init(nbits: ::std::os::raw::c_int, trans: RDFTransformType) -> *mut RDFTContext;
}
extern "C" {
    pub fn av_rdft_calc(s: *mut RDFTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_rdft_end(s: *mut RDFTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTContext {
    _unused: [u8; 0],
}
pub const DCT_II: DCTTransformType = 0;
pub const DCT_III: DCTTransformType = 1;
pub const DCT_I: DCTTransformType = 2;
pub const DST_I: DCTTransformType = 3;
pub type DCTTransformType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Set up DCT.\n\n @param nbits           size of the input array:\n                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n                        (1 << nbits) + 1 for DCT-I\n @param type            the type of transform\n\n @note the first element of the input of DST-I is ignored\n\n @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT"]
    pub fn av_dct_init(nbits: ::std::os::raw::c_int, type_: DCTTransformType) -> *mut DCTContext;
}
extern "C" {
    pub fn av_dct_calc(s: *mut DCTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_dct_end(s: *mut DCTContext);
}
#[doc = " The bitstream filter state.\n\n This struct must be allocated with av_bsf_alloc() and freed with\n av_bsf_free().\n\n The fields in the struct will only be changed (by the caller or by the\n filter) as described in their documentation, and are to be considered\n immutable otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFContext {
    #[doc = " A class for logging and AVOptions"]
    pub av_class: *const AVClass,
    #[doc = " The bitstream filter this context is an instance of."]
    pub filter: *const AVBitStreamFilter,
    #[doc = " Opaque filter-specific private data. If filter->priv_class is non-NULL,\n this is an AVOptions-enabled struct."]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Parameters of the input stream. This field is allocated in\n av_bsf_alloc(), it needs to be filled by the caller before\n av_bsf_init()."]
    pub par_in: *mut AVCodecParameters,
    #[doc = " Parameters of the output stream. This field is allocated in\n av_bsf_alloc(), it is set by the filter in av_bsf_init()."]
    pub par_out: *mut AVCodecParameters,
    #[doc = " The timebase used for the timestamps of the input packets. Set by the\n caller before av_bsf_init()."]
    pub time_base_in: AVRational,
    #[doc = " The timebase used for the timestamps of the output packets. Set by the\n filter in av_bsf_init()."]
    pub time_base_out: AVRational,
}
#[test]
fn bindgen_test_layout_AVBSFContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVBSFContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBSFContext>(),
        56usize,
        concat!("Size of: ", stringify!(AVBSFContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBSFContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBSFContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).par_in) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).par_out) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base_in) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base_out) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_out)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilter {
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A list of codec ids supported by the filter, terminated by\n AV_CODEC_ID_NONE.\n May be NULL, in that case the bitstream filter works with any codec id."]
    pub codec_ids: *const AVCodecID,
    #[doc = " A class for the private data, used to declare bitstream filter private\n AVOptions. This field is NULL for bitstream filters that do not declare\n any options.\n\n If this field is non-NULL, the first member of the filter private data\n must be a pointer to AVClass, which will be set by libavcodec generic\n code to this class."]
    pub priv_class: *const AVClass,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilter() {
    const UNINIT: ::std::mem::MaybeUninit<AVBitStreamFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBitStreamFilter>(),
        24usize,
        concat!("Size of: ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBitStreamFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_ids) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_class) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_class)
        )
    );
}
extern "C" {
    #[doc = " @return a bitstream filter with the specified name or NULL if no such\n         bitstream filter exists."]
    pub fn av_bsf_get_by_name(name: *const ::std::os::raw::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    #[doc = " Iterate over all registered bitstream filters.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered bitstream filter or NULL when the iteration is\n         finished"]
    pub fn av_bsf_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    #[doc = " Allocate a context for a given bitstream filter. The caller must fill in the\n context parameters as described in the documentation and then call\n av_bsf_init() before sending any data to the filter.\n\n @param filter the filter for which to allocate an instance.\n @param[out] ctx a pointer into which the pointer to the newly-allocated context\n                 will be written. It must be freed with av_bsf_free() after the\n                 filtering is done.\n\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepare the filter for use, after all the parameters and options have been\n set.\n\n @param ctx a AVBSFContext previously allocated with av_bsf_alloc()"]
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Submit a packet for filtering.\n\n After sending each packet, the filter must be completely drained by calling\n av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or\n AVERROR_EOF.\n\n @param ctx an initialized AVBSFContext\n @param pkt the packet to filter. The bitstream filter will take ownership of\n the packet and reset the contents of pkt. pkt is not touched if an error occurs.\n If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),\n it signals the end of the stream (i.e. no more non-empty packets will be sent;\n sending more empty packets does nothing) and will cause the filter to output\n any packets it may have buffered internally.\n\n @return\n  - 0 on success.\n  - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using\n    av_bsf_receive_packet()) before new input can be consumed.\n  - Another negative AVERROR value if an error occurs."]
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a filtered packet.\n\n @param ctx an initialized AVBSFContext\n @param[out] pkt this struct will be filled with the contents of the filtered\n                 packet. It is owned by the caller and must be freed using\n                 av_packet_unref() when it is no longer needed.\n                 This parameter should be \"clean\" (i.e. freshly allocated\n                 with av_packet_alloc() or unreffed with av_packet_unref())\n                 when this function is called. If this function returns\n                 successfully, the contents of pkt will be completely\n                 overwritten by the returned data. On failure, pkt is not\n                 touched.\n\n @return\n  - 0 on success.\n  - AVERROR(EAGAIN) if more packets need to be sent to the filter (using\n    av_bsf_send_packet()) to get more output.\n  - AVERROR_EOF if there will be no further output from the filter.\n  - Another negative AVERROR value if an error occurs.\n\n @note one input packet may result in several output packets, so after sending\n a packet with av_bsf_send_packet(), this function needs to be called\n repeatedly until it stops returning 0. It is also possible for a filter to\n output fewer packets than were sent to it, so this function may return\n AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call."]
    pub fn av_bsf_receive_packet(
        ctx: *mut AVBSFContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the internal bitstream filter state. Should be called e.g. when seeking."]
    pub fn av_bsf_flush(ctx: *mut AVBSFContext);
}
extern "C" {
    #[doc = " Free a bitstream filter context and everything associated with it; write NULL\n into the supplied pointer."]
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVBSFContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate empty list of bitstream filters.\n The list must be later freed by av_bsf_list_free()\n or finalized by av_bsf_list_finalize().\n\n @return Pointer to @ref AVBSFList on success, NULL in case of failure"]
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    #[doc = " Free list of bitstream filters.\n\n @param lst Pointer to pointer returned by av_bsf_list_alloc()"]
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    #[doc = " Append bitstream filter to the list of bitstream filters.\n\n @param lst List to append to\n @param bsf Filter context to be appended\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct new bitstream filter context given it's name and options\n and append it to the list of bitstream filters.\n\n @param lst      List to append to\n @param bsf_name Name of the bitstream filter\n @param options  Options for the bitstream filter, can be set to NULL\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finalize list of bitstream filters.\n\n This function will transform @ref AVBSFList to single @ref AVBSFContext,\n so the whole chain of bitstream filters can be treated as single filter\n freshly allocated by av_bsf_alloc().\n If the call is successful, @ref AVBSFList structure is freed and lst\n will be set to NULL. In case of failure, caller is responsible for\n freeing the structure by av_bsf_list_free()\n\n @param      lst Filter list structure to be transformed\n @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n                 representing the chain of bitstream filters\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse string describing list of bitstream filters and create single\n @ref AVBSFContext describing the whole chain of bitstream filters.\n Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly\n allocated by av_bsf_alloc().\n\n @param      str String describing chain of bitstream filters in format\n                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`\n @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n                 representing the chain of bitstream filters\n\n @return >=0 on success, negative AVERROR in case of failure"]
    pub fn av_bsf_list_parse_str(
        str_: *const ::std::os::raw::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get null/pass-through bitstream filter.\n\n @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter\n\n @return"]
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> ::std::os::raw::c_int;
}
pub const DIRAC_PCODE_SEQ_HEADER: DiracParseCodes = 0;
pub const DIRAC_PCODE_END_SEQ: DiracParseCodes = 16;
pub const DIRAC_PCODE_AUX: DiracParseCodes = 32;
pub const DIRAC_PCODE_PAD: DiracParseCodes = 48;
pub const DIRAC_PCODE_PICTURE_CODED: DiracParseCodes = 8;
pub const DIRAC_PCODE_PICTURE_RAW: DiracParseCodes = 72;
pub const DIRAC_PCODE_PICTURE_LOW_DEL: DiracParseCodes = 200;
pub const DIRAC_PCODE_PICTURE_HQ: DiracParseCodes = 232;
pub const DIRAC_PCODE_INTER_NOREF_CO1: DiracParseCodes = 10;
pub const DIRAC_PCODE_INTER_NOREF_CO2: DiracParseCodes = 9;
pub const DIRAC_PCODE_INTER_REF_CO1: DiracParseCodes = 13;
pub const DIRAC_PCODE_INTER_REF_CO2: DiracParseCodes = 14;
pub const DIRAC_PCODE_INTRA_REF_CO: DiracParseCodes = 12;
pub const DIRAC_PCODE_INTRA_REF_RAW: DiracParseCodes = 76;
pub const DIRAC_PCODE_INTRA_REF_PICT: DiracParseCodes = 204;
pub const DIRAC_PCODE_MAGIC: DiracParseCodes = 1111638852;
#[doc = " Parse code values:\n\n Dirac Specification ->\n 9.6.1  Table 9.1\n\n VC-2 Specification  ->\n 10.4.1 Table 10.1"]
pub type DiracParseCodes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiracVersionInfo {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DiracVersionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DiracVersionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DiracVersionInfo>(),
        8usize,
        concat!("Size of: ", stringify!(DiracVersionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DiracVersionInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(DiracVersionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DiracVersionInfo),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DiracVersionInfo),
            "::",
            stringify!(minor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDiracSeqHeader {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    #[doc = "< 0: 444  1: 422  2: 420"]
    pub chroma_format: u8,
    pub interlaced: u8,
    pub top_field_first: u8,
    #[doc = "< index into dirac_frame_rate[]"]
    pub frame_rate_index: u8,
    #[doc = "< index into dirac_aspect_ratio[]"]
    pub aspect_ratio_index: u8,
    pub clean_width: u16,
    pub clean_height: u16,
    pub clean_left_offset: u16,
    pub clean_right_offset: u16,
    #[doc = "< index into dirac_pixel_range_presets[]"]
    pub pixel_range_index: u8,
    #[doc = "< index into dirac_color_spec_presets[]"]
    pub color_spec_index: u8,
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub framerate: AVRational,
    pub sample_aspect_ratio: AVRational,
    pub pix_fmt: AVPixelFormat,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub version: DiracVersionInfo,
    pub bit_depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVDiracSeqHeader() {
    const UNINIT: ::std::mem::MaybeUninit<AVDiracSeqHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDiracSeqHeader>(),
        80usize,
        concat!("Size of: ", stringify!(AVDiracSeqHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDiracSeqHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDiracSeqHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(chroma_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate_index) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(frame_rate_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_ratio_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(aspect_ratio_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_width) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(clean_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(clean_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_left_offset) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(clean_left_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_right_offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(clean_right_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_range_index) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(pixel_range_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_spec_index) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(color_spec_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_trc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDiracSeqHeader),
            "::",
            stringify!(bit_depth)
        )
    );
}
extern "C" {
    #[doc = " Parse a Dirac sequence header.\n\n @param dsh this function will allocate and fill an AVDiracSeqHeader struct\n            and write it into this pointer. The caller must free it with\n            av_free().\n @param buf the data buffer\n @param buf_size the size of the data buffer in bytes\n @param log_ctx if non-NULL, this function will log errors here\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_dirac_parse_sequence_header(
        dsh: *mut *mut AVDiracSeqHeader,
        buf: *const u8,
        buf_size: usize,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDVProfile {
    pub dsf: ::std::os::raw::c_int,
    pub video_stype: ::std::os::raw::c_int,
    pub frame_size: ::std::os::raw::c_int,
    pub difseg_size: ::std::os::raw::c_int,
    pub n_difchan: ::std::os::raw::c_int,
    pub time_base: AVRational,
    pub ltc_divisor: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub sar: [AVRational; 2usize],
    pub pix_fmt: AVPixelFormat,
    pub bpm: ::std::os::raw::c_int,
    pub block_sizes: *const u8,
    pub audio_stride: ::std::os::raw::c_int,
    pub audio_min_samples: [::std::os::raw::c_int; 3usize],
    pub audio_samples_dist: [::std::os::raw::c_int; 5usize],
    pub audio_shuffle: *const [::std::os::raw::c_uchar; 9usize],
}
#[test]
fn bindgen_test_layout_AVDVProfile() {
    const UNINIT: ::std::mem::MaybeUninit<AVDVProfile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDVProfile>(),
        120usize,
        concat!("Size of: ", stringify!(AVDVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDVProfile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(dsf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_stype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(video_stype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).difseg_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(difseg_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_difchan) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(n_difchan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltc_divisor) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(ltc_divisor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sar) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(sar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpm) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(bpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_sizes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(block_sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_stride) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_min_samples) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_min_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_samples_dist) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_samples_dist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_shuffle) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_shuffle)
        )
    );
}
extern "C" {
    #[doc = " Get a DV profile for the provided compressed frame.\n\n @param sys the profile used for the previous frame, may be NULL\n @param frame the compressed data buffer\n @param buf_size size of the buffer in bytes\n @return the DV profile for the supplied data or NULL on failure"]
    pub fn av_dv_frame_profile(
        sys: *const AVDVProfile,
        frame: *const u8,
        buf_size: ::std::os::raw::c_uint,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters."]
    pub fn av_dv_codec_profile(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *const AVDVProfile;
}
extern "C" {
    #[doc = " Get a DV profile for the provided stream parameters.\n The frame rate is used as a best-effort parameter."]
    pub fn av_dv_codec_profile2(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        frame_rate: AVRational,
    ) -> *const AVDVProfile;
}
extern "C" {
    pub fn av_jni_set_java_vm(
        vm: *mut ::std::os::raw::c_void,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_jni_get_java_vm(log_ctx: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
#[doc = " This structure holds a reference to a android/view/Surface object that will\n be used as output by the decoder.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMediaCodecContext {
    #[doc = " android/view/Surface object reference."]
    pub surface: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AVMediaCodecContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVMediaCodecContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVMediaCodecContext>(),
        8usize,
        concat!("Size of: ", stringify!(AVMediaCodecContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVMediaCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVMediaCodecContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMediaCodecContext),
            "::",
            stringify!(surface)
        )
    );
}
extern "C" {
    #[doc = " Allocate and initialize a MediaCodec context.\n\n When decoding with MediaCodec is finished, the caller must free the\n MediaCodec context with av_mediacodec_default_free.\n\n @return a pointer to a newly allocated AVMediaCodecContext on success, NULL otherwise"]
    pub fn av_mediacodec_alloc_context() -> *mut AVMediaCodecContext;
}
extern "C" {
    #[doc = " Convenience function that sets up the MediaCodec context.\n\n @param avctx codec context\n @param ctx MediaCodec context to initialize\n @param surface reference to an android/view/Surface\n @return 0 on success, < 0 otherwise"]
    pub fn av_mediacodec_default_init(
        avctx: *mut AVCodecContext,
        ctx: *mut AVMediaCodecContext,
        surface: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function must be called to free the MediaCodec context initialized with\n av_mediacodec_default_init().\n\n @param avctx codec context"]
    pub fn av_mediacodec_default_free(avctx: *mut AVCodecContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MediaCodecBuffer {
    _unused: [u8; 0],
}
#[doc = " Opaque structure representing a MediaCodec buffer to render."]
pub type AVMediaCodecBuffer = MediaCodecBuffer;
extern "C" {
    #[doc = " Release a MediaCodec buffer and render it to the surface that is associated\n with the decoder. This function should only be called once on a given\n buffer, once released the underlying buffer returns to the codec, thus\n subsequent calls to this function will have no effect.\n\n @param buffer the buffer to render\n @param render 1 to release and render the buffer to the surface or 0 to\n discard the buffer\n @return 0 on success, < 0 otherwise"]
    pub fn av_mediacodec_release_buffer(
        buffer: *mut AVMediaCodecBuffer,
        render: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release a MediaCodec buffer and render it at the given time to the surface\n that is associated with the decoder. The timestamp must be within one second\n of the current `java/lang/System#nanoTime()` (which is implemented using\n `CLOCK_MONOTONIC` on Android). See the Android MediaCodec documentation\n of [`android/media/MediaCodec#releaseOutputBuffer(int,long)`][0] for more details.\n\n @param buffer the buffer to render\n @param time timestamp in nanoseconds of when to render the buffer\n @return 0 on success, < 0 otherwise\n\n [0]: https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,%20long)"]
    pub fn av_mediacodec_render_buffer_at_time(
        buffer: *mut AVMediaCodecBuffer,
        time: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVorbisParseContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize the Vorbis parser using headers in the extradata."]
    pub fn av_vorbis_parse_init(
        extradata: *const u8,
        extradata_size: ::std::os::raw::c_int,
    ) -> *mut AVVorbisParseContext;
}
extern "C" {
    #[doc = " Free the parser and everything associated with it."]
    pub fn av_vorbis_parse_free(s: *mut *mut AVVorbisParseContext);
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet.\n\n If @p flags is @c NULL,\n special frames are considered invalid.\n\n @param s        Vorbis parser context\n @param buf      buffer containing a Vorbis frame\n @param buf_size size of the buffer\n @param flags    flags for special frames"]
    pub fn av_vorbis_parse_frame_flags(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the duration for a Vorbis packet.\n\n @param s        Vorbis parser context\n @param buf      buffer containing a Vorbis frame\n @param buf_size size of the buffer"]
    pub fn av_vorbis_parse_frame(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_vorbis_parse_reset(s: *mut AVVorbisParseContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOInterruptCB {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AVIOInterruptCB() {
    const UNINIT: ::std::mem::MaybeUninit<AVIOInterruptCB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVIOInterruptCB>(),
        16usize,
        concat!("Size of: ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOInterruptCB>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(opaque)
        )
    );
}
pub const AVIO_ENTRY_UNKNOWN: AVIODirEntryType = 0;
pub const AVIO_ENTRY_BLOCK_DEVICE: AVIODirEntryType = 1;
pub const AVIO_ENTRY_CHARACTER_DEVICE: AVIODirEntryType = 2;
pub const AVIO_ENTRY_DIRECTORY: AVIODirEntryType = 3;
pub const AVIO_ENTRY_NAMED_PIPE: AVIODirEntryType = 4;
pub const AVIO_ENTRY_SYMBOLIC_LINK: AVIODirEntryType = 5;
pub const AVIO_ENTRY_SOCKET: AVIODirEntryType = 6;
pub const AVIO_ENTRY_FILE: AVIODirEntryType = 7;
pub const AVIO_ENTRY_SERVER: AVIODirEntryType = 8;
pub const AVIO_ENTRY_SHARE: AVIODirEntryType = 9;
pub const AVIO_ENTRY_WORKGROUP: AVIODirEntryType = 10;
pub type AVIODirEntryType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirEntry {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_int,
    pub utf8: ::std::os::raw::c_int,
    pub size: i64,
    pub modification_timestamp: i64,
    pub access_timestamp: i64,
    pub status_change_timestamp: i64,
    pub user_id: i64,
    pub group_id: i64,
    pub filemode: i64,
}
#[test]
fn bindgen_test_layout_AVIODirEntry() {
    const UNINIT: ::std::mem::MaybeUninit<AVIODirEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVIODirEntry>(),
        72usize,
        concat!("Size of: ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modification_timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(modification_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(access_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_change_timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(status_change_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(user_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filemode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(filemode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[test]
fn bindgen_test_layout_AVIODirContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVIODirContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVIODirContext>(),
        8usize,
        concat!("Size of: ", stringify!(AVIODirContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).url_context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirContext),
            "::",
            stringify!(url_context)
        )
    );
}
pub const AVIO_DATA_MARKER_HEADER: AVIODataMarkerType = 0;
pub const AVIO_DATA_MARKER_SYNC_POINT: AVIODataMarkerType = 1;
pub const AVIO_DATA_MARKER_BOUNDARY_POINT: AVIODataMarkerType = 2;
pub const AVIO_DATA_MARKER_UNKNOWN: AVIODataMarkerType = 3;
pub const AVIO_DATA_MARKER_TRAILER: AVIODataMarkerType = 4;
pub const AVIO_DATA_MARKER_FLUSH_POINT: AVIODataMarkerType = 5;
pub type AVIODataMarkerType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOContext {
    pub av_class: *const AVClass,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub buffer_size: ::std::os::raw::c_int,
    pub buf_ptr: *mut ::std::os::raw::c_uchar,
    pub buf_end: *mut ::std::os::raw::c_uchar,
    pub opaque: *mut ::std::os::raw::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            offset: i64,
            whence: ::std::os::raw::c_int,
        ) -> i64,
    >,
    pub pos: i64,
    pub eof_reached: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub write_flag: ::std::os::raw::c_int,
    pub max_packet_size: ::std::os::raw::c_int,
    pub min_packet_size: ::std::os::raw::c_int,
    pub checksum: ::std::os::raw::c_ulong,
    pub checksum_ptr: *mut ::std::os::raw::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(
            checksum: ::std::os::raw::c_ulong,
            buf: *const u8,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            pause: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> i64,
    >,
    pub seekable: ::std::os::raw::c_int,
    pub direct: ::std::os::raw::c_int,
    pub protocol_whitelist: *const ::std::os::raw::c_char,
    pub protocol_blacklist: *const ::std::os::raw::c_char,
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> ::std::os::raw::c_int,
    >,
    pub ignore_boundary_point: ::std::os::raw::c_int,
    pub buf_ptr_max: *mut ::std::os::raw::c_uchar,
    pub bytes_read: i64,
    pub bytes_written: i64,
}
#[test]
fn bindgen_test_layout_AVIOContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVIOContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVIOContext>(),
        208usize,
        concat!("Size of: ", stringify!(AVIOContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_packet) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_packet) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eof_reached) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(eof_reached)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_flag) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(max_packet_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_packet_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(min_packet_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checksum_ptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_checksum) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_pause) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_seek) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seekable) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direct) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(direct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_whitelist) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_blacklist) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_data_type) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_data_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignore_boundary_point) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(ignore_boundary_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_ptr_max) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_read) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_written) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_written)
        )
    );
}
extern "C" {
    pub fn avio_find_protocol_name(
        url: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avio_check(
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_read_dir(
        s: *mut AVIODirContext,
        next: *mut *mut AVIODirEntry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    pub fn avio_alloc_context(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: ::std::os::raw::c_int,
        write_flag: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                offset: i64,
                whence: ::std::os::raw::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: ::std::os::raw::c_int);
}
extern "C" {
    pub fn avio_write(
        s: *mut AVIOContext,
        buf: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_put_str(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_put_str16le(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_put_str16be(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    pub fn avio_feof(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_vprintf(
        s: *mut AVIOContext,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_printf(
        s: *mut AVIOContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_print_string_array(
        s: *mut AVIOContext,
        strings: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_r8(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_close(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_closep(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_enum_protocols(
        opaque: *mut *mut ::std::os::raw::c_void,
        output: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avio_protocol_get_class(name: *const ::std::os::raw::c_char) -> *const AVClass;
}
extern "C" {
    pub fn avio_pause(h: *mut AVIOContext, pause: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> i64;
}
extern "C" {
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_handshake(c: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProbeData {
    pub filename: *const ::std::os::raw::c_char,
    pub buf: *mut ::std::os::raw::c_uchar,
    pub buf_size: ::std::os::raw::c_int,
    pub mime_type: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVProbeData() {
    const UNINIT: ::std::mem::MaybeUninit<AVProbeData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVProbeData>(),
        32usize,
        concat!("Size of: ", stringify!(AVProbeData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProbeData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProbeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mime_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(mime_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOutputFormat {
    pub name: *const ::std::os::raw::c_char,
    pub long_name: *const ::std::os::raw::c_char,
    pub mime_type: *const ::std::os::raw::c_char,
    pub extensions: *const ::std::os::raw::c_char,
    pub audio_codec: AVCodecID,
    pub video_codec: AVCodecID,
    pub subtitle_codec: AVCodecID,
    pub flags: ::std::os::raw::c_int,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
}
#[test]
fn bindgen_test_layout_AVOutputFormat() {
    const UNINIT: ::std::mem::MaybeUninit<AVOutputFormat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVOutputFormat>(),
        64usize,
        concat!("Size of: ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOutputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mime_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_codec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_codec) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtitle_codec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_tag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_class) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVInputFormat {
    pub name: *const ::std::os::raw::c_char,
    pub long_name: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
    pub extensions: *const ::std::os::raw::c_char,
    pub codec_tag: *const *const AVCodecTag,
    pub priv_class: *const AVClass,
    pub mime_type: *const ::std::os::raw::c_char,
    pub raw_codec_id: ::std::os::raw::c_int,
    pub priv_data_size: ::std::os::raw::c_int,
    pub flags_internal: ::std::os::raw::c_int,
    pub read_probe: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const AVProbeData) -> ::std::os::raw::c_int,
    >,
    pub read_header: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    pub read_play: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVInputFormat() {
    const UNINIT: ::std::mem::MaybeUninit<AVInputFormat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVInputFormat>(),
        152usize,
        concat!("Size of: ", stringify!(AVInputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVInputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVInputFormat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_class) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mime_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_codec_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(raw_codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data_size) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_internal) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_probe) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_probe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_header) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_packet) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_close) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_seek) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_timestamp) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_play) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_play)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_pause) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_seek2) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_device_list) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
}
pub const AVSTREAM_PARSE_NONE: AVStreamParseType = 0;
pub const AVSTREAM_PARSE_FULL: AVStreamParseType = 1;
pub const AVSTREAM_PARSE_HEADERS: AVStreamParseType = 2;
pub const AVSTREAM_PARSE_TIMESTAMPS: AVStreamParseType = 3;
pub const AVSTREAM_PARSE_FULL_ONCE: AVStreamParseType = 4;
pub const AVSTREAM_PARSE_FULL_RAW: AVStreamParseType = 5;
pub type AVStreamParseType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIndexEntry {
    pub pos: i64,
    pub timestamp: i64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub min_distance: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVIndexEntry() {
    const UNINIT: ::std::mem::MaybeUninit<AVIndexEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVIndexEntry>(),
        24usize,
        concat!("Size of: ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIndexEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_distance) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(min_distance)
        )
    );
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn av_disposition_from_string(disp: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_disposition_to_string(
        disposition: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream {
    pub av_class: *const AVClass,
    pub index: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub codecpar: *mut AVCodecParameters,
    pub priv_data: *mut ::std::os::raw::c_void,
    pub time_base: AVRational,
    pub start_time: i64,
    pub duration: i64,
    pub nb_frames: i64,
    pub disposition: ::std::os::raw::c_int,
    pub discard: AVDiscard,
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    pub avg_frame_rate: AVRational,
    pub attached_pic: AVPacket,
    pub side_data: *mut AVPacketSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    pub event_flags: ::std::os::raw::c_int,
    pub r_frame_rate: AVRational,
    pub pts_wrap_bits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVStream() {
    const UNINIT: ::std::mem::MaybeUninit<AVStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVStream>(),
        232usize,
        concat!("Size of: ", stringify!(AVStream))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codecpar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codecpar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_frames) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disposition) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(disposition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discard) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avg_frame_rate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(avg_frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attached_pic) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(attached_pic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).side_data) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_side_data) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_flags) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_frame_rate) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(r_frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_wrap_bits) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_bits)
        )
    );
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
extern "C" {
    pub fn av_stream_get_first_dts(st: *const AVStream) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProgram {
    pub id: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub discard: AVDiscard,
    pub stream_index: *mut ::std::os::raw::c_uint,
    pub nb_stream_indexes: ::std::os::raw::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: ::std::os::raw::c_int,
    pub pmt_pid: ::std::os::raw::c_int,
    pub pcr_pid: ::std::os::raw::c_int,
    pub pmt_version: ::std::os::raw::c_int,
    pub start_time: i64,
    pub end_time: i64,
    pub pts_wrap_reference: i64,
    pub pts_wrap_behavior: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVProgram() {
    const UNINIT: ::std::mem::MaybeUninit<AVProgram> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVProgram>(),
        88usize,
        concat!("Size of: ", stringify!(AVProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProgram))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discard) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_stream_indexes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(nb_stream_indexes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).program_num) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(program_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmt_pid) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcr_pid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pcr_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmt_version) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_wrap_reference) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts_wrap_behavior) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChapter {
    pub id: i64,
    pub time_base: AVRational,
    pub start: i64,
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[test]
fn bindgen_test_layout_AVChapter() {
    const UNINIT: ::std::mem::MaybeUninit<AVChapter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVChapter>(),
        40usize,
        concat!("Size of: ", stringify!(AVChapter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChapter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChapter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(metadata)
        )
    );
}
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int,
>;
pub const AVFMT_DURATION_FROM_PTS: AVDurationEstimationMethod = 0;
pub const AVFMT_DURATION_FROM_STREAM: AVDurationEstimationMethod = 1;
pub const AVFMT_DURATION_FROM_BITRATE: AVDurationEstimationMethod = 2;
pub type AVDurationEstimationMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatContext {
    pub av_class: *const AVClass,
    pub iformat: *const AVInputFormat,
    pub oformat: *const AVOutputFormat,
    pub priv_data: *mut ::std::os::raw::c_void,
    pub pb: *mut AVIOContext,
    pub ctx_flags: ::std::os::raw::c_int,
    pub nb_streams: ::std::os::raw::c_uint,
    pub streams: *mut *mut AVStream,
    pub url: *mut ::std::os::raw::c_char,
    pub start_time: i64,
    pub duration: i64,
    pub bit_rate: i64,
    pub packet_size: ::std::os::raw::c_uint,
    pub max_delay: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub probesize: i64,
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: ::std::os::raw::c_int,
    pub nb_programs: ::std::os::raw::c_uint,
    pub programs: *mut *mut AVProgram,
    pub video_codec_id: AVCodecID,
    pub audio_codec_id: AVCodecID,
    pub subtitle_codec_id: AVCodecID,
    pub max_index_size: ::std::os::raw::c_uint,
    pub max_picture_buffer: ::std::os::raw::c_uint,
    pub nb_chapters: ::std::os::raw::c_uint,
    pub chapters: *mut *mut AVChapter,
    pub metadata: *mut AVDictionary,
    pub start_time_realtime: i64,
    pub fps_probe_size: ::std::os::raw::c_int,
    pub error_recognition: ::std::os::raw::c_int,
    pub interrupt_callback: AVIOInterruptCB,
    pub debug: ::std::os::raw::c_int,
    pub max_interleave_delta: i64,
    pub strict_std_compliance: ::std::os::raw::c_int,
    pub event_flags: ::std::os::raw::c_int,
    pub max_ts_probe: ::std::os::raw::c_int,
    pub avoid_negative_ts: ::std::os::raw::c_int,
    pub ts_id: ::std::os::raw::c_int,
    pub audio_preload: ::std::os::raw::c_int,
    pub max_chunk_duration: ::std::os::raw::c_int,
    pub max_chunk_size: ::std::os::raw::c_int,
    pub use_wallclock_as_timestamps: ::std::os::raw::c_int,
    pub avio_flags: ::std::os::raw::c_int,
    pub duration_estimation_method: AVDurationEstimationMethod,
    pub skip_initial_bytes: i64,
    pub correct_ts_overflow: ::std::os::raw::c_uint,
    pub seek2any: ::std::os::raw::c_int,
    pub flush_packets: ::std::os::raw::c_int,
    pub probe_score: ::std::os::raw::c_int,
    pub format_probesize: ::std::os::raw::c_int,
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    pub format_whitelist: *mut ::std::os::raw::c_char,
    pub io_repositioned: ::std::os::raw::c_int,
    pub video_codec: *const AVCodec,
    pub audio_codec: *const AVCodec,
    pub subtitle_codec: *const AVCodec,
    pub data_codec: *const AVCodec,
    pub metadata_header_padding: ::std::os::raw::c_int,
    pub opaque: *mut ::std::os::raw::c_void,
    pub control_message_cb: av_format_control_message,
    pub output_ts_offset: i64,
    pub dump_separator: *mut u8,
    pub data_codec_id: AVCodecID,
    pub protocol_whitelist: *mut ::std::os::raw::c_char,
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            options: *mut *mut AVDictionary,
        ) -> ::std::os::raw::c_int,
    >,
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    pub protocol_blacklist: *mut ::std::os::raw::c_char,
    pub max_streams: ::std::os::raw::c_int,
    pub skip_estimate_duration_from_pts: ::std::os::raw::c_int,
    pub max_probe_packets: ::std::os::raw::c_int,
    pub io_close2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut AVIOContext,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVFormatContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVFormatContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFormatContext>(),
        472usize,
        concat!("Size of: ", stringify!(AVFormatContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFormatContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFormatContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iformat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(iformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oformat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(oformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(pb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ctx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_streams) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_streams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(streams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_rate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_delay) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_analyze_duration) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_analyze_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_programs) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_programs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(programs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_codec_id) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_codec_id) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtitle_codec_id) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_index_size) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_index_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_picture_buffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_picture_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_chapters) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_chapters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chapters) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(chapters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_time_realtime) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time_realtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_probe_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(fps_probe_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_recognition) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(error_recognition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interrupt_callback) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(interrupt_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_interleave_delta) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_interleave_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_std_compliance) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_flags) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_ts_probe) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_ts_probe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avoid_negative_ts) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avoid_negative_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_id) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ts_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_preload) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_preload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_chunk_duration) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_chunk_size) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_wallclock_as_timestamps) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(use_wallclock_as_timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avio_flags) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avio_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration_estimation_method) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration_estimation_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_initial_bytes) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_initial_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correct_ts_overflow) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(correct_ts_overflow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek2any) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(seek2any)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_packets) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flush_packets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probe_score) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probe_score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_probesize) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_probesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_whitelist) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_whitelist) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_whitelist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_repositioned) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_repositioned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_codec) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_codec) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtitle_codec) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_codec) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_header_padding) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata_header_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_message_cb) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(control_message_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_ts_offset) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(output_ts_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_separator) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_codec_id) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_whitelist) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_open) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_blacklist) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_streams) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_streams)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).skip_estimate_duration_from_pts) as usize - ptr as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_estimate_duration_from_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_probe_packets) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_probe_packets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_close2) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close2)
        )
    );
}
extern "C" {
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
extern "C" {
    pub fn avformat_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avformat_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avformat_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avformat_network_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_network_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_muxer_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVOutputFormat;
}
extern "C" {
    pub fn av_demuxer_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVInputFormat;
}
extern "C" {
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    pub fn av_stream_get_class() -> *const AVClass;
}
extern "C" {
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_stream_get_side_data(
        stream: *const AVStream,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: ::std::os::raw::c_int) -> *mut AVProgram;
}
extern "C" {
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *const AVOutputFormat,
        format_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_input_format(short_name: *const ::std::os::raw::c_char) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format2(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_max: *mut ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_format3(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_ret: *mut ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const ::std::os::raw::c_char,
        fmt: *const AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: ::std::os::raw::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: ::std::os::raw::c_int,
        related_stream: ::std::os::raw::c_int,
        decoder_ret: *mut *const AVCodec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_flush(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_read_play(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_read_pause(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_interleaved_write_frame(
        s: *mut AVFormatContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_write_trailer(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_guess_format(
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
    ) -> *const AVOutputFormat;
}
extern "C" {
    pub fn av_guess_codec(
        fmt: *const AVOutputFormat,
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: ::std::os::raw::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_hex_dump_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        buf: *const u8,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    pub fn av_pkt_dump_log2(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    pub fn av_codec_get_id(
        tags: *const *const AVCodecTag,
        tag: ::std::os::raw::c_uint,
    ) -> AVCodecID;
}
extern "C" {
    pub fn av_codec_get_tag(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_index_get_entries_count(st: *const AVStream) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_index_get_entry(
        st: *mut AVStream,
        idx: ::std::os::raw::c_int,
    ) -> *const AVIndexEntry;
}
extern "C" {
    pub fn avformat_index_get_entry_from_timestamp(
        st: *mut AVStream,
        wanted_timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> *const AVIndexEntry;
}
extern "C" {
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: ::std::os::raw::c_int,
        distance: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_url_split(
        proto: *mut ::std::os::raw::c_char,
        proto_size: ::std::os::raw::c_int,
        authorization: *mut ::std::os::raw::c_char,
        authorization_size: ::std::os::raw::c_int,
        hostname: *mut ::std::os::raw::c_char,
        hostname_size: ::std::os::raw::c_int,
        port_ptr: *mut ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        path_size: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
        is_output: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_get_frame_filename2(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_filename_number_test(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_match_ext(
        filename: *const ::std::os::raw::c_char,
        extensions: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
pub const AVFMT_TBCF_AUTO: AVTimebaseSource = -1;
pub const AVFMT_TBCF_DECODER: AVTimebaseSource = 0;
pub const AVFMT_TBCF_DEMUXER: AVTimebaseSource = 1;
pub const AVFMT_TBCF_R_FRAMERATE: AVTimebaseSource = 2;
pub type AVTimebaseSource = ::std::os::raw::c_int;
extern "C" {
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
extern "C" {
    #[doc = " Return the LIBAVDEVICE_VERSION_INT constant."]
    pub fn avdevice_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavdevice build-time configuration."]
    pub fn avdevice_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavdevice license."]
    pub fn avdevice_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize libavdevice and register all the input and output devices."]
    pub fn avdevice_register_all();
}
extern "C" {
    #[doc = " Audio input devices iterator.\n\n If d is NULL, returns the first registered input audio/video device,\n if d is non-NULL, returns the next registered input audio/video device after d\n or NULL if d is the last one."]
    pub fn av_input_audio_device_next(d: *const AVInputFormat) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Video input devices iterator.\n\n If d is NULL, returns the first registered input audio/video device,\n if d is non-NULL, returns the next registered input audio/video device after d\n or NULL if d is the last one."]
    pub fn av_input_video_device_next(d: *const AVInputFormat) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Audio output devices iterator.\n\n If d is NULL, returns the first registered output audio/video device,\n if d is non-NULL, returns the next registered output audio/video device after d\n or NULL if d is the last one."]
    pub fn av_output_audio_device_next(d: *const AVOutputFormat) -> *const AVOutputFormat;
}
extern "C" {
    #[doc = " Video output devices iterator.\n\n If d is NULL, returns the first registered output audio/video device,\n if d is non-NULL, returns the next registered output audio/video device after d\n or NULL if d is the last one."]
    pub fn av_output_video_device_next(d: *const AVOutputFormat) -> *const AVOutputFormat;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceRect {
    #[doc = "< x coordinate of top left corner"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< y coordinate of top left corner"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< width"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< height"]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceRect() {
    const UNINIT: ::std::mem::MaybeUninit<AVDeviceRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDeviceRect>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceRect>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Dummy message."]
pub const AV_APP_TO_DEV_NONE: AVAppToDevMessageType = 1313820229;
#[doc = " Window size change message.\n\n Message is sent to the device every time the application changes the size\n of the window device renders to.\n Message should also be sent right after window is created.\n\n data: AVDeviceRect: new window size."]
pub const AV_APP_TO_DEV_WINDOW_SIZE: AVAppToDevMessageType = 1195724621;
#[doc = " Repaint request message.\n\n Message is sent to the device when window has to be repainted.\n\n data: AVDeviceRect: area required to be repainted.\n       NULL: whole area is required to be repainted."]
pub const AV_APP_TO_DEV_WINDOW_REPAINT: AVAppToDevMessageType = 1380274241;
#[doc = " Request pause/play.\n\n Application requests pause/unpause playback.\n Mostly usable with devices that have internal buffer.\n By default devices are not paused.\n\n data: NULL"]
pub const AV_APP_TO_DEV_PAUSE: AVAppToDevMessageType = 1346458912;
#[doc = " Request pause/play.\n\n Application requests pause/unpause playback.\n Mostly usable with devices that have internal buffer.\n By default devices are not paused.\n\n data: NULL"]
pub const AV_APP_TO_DEV_PLAY: AVAppToDevMessageType = 1347174745;
#[doc = " Request pause/play.\n\n Application requests pause/unpause playback.\n Mostly usable with devices that have internal buffer.\n By default devices are not paused.\n\n data: NULL"]
pub const AV_APP_TO_DEV_TOGGLE_PAUSE: AVAppToDevMessageType = 1346458964;
#[doc = " Volume control message.\n\n Set volume level. It may be device-dependent if volume\n is changed per stream or system wide. Per stream volume\n change is expected when possible.\n\n data: double: new volume with range of 0.0 - 1.0."]
pub const AV_APP_TO_DEV_SET_VOLUME: AVAppToDevMessageType = 1398165324;
#[doc = " Mute control messages.\n\n Change mute state. It may be device-dependent if mute status\n is changed per stream or system wide. Per stream mute status\n change is expected when possible.\n\n data: NULL."]
pub const AV_APP_TO_DEV_MUTE: AVAppToDevMessageType = 541939028;
#[doc = " Mute control messages.\n\n Change mute state. It may be device-dependent if mute status\n is changed per stream or system wide. Per stream mute status\n change is expected when possible.\n\n data: NULL."]
pub const AV_APP_TO_DEV_UNMUTE: AVAppToDevMessageType = 1431131476;
#[doc = " Mute control messages.\n\n Change mute state. It may be device-dependent if mute status\n is changed per stream or system wide. Per stream mute status\n change is expected when possible.\n\n data: NULL."]
pub const AV_APP_TO_DEV_TOGGLE_MUTE: AVAppToDevMessageType = 1414354260;
#[doc = " Get volume/mute messages.\n\n Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or\n AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.\n\n data: NULL."]
pub const AV_APP_TO_DEV_GET_VOLUME: AVAppToDevMessageType = 1196838732;
#[doc = " Get volume/mute messages.\n\n Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or\n AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.\n\n data: NULL."]
pub const AV_APP_TO_DEV_GET_MUTE: AVAppToDevMessageType = 1196250452;
#[doc = " Message types used by avdevice_app_to_dev_control_message()."]
pub type AVAppToDevMessageType = ::std::os::raw::c_uint;
#[doc = " Dummy message."]
pub const AV_DEV_TO_APP_NONE: AVDevToAppMessageType = 1313820229;
#[doc = " Create window buffer message.\n\n Device requests to create a window buffer. Exact meaning is device-\n and application-dependent. Message is sent before rendering first\n frame and all one-shot initializations should be done here.\n Application is allowed to ignore preferred window buffer size.\n\n @note: Application is obligated to inform about window buffer size\n        with AV_APP_TO_DEV_WINDOW_SIZE message.\n\n data: AVDeviceRect: preferred size of the window buffer.\n       NULL: no preferred size of the window buffer."]
pub const AV_DEV_TO_APP_CREATE_WINDOW_BUFFER: AVDevToAppMessageType = 1111708229;
#[doc = " Prepare window buffer message.\n\n Device requests to prepare a window buffer for rendering.\n Exact meaning is device- and application-dependent.\n Message is sent before rendering of each frame.\n\n data: NULL."]
pub const AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER: AVDevToAppMessageType = 1112560197;
#[doc = " Display window buffer message.\n\n Device requests to display a window buffer.\n Message is sent when new frame is ready to be displayed.\n Usually buffers need to be swapped in handler of this message.\n\n data: NULL."]
pub const AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER: AVDevToAppMessageType = 1111771475;
#[doc = " Destroy window buffer message.\n\n Device requests to destroy a window buffer.\n Message is sent when device is about to be destroyed and window\n buffer is not required anymore.\n\n data: NULL."]
pub const AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER: AVDevToAppMessageType = 1111770451;
#[doc = " Buffer fullness status messages.\n\n Device signals buffer overflow/underflow.\n\n data: NULL."]
pub const AV_DEV_TO_APP_BUFFER_OVERFLOW: AVDevToAppMessageType = 1112491596;
#[doc = " Buffer fullness status messages.\n\n Device signals buffer overflow/underflow.\n\n data: NULL."]
pub const AV_DEV_TO_APP_BUFFER_UNDERFLOW: AVDevToAppMessageType = 1112884812;
#[doc = " Buffer readable/writable.\n\n Device informs that buffer is readable/writable.\n When possible, device informs how many bytes can be read/write.\n\n @warning Device may not inform when number of bytes than can be read/write changes.\n\n data: int64_t: amount of bytes available to read/write.\n       NULL: amount of bytes available to read/write is not known."]
pub const AV_DEV_TO_APP_BUFFER_READABLE: AVDevToAppMessageType = 1112687648;
#[doc = " Buffer readable/writable.\n\n Device informs that buffer is readable/writable.\n When possible, device informs how many bytes can be read/write.\n\n @warning Device may not inform when number of bytes than can be read/write changes.\n\n data: int64_t: amount of bytes available to read/write.\n       NULL: amount of bytes available to read/write is not known."]
pub const AV_DEV_TO_APP_BUFFER_WRITABLE: AVDevToAppMessageType = 1113018912;
#[doc = " Mute state change message.\n\n Device informs that mute state has changed.\n\n data: int: 0 for not muted state, non-zero for muted state."]
pub const AV_DEV_TO_APP_MUTE_STATE_CHANGED: AVDevToAppMessageType = 1129141588;
#[doc = " Volume level change message.\n\n Device informs that volume level has changed.\n\n data: double: new volume with range of 0.0 - 1.0."]
pub const AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED: AVDevToAppMessageType = 1129729868;
#[doc = " Message types used by avdevice_dev_to_app_control_message()."]
pub type AVDevToAppMessageType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Send control message from application to device.\n\n @param s         device context.\n @param type      message type.\n @param data      message data. Exact type depends on message type.\n @param data_size size of message data.\n @return >= 0 on success, negative on error.\n         AVERROR(ENOSYS) when device doesn't implement handler of the message."]
    pub fn avdevice_app_to_dev_control_message(
        s: *mut AVFormatContext,
        type_: AVAppToDevMessageType,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send control message from device to application.\n\n @param s         device context.\n @param type      message type.\n @param data      message data. Can be NULL.\n @param data_size size of message data.\n @return >= 0 on success, negative on error.\n         AVERROR(ENOSYS) when application doesn't implement handler of the message."]
    pub fn avdevice_dev_to_app_control_message(
        s: *mut AVFormatContext,
        type_: AVDevToAppMessageType,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure describes basic parameters of the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfo {
    #[doc = "< device name, format depends on device"]
    pub device_name: *mut ::std::os::raw::c_char,
    #[doc = "< human friendly name"]
    pub device_description: *mut ::std::os::raw::c_char,
    #[doc = "< array indicating what media types(s), if any, a device can provide. If null, cannot provide any"]
    pub media_types: *mut AVMediaType,
    #[doc = "< length of media_types array, 0 if device cannot provide any media types"]
    pub nb_media_types: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AVDeviceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfo>(),
        32usize,
        concat!("Size of: ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_types) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(media_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_media_types) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(nb_media_types)
        )
    );
}
#[doc = " List of devices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfoList {
    #[doc = "< list of autodetected devices"]
    pub devices: *mut *mut AVDeviceInfo,
    #[doc = "< number of autodetected devices"]
    pub nb_devices: ::std::os::raw::c_int,
    #[doc = "< index of default device or -1 if no default"]
    pub default_device: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfoList() {
    const UNINIT: ::std::mem::MaybeUninit<AVDeviceInfoList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_devices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(nb_devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_device) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(default_device)
        )
    );
}
extern "C" {
    #[doc = " List devices.\n\n Returns available device names and their parameters.\n\n @note: Some devices may accept system-dependent device names that cannot be\n        autodetected. The list returned by this function cannot be assumed to\n        be always completed.\n\n @param s                device context.\n @param[out] device_list list of autodetected devices.\n @return count of autodetected devices, negative on error."]
    pub fn avdevice_list_devices(
        s: *mut AVFormatContext,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenient function to free result of avdevice_list_devices().\n\n @param device_list device list to be freed."]
    pub fn avdevice_free_list_devices(device_list: *mut *mut AVDeviceInfoList);
}
extern "C" {
    #[doc = " List devices.\n\n Returns available device names and their parameters.\n These are convinient wrappers for avdevice_list_devices().\n Device context is allocated and deallocated internally.\n\n @param device           device format. May be NULL if device name is set.\n @param device_name      device name. May be NULL if device format is set.\n @param device_options   An AVDictionary filled with device-private options. May be NULL.\n                         The same options must be passed later to avformat_write_header() for output\n                         devices or avformat_open_input() for input devices, or at any other place\n                         that affects device-private options.\n @param[out] device_list list of autodetected devices\n @return count of autodetected devices, negative on error.\n @note device argument takes precedence over device_name when both are set."]
    pub fn avdevice_list_input_sources(
        device: *const AVInputFormat,
        device_name: *const ::std::os::raw::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avdevice_list_output_sinks(
        device: *const AVOutputFormat,
        device_name: *const ::std::os::raw::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the LIBAVFILTER_VERSION_INT constant."]
    pub fn avfilter_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavfilter build-time configuration."]
    pub fn avfilter_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavfilter license."]
    pub fn avfilter_license() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterChannelLayouts {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the name of an AVFilterPad.\n\n @param pads an array of AVFilterPads\n @param pad_idx index of the pad in the array; it is the caller's\n                responsibility to ensure the index is valid\n\n @return name of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_name(
        pads: *const AVFilterPad,
        pad_idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the type of an AVFilterPad.\n\n @param pads an array of AVFilterPads\n @param pad_idx index of the pad in the array; it is the caller's\n                responsibility to ensure the index is valid\n\n @return type of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_type(
        pads: *const AVFilterPad,
        pad_idx: ::std::os::raw::c_int,
    ) -> AVMediaType;
}
#[doc = " Filter definition. This defines the pads a filter contains, and all the\n callback functions used to interact with the filter."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilter {
    #[doc = " Filter name. Must be non-NULL and unique among filters."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A description of the filter. May be NULL.\n\n You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " List of static inputs.\n\n NULL if there are no (static) inputs. Instances of filters with\n AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in\n this list."]
    pub inputs: *const AVFilterPad,
    #[doc = " List of static outputs.\n\n NULL if there are no (static) outputs. Instances of filters with\n AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in\n this list."]
    pub outputs: *const AVFilterPad,
    #[doc = " A class for the private data, used to declare filter private AVOptions.\n This field is NULL for filters that do not declare any options.\n\n If this field is non-NULL, the first member of the filter private data\n must be a pointer to AVClass, which will be set by libavfilter generic\n code to this class."]
    pub priv_class: *const AVClass,
    #[doc = " A combination of AVFILTER_FLAG_*"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " The number of entries in the list of inputs."]
    pub nb_inputs: u8,
    #[doc = " The number of entries in the list of outputs."]
    pub nb_outputs: u8,
    #[doc = " This field determines the state of the formats union.\n It is an enum FilterFormatsState value."]
    pub formats_state: u8,
    #[doc = " Filter pre-initialization function\n\n This callback will be called immediately after the filter context is\n allocated, to allow allocating and initing sub-objects.\n\n If this callback is not NULL, the uninit callback will be called on\n allocation failure.\n\n @return 0 on success,\n         AVERROR code on failure (but the code will be\n           dropped and treated as ENOMEM by the calling code)"]
    pub preinit: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter initialization function.\n\n This callback will be called only once during the filter lifetime, after\n all the options have been set, but before links between filters are\n established and format negotiation is done.\n\n Basic filter initialization should be done here. Filters with dynamic\n inputs and/or outputs should create those inputs/outputs here based on\n provided options. No more changes to this filter's inputs/outputs can be\n done after this callback.\n\n This callback must not assume that the filter links exist or frame\n parameters are known.\n\n @ref AVFilter.uninit \"uninit\" is guaranteed to be called even if\n initialization fails, so this callback does not have to clean up on\n failure.\n\n @return 0 on success, a negative AVERROR on failure"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter uninitialization function.\n\n Called only once right before the filter is freed. Should deallocate any\n memory held by the filter, release any buffer references, etc. It does\n not need to deallocate the AVFilterContext.priv memory itself.\n\n This callback may be called even if @ref AVFilter.init \"init\" was not\n called or failed, so it must be prepared to handle such a situation."]
    pub uninit: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext)>,
    pub formats: AVFilter__bindgen_ty_1,
    #[doc = "< size of private data to allocate for the filter"]
    pub priv_size: ::std::os::raw::c_int,
    #[doc = "< Additional flags for avfilter internal use only."]
    pub flags_internal: ::std::os::raw::c_int,
    #[doc = " Make the filter instance process a command.\n\n @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only\n @param arg    the argument for the command\n @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.\n @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be\n               time consuming then a filter should treat it like an unsupported command\n\n @returns >=0 on success otherwise an error code.\n          AVERROR(ENOSYS) on unsupported commands"]
    pub process_command: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFilterContext,
            cmd: *const ::std::os::raw::c_char,
            arg: *const ::std::os::raw::c_char,
            res: *mut ::std::os::raw::c_char,
            res_len: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter activation function.\n\n Called when any processing is needed from the filter, instead of any\n filter_frame and request_frame on pads.\n\n The function must examine inlinks and outlinks and perform a single\n step of processing. If there is nothing to do, the function must do\n nothing and not return an error. If more steps are or may be\n possible, it must use ff_filter_set_ready() to schedule another\n activation."]
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
}
#[doc = " The state of the following union is determined by formats_state.\n See the documentation of enum FilterFormatsState in internal.h."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVFilter__bindgen_ty_1 {
    #[doc = " Query formats supported by the filter on its inputs and outputs.\n\n This callback is called after the filter is initialized (so the inputs\n and outputs are fixed), shortly before the format negotiation. This\n callback may be called more than once.\n\n This callback must set ::AVFilterLink's\n @ref AVFilterFormatsConfig.formats \"outcfg.formats\"\n on every input link and\n @ref AVFilterFormatsConfig.formats \"incfg.formats\"\n on every output link to a list of pixel/sample formats that the filter\n supports on that link.\n For audio links, this filter must also set\n @ref AVFilterFormatsConfig.samplerates \"incfg.samplerates\"\n  /\n @ref AVFilterFormatsConfig.samplerates \"outcfg.samplerates\"\n and @ref AVFilterFormatsConfig.channel_layouts \"incfg.channel_layouts\"\n  /\n @ref AVFilterFormatsConfig.channel_layouts \"outcfg.channel_layouts\"\n analogously.\n\n This callback must never be NULL if the union is in this state.\n\n @return zero on success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub query_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " A pointer to an array of admissible pixel formats delimited\n by AV_PIX_FMT_NONE. The generic code will use this list\n to indicate that this filter supports each of these pixel formats,\n provided that all inputs and outputs use the same pixel format.\n\n This list must never be NULL if the union is in this state.\n The type of all inputs and outputs of filters using this must\n be AVMEDIA_TYPE_VIDEO."]
    pub pixels_list: *const AVPixelFormat,
    #[doc = " Analogous to pixels, but delimited by AV_SAMPLE_FMT_NONE\n and restricted to filters that only have AVMEDIA_TYPE_AUDIO\n inputs and outputs.\n\n In addition to that the generic code will mark all inputs\n and all outputs as supporting all sample rates and every\n channel count and channel layout, as long as all inputs\n and outputs use the same sample rate and channel count/layout."]
    pub samples_list: *const AVSampleFormat,
    #[doc = " Equivalent to { pix_fmt, AV_PIX_FMT_NONE } as pixels_list."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Equivalent to { sample_fmt, AV_SAMPLE_FMT_NONE } as samples_list."]
    pub sample_fmt: AVSampleFormat,
}
#[test]
fn bindgen_test_layout_AVFilter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVFilter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(query_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixels_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(pixels_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(samples_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_fmt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_fmt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter__bindgen_ty_1),
            "::",
            stringify!(sample_fmt)
        )
    );
}
impl ::std::fmt::Debug for AVFilter__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "AVFilter__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_AVFilter() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilter>(),
        104usize,
        concat!("Size of: ", stringify!(AVFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_class) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inputs) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_outputs) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(nb_outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formats_state) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(formats_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preinit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(preinit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uninit) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formats) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_internal) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_command) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(process_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(activate)
        )
    );
}
impl ::std::fmt::Debug for AVFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVFilter {{ name: {:?}, description: {:?}, inputs: {:?}, outputs: {:?}, priv_class: {:?}, flags: {:?}, nb_inputs: {:?}, nb_outputs: {:?}, formats_state: {:?}, preinit: {:?}, init: {:?}, uninit: {:?}, formats: {:?}, priv_size: {:?}, flags_internal: {:?}, process_command: {:?}, activate: {:?} }}" , self . name , self . description , self . inputs , self . outputs , self . priv_class , self . flags , self . nb_inputs , self . nb_outputs , self . formats_state , self . preinit , self . init , self . uninit , self . formats , self . priv_size , self . flags_internal , self . process_command , self . activate)
    }
}
extern "C" {
    #[doc = " Get the number of elements in an AVFilter's inputs or outputs array."]
    pub fn avfilter_filter_pad_count(
        filter: *const AVFilter,
        is_output: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInternal {
    _unused: [u8; 0],
}
#[doc = " An instance of a filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterContext {
    #[doc = "< needed for av_log() and filters common options"]
    pub av_class: *const AVClass,
    #[doc = "< the AVFilter of which this is an instance"]
    pub filter: *const AVFilter,
    #[doc = "< name of this filter instance"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< array of input pads"]
    pub input_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to input links"]
    pub inputs: *mut *mut AVFilterLink,
    #[doc = "< number of input pads"]
    pub nb_inputs: ::std::os::raw::c_uint,
    #[doc = "< array of output pads"]
    pub output_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to output links"]
    pub outputs: *mut *mut AVFilterLink,
    #[doc = "< number of output pads"]
    pub nb_outputs: ::std::os::raw::c_uint,
    #[doc = "< private data for use by the filter"]
    pub priv_: *mut ::std::os::raw::c_void,
    #[doc = "< filtergraph this filter belongs to"]
    pub graph: *mut AVFilterGraph,
    #[doc = " Type of multithreading being allowed/used. A combination of\n AVFILTER_THREAD_* flags.\n\n May be set by the caller before initializing the filter to forbid some\n or all kinds of multithreading for this filter. The default is allowing\n everything.\n\n When the filter is initialized, this field is combined using bit AND with\n AVFilterGraph.thread_type to get the final mask used for determining\n allowed threading types. I.e. a threading type needs to be set in both\n to be allowed.\n\n After the filter is initialized, libavfilter sets this field to the\n threading type that is actually used (0 for no multithreading)."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " An opaque struct for libavfilter internal use."]
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    #[doc = "< enable expression string"]
    pub enable_str: *mut ::std::os::raw::c_char,
    #[doc = "< parsed expression (AVExpr*)"]
    pub enable: *mut ::std::os::raw::c_void,
    #[doc = "< variable values for the enable expression"]
    pub var_values: *mut f64,
    #[doc = "< the enabled state from the last expression evaluation"]
    pub is_disabled: ::std::os::raw::c_int,
    #[doc = " For filters which will create hardware frames, sets the device the\n filter should create them in.  All other filters will ignore this field:\n in particular, a filter which consumes or processes hardware frames will\n instead use the hw_frames_ctx field in AVFilterLink to carry the\n hardware context information.\n\n May be set by the caller on filters flagged with AVFILTER_FLAG_HWDEVICE\n before initializing the filter with avfilter_init_str() or\n avfilter_init_dict()."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Max number of threads allowed in this filter instance.\n If <= 0, its value is ignored.\n Overrides global number of threads set per filter graph."]
    pub nb_threads: ::std::os::raw::c_int,
    #[doc = " Ready status of the filter.\n A non-0 value means that the filter needs activating;\n a higher value suggests a more urgent activation."]
    pub ready: ::std::os::raw::c_uint,
    #[doc = " Sets the number of extra hardware frames which the filter will\n allocate on its output links for use in following filters or by\n the caller.\n\n Some hardware filters require all frames that they will use for\n output to be defined in advance before filtering starts.  For such\n filters, any hardware frame pools used for output must therefore be\n of fixed size.  The extra frames set here are on top of any number\n that the filter needs internally in order to operate normally.\n\n This field must be set before the graph containing this filter is\n configured."]
    pub extra_hw_frames: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVFilterContext() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterContext>(),
        168usize,
        concat!("Size of: ", stringify!(AVFilterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_pads) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(input_pads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inputs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_pads) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(output_pads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_outputs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_queue) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_str) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var_values) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(var_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_disabled) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(is_disabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_device_ctx) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_threads) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_hw_frames) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(extra_hw_frames)
        )
    );
}
#[doc = " Lists of formats / etc. supported by an end of a link.\n\n This structure is directly part of AVFilterLink, in two copies:\n one for the source filter, one for the destination filter.\n\n These lists are used for negotiating the format to actually be used,\n which will be loaded into the format and channel_layout members of\n AVFilterLink, when chosen."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormatsConfig {
    #[doc = " List of supported formats (pixel or sample)."]
    pub formats: *mut AVFilterFormats,
    #[doc = " Lists of supported sample rates, only for audio."]
    pub samplerates: *mut AVFilterFormats,
    #[doc = " Lists of supported channel layouts, only for audio."]
    pub channel_layouts: *mut AVFilterChannelLayouts,
}
#[test]
fn bindgen_test_layout_AVFilterFormatsConfig() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterFormatsConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterFormatsConfig>(),
        24usize,
        concat!("Size of: ", stringify!(AVFilterFormatsConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterFormatsConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterFormatsConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formats) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(samplerates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layouts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterFormatsConfig),
            "::",
            stringify!(channel_layouts)
        )
    );
}
#[doc = " A link between two filters. This contains pointers to the source and\n destination filters between which this link exists, and the indexes of\n the pads involved. In addition, this link also contains the parameters\n which have been negotiated and agreed upon between the filter, such as\n image dimensions, format, etc.\n\n Applications must not normally access the link structure directly.\n Use the buffersrc and buffersink API instead.\n In the future, access to the header may be reserved for filters\n implementation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilterLink {
    #[doc = "< source filter"]
    pub src: *mut AVFilterContext,
    #[doc = "< output pad on the source filter"]
    pub srcpad: *mut AVFilterPad,
    #[doc = "< dest filter"]
    pub dst: *mut AVFilterContext,
    #[doc = "< input pad on the dest filter"]
    pub dstpad: *mut AVFilterPad,
    #[doc = "< filter media type"]
    pub type_: AVMediaType,
    #[doc = "< agreed upon image width"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< agreed upon image height"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< agreed upon sample aspect ratio"]
    pub sample_aspect_ratio: AVRational,
    #[doc = " channel layout of current buffer (see libavutil/channel_layout.h)\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = "< samples per second"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = "< agreed upon media format"]
    pub format: ::std::os::raw::c_int,
    #[doc = " Define the time base used by the PTS of the frames/samples\n which will pass through this link.\n During the configuration stage, each filter is supposed to\n change only the output timebase, while the timebase of the\n input link is assumed to be an unchangeable property."]
    pub time_base: AVRational,
    #[doc = "< channel layout of current buffer (see libavutil/channel_layout.h)"]
    pub ch_layout: AVChannelLayout,
    #[doc = " Lists of supported formats / etc. supported by the input filter."]
    pub incfg: AVFilterFormatsConfig,
    #[doc = " Lists of supported formats / etc. supported by the output filter."]
    pub outcfg: AVFilterFormatsConfig,
    pub init_state: AVFilterLink__bindgen_ty_1,
    #[doc = " Graph the filter belongs to."]
    pub graph: *mut AVFilterGraph,
    #[doc = " Current timestamp of the link, as defined by the most recent\n frame(s), in link time_base units."]
    pub current_pts: i64,
    #[doc = " Current timestamp of the link, as defined by the most recent\n frame(s), in AV_TIME_BASE units."]
    pub current_pts_us: i64,
    #[doc = " Index in the age array."]
    pub age_index: ::std::os::raw::c_int,
    #[doc = " Frame rate of the stream on the link, or 1/0 if unknown or variable;\n if left to 0/0, will be automatically copied from the first input\n of the source filter if it exists.\n\n Sources should set it to the best estimation of the real frame rate.\n If the source frame rate is unknown or variable, set this to 1/0.\n Filters should update it if necessary depending on their function.\n Sinks can use it to set a default output frame rate.\n It is similar to the r_frame_rate field in AVStream."]
    pub frame_rate: AVRational,
    #[doc = " Minimum number of samples to filter at once. If filter_frame() is\n called with fewer samples, it will accumulate them in fifo.\n This field and the related ones must not be changed after filtering\n has started.\n If 0, all related fields are ignored."]
    pub min_samples: ::std::os::raw::c_int,
    #[doc = " Maximum number of samples to filter at once. If filter_frame() is\n called with more samples, it will split them."]
    pub max_samples: ::std::os::raw::c_int,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_in: i64,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_out: i64,
    #[doc = " Number of past samples sent through the link."]
    pub sample_count_in: i64,
    #[doc = " Number of past samples sent through the link."]
    pub sample_count_out: i64,
    #[doc = " A pointer to a FFFramePool struct."]
    pub frame_pool: *mut ::std::os::raw::c_void,
    #[doc = " True if a frame is currently wanted on the output of this filter.\n Set when ff_request_frame() is called by the output,\n cleared when a frame is filtered."]
    pub frame_wanted_out: ::std::os::raw::c_int,
    #[doc = " For hwaccel pixel formats, this should be a reference to the\n AVHWFramesContext describing the frames."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Internal structure members.\n The fields below this limit are internal for libavfilter's use\n and must in no way be accessed by applications."]
    pub reserved: [::std::os::raw::c_char; 61440usize],
}
#[doc = "< not started"]
pub const AVLINK_UNINIT: AVFilterLink__bindgen_ty_1 = 0;
#[doc = "< started, but incomplete"]
pub const AVLINK_STARTINIT: AVFilterLink__bindgen_ty_1 = 1;
#[doc = "< complete"]
pub const AVLINK_INIT: AVFilterLink__bindgen_ty_1 = 2;
#[doc = " stage of the initialization of the link properties (dimensions, etc)"]
pub type AVFilterLink__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_AVFilterLink() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterLink> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterLink>(),
        61704usize,
        concat!("Size of: ", stringify!(AVFilterLink))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterLink>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterLink))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcpad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(srcpad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstpad) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dstpad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layout) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(ch_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incfg) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(incfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outcfg) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(outcfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_state) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(init_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_pts) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_pts_us) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age_index) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(age_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_samples) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(min_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_samples) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_count_in) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_count_out) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_count_in) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_count_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_count_out) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_count_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_pool) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_wanted_out) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_wanted_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_frames_ctx) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(reserved)
        )
    );
}
impl ::std::fmt::Debug for AVFilterLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVFilterLink {{ src: {:?}, srcpad: {:?}, dst: {:?}, dstpad: {:?}, type: {:?}, w: {:?}, h: {:?}, sample_aspect_ratio: {:?}, channel_layout: {:?}, sample_rate: {:?}, format: {:?}, time_base: {:?}, ch_layout: {:?}, incfg: {:?}, outcfg: {:?}, init_state: {:?}, graph: {:?}, current_pts: {:?}, current_pts_us: {:?}, age_index: {:?}, frame_rate: {:?}, min_samples: {:?}, max_samples: {:?}, frame_count_in: {:?}, frame_count_out: {:?}, sample_count_in: {:?}, sample_count_out: {:?}, frame_pool: {:?}, frame_wanted_out: {:?}, hw_frames_ctx: {:?}, reserved: {:?} }}" , self . src , self . srcpad , self . dst , self . dstpad , self . type_ , self . w , self . h , self . sample_aspect_ratio , self . channel_layout , self . sample_rate , self . format , self . time_base , self . ch_layout , self . incfg , self . outcfg , self . init_state , self . graph , self . current_pts , self . current_pts_us , self . age_index , self . frame_rate , self . min_samples , self . max_samples , self . frame_count_in , self . frame_count_out , self . sample_count_in , self . sample_count_out , self . frame_pool , self . frame_wanted_out , self . hw_frames_ctx , self . reserved)
    }
}
extern "C" {
    #[doc = " Link two filters together.\n\n @param src    the source filter\n @param srcpad index of the output pad on the source filter\n @param dst    the destination filter\n @param dstpad index of the input pad on the destination filter\n @return       zero on success"]
    pub fn avfilter_link(
        src: *mut AVFilterContext,
        srcpad: ::std::os::raw::c_uint,
        dst: *mut AVFilterContext,
        dstpad: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the link in *link, and set its pointer to NULL."]
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
}
extern "C" {
    #[doc = " Negotiate the media format, dimensions, etc of all inputs to a filter.\n\n @param filter the filter to negotiate the properties for its inputs\n @return       zero on successful negotiation"]
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make the filter instance process a command.\n It is recommended to use avfilter_graph_send_command()."]
    pub fn avfilter_process_command(
        filter: *mut AVFilterContext,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_char,
        res_len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over all registered filters.\n\n @param opaque a pointer where libavfilter will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered filter or NULL when the iteration is\n         finished"]
    pub fn av_filter_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVFilter;
}
extern "C" {
    #[doc = " Get a filter definition matching the given name.\n\n @param name the filter name to find\n @return     the filter definition, if any matching one is registered.\n             NULL if none found."]
    pub fn avfilter_get_by_name(name: *const ::std::os::raw::c_char) -> *const AVFilter;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied parameters.\n\n @param ctx  uninitialized filter context to initialize\n @param args Options to initialize the filter with. This must be a\n             ':'-separated list of options in the 'key=value' form.\n             May be NULL if the options have been set directly using the\n             AVOptions API or there are no options that need to be set.\n @return 0 on success, a negative AVERROR on failure"]
    pub fn avfilter_init_str(
        ctx: *mut AVFilterContext,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied dictionary of options.\n\n @param ctx     uninitialized filter context to initialize\n @param options An AVDictionary filled with options for this filter. On\n                return this parameter will be destroyed and replaced with\n                a dict containing options that were not found. This dictionary\n                must be freed by the caller.\n                May be NULL, then this function is equivalent to\n                avfilter_init_str() with the second parameter set to NULL.\n @return 0 on success, a negative AVERROR on failure\n\n @note This function and avfilter_init_str() do essentially the same thing,\n the difference is in manner in which the options are passed. It is up to the\n calling code to choose whichever is more preferable. The two functions also\n behave differently when some of the provided options are not declared as\n supported by the filter. In such a case, avfilter_init_str() will fail, but\n this function will leave those extra options in the options AVDictionary and\n continue as usual."]
    pub fn avfilter_init_dict(
        ctx: *mut AVFilterContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a filter context. This will also remove the filter from its\n filtergraph's list of filters.\n\n @param filter the filter to free"]
    pub fn avfilter_free(filter: *mut AVFilterContext);
}
extern "C" {
    #[doc = " Insert a filter in the middle of an existing link.\n\n @param link the link into which the filter should be inserted\n @param filt the filter to be inserted\n @param filt_srcpad_idx the input pad on the filter to connect\n @param filt_dstpad_idx the output pad on the filter to connect\n @return     zero on success"]
    pub fn avfilter_insert_filter(
        link: *mut AVFilterLink,
        filt: *mut AVFilterContext,
        filt_srcpad_idx: ::std::os::raw::c_uint,
        filt_dstpad_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return AVClass for AVFilterContext.\n\n @see av_opt_find()."]
    pub fn avfilter_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphInternal {
    _unused: [u8; 0],
}
#[doc = " A function pointer passed to the @ref AVFilterGraph.execute callback to be\n executed multiple times, possibly in parallel.\n\n @param ctx the filter context the job belongs to\n @param arg an opaque parameter passed through from @ref\n            AVFilterGraph.execute\n @param jobnr the index of the job being executed\n @param nb_jobs the total number of jobs\n\n @return 0 on success, a negative AVERROR on error"]
pub type avfilter_action_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        arg: *mut ::std::os::raw::c_void,
        jobnr: ::std::os::raw::c_int,
        nb_jobs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A function executing multiple jobs, possibly in parallel.\n\n @param ctx the filter context to which the jobs belong\n @param func the function to be called multiple times\n @param arg the argument to be passed to func\n @param ret a nb_jobs-sized array to be filled with return values from each\n            invocation of func\n @param nb_jobs the number of jobs to execute\n\n @return 0 on success, a negative AVERROR on error"]
pub type avfilter_execute_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        func: avfilter_action_func,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        nb_jobs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: ::std::os::raw::c_uint,
    #[doc = "< sws options to use for the auto-inserted scale filters"]
    pub scale_sws_opts: *mut ::std::os::raw::c_char,
    #[doc = " Type of multithreading allowed for filters in this graph. A combination\n of AVFILTER_THREAD_* flags.\n\n May be set by the caller at any point, the setting will apply to all\n filters initialized after that. The default is allowing everything.\n\n When a filter in this graph is initialized, this field is combined using\n bit AND with AVFilterContext.thread_type to get the final mask used for\n determining allowed threading types. I.e. a threading type needs to be\n set in both to be allowed."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " Maximum number of threads used by filters in this graph. May be set by\n the caller before adding any filters to the filtergraph. Zero (the\n default) means that the number of threads is determined automatically."]
    pub nb_threads: ::std::os::raw::c_int,
    #[doc = " Opaque object for libavfilter internal use."]
    pub internal: *mut AVFilterGraphInternal,
    #[doc = " Opaque user data. May be set by the caller to an arbitrary value, e.g. to\n be used from callbacks like @ref AVFilterGraph.execute.\n Libavfilter will not touch this field in any way."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " This callback may be set by the caller immediately after allocating the\n graph and before adding any filters to it, to provide a custom\n multithreading implementation.\n\n If set, filters with slice threading capability will call this callback\n to execute multiple jobs in parallel.\n\n If this field is left unset, libavfilter will use its internal\n implementation, which may or may not be multithreaded depending on the\n platform and build options."]
    pub execute: avfilter_execute_func,
    #[doc = "< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions"]
    pub aresample_swr_opts: *mut ::std::os::raw::c_char,
    #[doc = " Private fields\n\n The following fields are for internal use only.\n Their type, offset, number and semantic can change without notice."]
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: ::std::os::raw::c_int,
    pub disable_auto_convert: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterGraph() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterGraph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterGraph>(),
        88usize,
        concat!("Size of: ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_filters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_sws_opts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(scale_sws_opts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_threads) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aresample_swr_opts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(aresample_swr_opts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sink_links) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sink_links_count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_auto_convert) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(disable_auto_convert)
        )
    );
}
extern "C" {
    #[doc = " Allocate a filter graph.\n\n @return the allocated filter graph on success or NULL."]
    pub fn avfilter_graph_alloc() -> *mut AVFilterGraph;
}
extern "C" {
    #[doc = " Create a new filter instance in a filter graph.\n\n @param graph graph in which the new filter will be used\n @param filter the filter to create an instance of\n @param name Name to give to the new instance (will be copied to\n             AVFilterContext.name). This may be used by the caller to identify\n             different filters, libavfilter itself assigns no semantics to\n             this parameter. May be NULL.\n\n @return the context of the newly created filter instance (note that it is\n         also retrievable directly through AVFilterGraph.filters or with\n         avfilter_graph_get_filter()) on success or NULL on failure."]
    pub fn avfilter_graph_alloc_filter(
        graph: *mut AVFilterGraph,
        filter: *const AVFilter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Get a filter instance identified by instance name from graph.\n\n @param graph filter graph to search through.\n @param name filter instance name (should be unique in the graph).\n @return the pointer to the found filter instance or NULL if it\n cannot be found."]
    pub fn avfilter_graph_get_filter(
        graph: *mut AVFilterGraph,
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Create and add a filter instance into an existing graph.\n The filter instance is created from the filter filt and inited\n with the parameter args. opaque is currently ignored.\n\n In case of success put in *filt_ctx the pointer to the created\n filter instance, otherwise set *filt_ctx to NULL.\n\n @param name the instance name to give to the created filter instance\n @param graph_ctx the filter graph\n @return a negative AVERROR error code in case of failure, a non\n negative value otherwise"]
    pub fn avfilter_graph_create_filter(
        filt_ctx: *mut *mut AVFilterContext,
        filt: *const AVFilter,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
        graph_ctx: *mut AVFilterGraph,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable automatic format conversion inside the graph.\n\n Note that format conversion can still happen inside explicitly inserted\n scale and aresample filters.\n\n @param flags  any of the AVFILTER_AUTO_CONVERT_* constants"]
    pub fn avfilter_graph_set_auto_convert(
        graph: *mut AVFilterGraph,
        flags: ::std::os::raw::c_uint,
    );
}
#[doc = "< all automatic conversions enabled"]
pub const AVFILTER_AUTO_CONVERT_ALL: _bindgen_ty_6 = 0;
#[doc = "< all automatic conversions disabled"]
pub const AVFILTER_AUTO_CONVERT_NONE: _bindgen_ty_6 = -1;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Check validity and configure all the links and formats in the graph.\n\n @param graphctx the filter graph\n @param log_ctx context used for logging\n @return >= 0 in case of success, a negative AVERROR code otherwise"]
    pub fn avfilter_graph_config(
        graphctx: *mut AVFilterGraph,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a graph, destroy its links, and set *graph to NULL.\n If *graph is NULL, do nothing."]
    pub fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
}
#[doc = " A linked-list of the inputs/outputs of the filter chain.\n\n This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),\n where it is used to communicate open (unlinked) inputs and outputs from and\n to the caller.\n This struct specifies, per each not connected pad contained in the graph, the\n filter context and the pad index required for establishing a link."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInOut {
    #[doc = " unique name for this input/output in the list"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " filter context associated to this input/output"]
    pub filter_ctx: *mut AVFilterContext,
    #[doc = " index of the filt_ctx pad to use for linking"]
    pub pad_idx: ::std::os::raw::c_int,
    #[doc = " next input/input in the list, NULL if this is the last"]
    pub next: *mut AVFilterInOut,
}
#[test]
fn bindgen_test_layout_AVFilterInOut() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterInOut> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterInOut>(),
        32usize,
        concat!("Size of: ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(filter_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad_idx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(pad_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Allocate a single AVFilterInOut entry.\n Must be freed with avfilter_inout_free().\n @return allocated AVFilterInOut on success, NULL on failure."]
    pub fn avfilter_inout_alloc() -> *mut AVFilterInOut;
}
extern "C" {
    #[doc = " Free the supplied list of AVFilterInOut and set *inout to NULL.\n If *inout is NULL, do nothing."]
    pub fn avfilter_inout_free(inout: *mut *mut AVFilterInOut);
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph.\n\n @note The caller must provide the lists of inputs and outputs,\n which therefore must be known before calling the function.\n\n @note The inputs parameter describes inputs of the already existing\n part of the graph; i.e. from the point of view of the newly created\n part, they are outputs. Similarly the outputs parameter describes\n outputs of the already existing filters, which are provided as\n inputs to the parsed filters.\n\n @param graph   the filter graph where to link the parsed graph context\n @param filters string to be parsed\n @param inputs  linked list to the inputs of the graph\n @param outputs linked list to the outputs of the graph\n @return zero on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut AVFilterInOut,
        outputs: *mut AVFilterInOut,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph.\n\n In the graph filters description, if the input label of the first\n filter is not specified, \"in\" is assumed; if the output label of\n the last filter is not specified, \"out\" is assumed.\n\n @param graph   the filter graph where to link the parsed graph context\n @param filters string to be parsed\n @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.\n                If non-NULL, *inputs is updated to contain the list of open inputs\n                after the parsing, should be freed with avfilter_inout_free().\n @param outputs pointer to a linked list to the outputs of the graph, may be NULL.\n                If non-NULL, *outputs is updated to contain the list of open outputs\n                after the parsing, should be freed with avfilter_inout_free().\n @return non negative on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse_ptr(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph.\n\n @param[in]  graph   the filter graph where to link the parsed graph context\n @param[in]  filters string to be parsed\n @param[out] inputs  a linked list of all free (unlinked) inputs of the\n                     parsed graph will be returned here. It is to be freed\n                     by the caller using avfilter_inout_free().\n @param[out] outputs a linked list of all free (unlinked) outputs of the\n                     parsed graph will be returned here. It is to be freed by the\n                     caller using avfilter_inout_free().\n @return zero on success, a negative AVERROR code on error\n\n @note This function returns the inputs and outputs that are left\n unlinked after parsing the graph and the caller then deals with\n them.\n @note This function makes no reference whatsoever to already\n existing parts of the graph and the inputs parameter will on return\n contain inputs of the newly parsed part of the graph.  Analogously\n the outputs parameter will contain outputs of the newly created\n filters."]
    pub fn avfilter_graph_parse2(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Parameters of a filter's input or output pad.\n\n Created as a child of AVFilterParams by avfilter_graph_segment_parse().\n Freed in avfilter_graph_segment_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPadParams {
    #[doc = " An av_malloc()'ed string containing the pad label.\n\n May be av_free()'d and set to NULL by the caller, in which case this pad\n will be treated as unlabeled for linking.\n May also be replaced by another av_malloc()'ed string."]
    pub label: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVFilterPadParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterPadParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterPadParams>(),
        8usize,
        concat!("Size of: ", stringify!(AVFilterPadParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterPadParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterPadParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterPadParams),
            "::",
            stringify!(label)
        )
    );
}
#[doc = " Parameters describing a filter to be created in a filtergraph.\n\n Created as a child of AVFilterGraphSegment by avfilter_graph_segment_parse().\n Freed in avfilter_graph_segment_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterParams {
    #[doc = " The filter context.\n\n Created by avfilter_graph_segment_create_filters() based on\n AVFilterParams.filter_name and instance_name.\n\n Callers may also create the filter context manually, then they should\n av_free() filter_name and set it to NULL. Such AVFilterParams instances\n are then skipped by avfilter_graph_segment_create_filters()."]
    pub filter: *mut AVFilterContext,
    #[doc = " Name of the AVFilter to be used.\n\n An av_malloc()'ed string, set by avfilter_graph_segment_parse(). Will be\n passed to avfilter_get_by_name() by\n avfilter_graph_segment_create_filters().\n\n Callers may av_free() this string and replace it with another one or\n NULL. If the caller creates the filter instance manually, this string\n MUST be set to NULL.\n\n When both AVFilterParams.filter an AVFilterParams.filter_name are NULL,\n this AVFilterParams instance is skipped by avfilter_graph_segment_*()\n functions."]
    pub filter_name: *mut ::std::os::raw::c_char,
    #[doc = " Name to be used for this filter instance.\n\n An av_malloc()'ed string, may be set by avfilter_graph_segment_parse() or\n left NULL. The caller may av_free() this string and replace with another\n one or NULL.\n\n Will be used by avfilter_graph_segment_create_filters() - passed as the\n third argument to avfilter_graph_alloc_filter(), then freed and set to\n NULL."]
    pub instance_name: *mut ::std::os::raw::c_char,
    #[doc = " Options to be apllied to the filter.\n\n Filled by avfilter_graph_segment_parse(). Afterwards may be freely\n modified by the caller.\n\n Will be applied to the filter by avfilter_graph_segment_apply_opts()\n with an equivalent of av_opt_set_dict2(filter, &opts, AV_OPT_SEARCH_CHILDREN),\n i.e. any unapplied options will be left in this dictionary."]
    pub opts: *mut AVDictionary,
    pub inputs: *mut *mut AVFilterPadParams,
    pub nb_inputs: ::std::os::raw::c_uint,
    pub outputs: *mut *mut AVFilterPadParams,
    pub nb_outputs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterParams>(),
        64usize,
        concat!("Size of: ", stringify!(AVFilterParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(filter_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(instance_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(opts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_inputs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_outputs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterParams),
            "::",
            stringify!(nb_outputs)
        )
    );
}
#[doc = " A filterchain is a list of filter specifications.\n\n Created as a child of AVFilterGraphSegment by avfilter_graph_segment_parse().\n Freed in avfilter_graph_segment_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterChain {
    pub filters: *mut *mut AVFilterParams,
    pub nb_filters: usize,
}
#[test]
fn bindgen_test_layout_AVFilterChain() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterChain> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterChain>(),
        16usize,
        concat!("Size of: ", stringify!(AVFilterChain))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterChain>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterChain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterChain),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_filters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterChain),
            "::",
            stringify!(nb_filters)
        )
    );
}
#[doc = " A parsed representation of a filtergraph segment.\n\n A filtergraph segment is conceptually a list of filterchains, with some\n supplementary information (e.g. format conversion flags).\n\n Created by avfilter_graph_segment_parse(). Must be freed with\n avfilter_graph_segment_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphSegment {
    #[doc = " The filtergraph this segment is associated with.\n Set by avfilter_graph_segment_parse()."]
    pub graph: *mut AVFilterGraph,
    #[doc = " A list of filter chain contained in this segment.\n Set in avfilter_graph_segment_parse()."]
    pub chains: *mut *mut AVFilterChain,
    pub nb_chains: usize,
    #[doc = " A string containing a colon-separated list of key=value options applied\n to all scale filters in this segment.\n\n May be set by avfilter_graph_segment_parse().\n The caller may free this string with av_free() and replace it with a\n different av_malloc()'ed string."]
    pub scale_sws_opts: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVFilterGraphSegment() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilterGraphSegment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilterGraphSegment>(),
        32usize,
        concat!("Size of: ", stringify!(AVFilterGraphSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterGraphSegment>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterGraphSegment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraphSegment),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chains) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraphSegment),
            "::",
            stringify!(chains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_chains) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraphSegment),
            "::",
            stringify!(nb_chains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_sws_opts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraphSegment),
            "::",
            stringify!(scale_sws_opts)
        )
    );
}
extern "C" {
    #[doc = " Parse a textual filtergraph description into an intermediate form.\n\n This intermediate representation is intended to be modified by the caller as\n described in the documentation of AVFilterGraphSegment and its children, and\n then applied to the graph either manually or with other\n avfilter_graph_segment_*() functions. See the documentation for\n avfilter_graph_segment_apply() for the canonical way to apply\n AVFilterGraphSegment.\n\n @param graph Filter graph the parsed segment is associated with. Will only be\n              used for logging and similar auxiliary purposes. The graph will\n              not be actually modified by this function - the parsing results\n              are instead stored in seg for further processing.\n @param graph_str a string describing the filtergraph segment\n @param flags reserved for future use, caller must set to 0 for now\n @param seg A pointer to the newly-created AVFilterGraphSegment is written\n            here on success. The graph segment is owned by the caller and must\n            be freed with avfilter_graph_segment_free() before graph itself is\n            freed.\n\n @retval \"non-negative number\" success\n @retval \"negative error code\" failure"]
    pub fn avfilter_graph_segment_parse(
        graph: *mut AVFilterGraph,
        graph_str: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        seg: *mut *mut AVFilterGraphSegment,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create filters specified in a graph segment.\n\n Walk through the creation-pending AVFilterParams in the segment and create\n new filter instances for them.\n Creation-pending params are those where AVFilterParams.filter_name is\n non-NULL (and hence AVFilterParams.filter is NULL). All other AVFilterParams\n instances are ignored.\n\n For any filter created by this function, the corresponding\n AVFilterParams.filter is set to the newly-created filter context,\n AVFilterParams.filter_name and AVFilterParams.instance_name are freed and set\n to NULL.\n\n @param seg the filtergraph segment to process\n @param flags reserved for future use, caller must set to 0 for now\n\n @retval \"non-negative number\" Success, all creation-pending filters were\n                               successfully created\n @retval AVERROR_FILTER_NOT_FOUND some filter's name did not correspond to a\n                                  known filter\n @retval \"another negative error code\" other failures\n\n @note Calling this function multiple times is safe, as it is idempotent."]
    pub fn avfilter_graph_segment_create_filters(
        seg: *mut AVFilterGraphSegment,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply parsed options to filter instances in a graph segment.\n\n Walk through all filter instances in the graph segment that have option\n dictionaries associated with them and apply those options with\n av_opt_set_dict2(..., AV_OPT_SEARCH_CHILDREN). AVFilterParams.opts is\n replaced by the dictionary output by av_opt_set_dict2(), which should be\n empty (NULL) if all options were successfully applied.\n\n If any options could not be found, this function will continue processing all\n other filters and finally return AVERROR_OPTION_NOT_FOUND (unless another\n error happens). The calling program may then deal with unapplied options as\n it wishes.\n\n Any creation-pending filters (see avfilter_graph_segment_create_filters())\n present in the segment will cause this function to fail. AVFilterParams with\n no associated filter context are simply skipped.\n\n @param seg the filtergraph segment to process\n @param flags reserved for future use, caller must set to 0 for now\n\n @retval \"non-negative number\" Success, all options were successfully applied.\n @retval AVERROR_OPTION_NOT_FOUND some options were not found in a filter\n @retval \"another negative error code\" other failures\n\n @note Calling this function multiple times is safe, as it is idempotent."]
    pub fn avfilter_graph_segment_apply_opts(
        seg: *mut AVFilterGraphSegment,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize all filter instances in a graph segment.\n\n Walk through all filter instances in the graph segment and call\n avfilter_init_dict(..., NULL) on those that have not been initialized yet.\n\n Any creation-pending filters (see avfilter_graph_segment_create_filters())\n present in the segment will cause this function to fail. AVFilterParams with\n no associated filter context or whose filter context is already initialized,\n are simply skipped.\n\n @param seg the filtergraph segment to process\n @param flags reserved for future use, caller must set to 0 for now\n\n @retval \"non-negative number\" Success, all filter instances were successfully\n                               initialized\n @retval \"negative error code\" failure\n\n @note Calling this function multiple times is safe, as it is idempotent."]
    pub fn avfilter_graph_segment_init(
        seg: *mut AVFilterGraphSegment,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link filters in a graph segment.\n\n Walk through all filter instances in the graph segment and try to link all\n unlinked input and output pads. Any creation-pending filters (see\n avfilter_graph_segment_create_filters()) present in the segment will cause\n this function to fail. Disabled filters and already linked pads are skipped.\n\n Every filter output pad that has a corresponding AVFilterPadParams with a\n non-NULL label is\n - linked to the input with the matching label, if one exists;\n - exported in the outputs linked list otherwise, with the label preserved.\n Unlabeled outputs are\n - linked to the first unlinked unlabeled input in the next non-disabled\n   filter in the chain, if one exists\n - exported in the ouputs linked list otherwise, with NULL label\n\n Similarly, unlinked input pads are exported in the inputs linked list.\n\n @param seg the filtergraph segment to process\n @param flags reserved for future use, caller must set to 0 for now\n @param[out] inputs  a linked list of all free (unlinked) inputs of the\n                     filters in this graph segment will be returned here. It\n                     is to be freed by the caller using avfilter_inout_free().\n @param[out] outputs a linked list of all free (unlinked) outputs of the\n                     filters in this graph segment will be returned here. It\n                     is to be freed by the caller using avfilter_inout_free().\n\n @retval \"non-negative number\" success\n @retval \"negative error code\" failure\n\n @note Calling this function multiple times is safe, as it is idempotent."]
    pub fn avfilter_graph_segment_link(
        seg: *mut AVFilterGraphSegment,
        flags: ::std::os::raw::c_int,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply all filter/link descriptions from a graph segment to the associated filtergraph.\n\n This functions is currently equivalent to calling the following in sequence:\n - avfilter_graph_segment_create_filters();\n - avfilter_graph_segment_apply_opts();\n - avfilter_graph_segment_init();\n - avfilter_graph_segment_link();\n failing if any of them fails. This list may be extended in the future.\n\n Since the above functions are idempotent, the caller may call some of them\n manually, then do some custom processing on the filtergraph, then call this\n function to do the rest.\n\n @param seg the filtergraph segment to process\n @param flags reserved for future use, caller must set to 0 for now\n @param[out] inputs passed to avfilter_graph_segment_link()\n @param[out] outputs passed to avfilter_graph_segment_link()\n\n @retval \"non-negative number\" success\n @retval \"negative error code\" failure\n\n @note Calling this function multiple times is safe, as it is idempotent."]
    pub fn avfilter_graph_segment_apply(
        seg: *mut AVFilterGraphSegment,
        flags: ::std::os::raw::c_int,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the provided AVFilterGraphSegment and everything associated with it.\n\n @param seg double pointer to the AVFilterGraphSegment to be freed. NULL will\n be written to this pointer on exit from this function.\n\n @note\n The filter contexts (AVFilterParams.filter) are owned by AVFilterGraph rather\n than AVFilterGraphSegment, so they are not freed."]
    pub fn avfilter_graph_segment_free(seg: *mut *mut AVFilterGraphSegment);
}
extern "C" {
    #[doc = " Send a command to one or more filter instances.\n\n @param graph  the filter graph\n @param target the filter(s) to which the command should be sent\n               \"all\" sends to all filters\n               otherwise it can be a filter or filter instance name\n               which will send the command to all matching filters.\n @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only\n @param arg    the argument for the command\n @param res    a buffer with size res_size where the filter(s) can return a response.\n\n @returns >=0 on success otherwise an error code.\n              AVERROR(ENOSYS) on unsupported commands"]
    pub fn avfilter_graph_send_command(
        graph: *mut AVFilterGraph,
        target: *const ::std::os::raw::c_char,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_char,
        res_len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queue a command for one or more filter instances.\n\n @param graph  the filter graph\n @param target the filter(s) to which the command should be sent\n               \"all\" sends to all filters\n               otherwise it can be a filter or filter instance name\n               which will send the command to all matching filters.\n @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only\n @param arg    the argument for the command\n @param ts     time at which the command should be sent to the filter\n\n @note As this executes commands after this function returns, no return code\n       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported."]
    pub fn avfilter_graph_queue_command(
        graph: *mut AVFilterGraph,
        target: *const ::std::os::raw::c_char,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ts: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump a graph into a human-readable string representation.\n\n @param graph    the graph to dump\n @param options  formatting options; currently ignored\n @return  a string, or NULL in case of memory allocation failure;\n          the string must be freed using av_free"]
    pub fn avfilter_graph_dump(
        graph: *mut AVFilterGraph,
        options: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Request a frame on the oldest sink link.\n\n If the request returns AVERROR_EOF, try the next.\n\n Note that this function is not meant to be the sole scheduling mechanism\n of a filtergraph, only a convenience function to help drain a filtergraph\n in a balanced way under normal circumstances.\n\n Also note that AVERROR_EOF does not mean that frames did not arrive on\n some of the sinks during the process.\n When there are multiple sink links, in case the requested link\n returns an EOF, this may cause a filter to flush pending frames\n which are sent to another sink link, although unrequested.\n\n @return  the return value of ff_request_frame(),\n          or AVERROR_EOF if all links returned AVERROR_EOF"]
    pub fn avfilter_graph_request_oldest(graph: *mut AVFilterGraph) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a frame with filtered data from sink and put it in frame.\n\n @param ctx    pointer to a buffersink or abuffersink filter context.\n @param frame  pointer to an allocated frame that will be filled with data.\n               The data must be freed using av_frame_unref() / av_frame_free()\n @param flags  a combination of AV_BUFFERSINK_FLAG_* flags\n\n @return  >= 0 in for success, a negative AVERROR code for failure."]
    pub fn av_buffersink_get_frame_flags(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the frame size for an audio buffer sink.\n\n All calls to av_buffersink_get_buffer_ref will return a buffer with\n exactly the specified number of samples, or AVERROR(EAGAIN) if there is\n not enough. The last buffer at EOF will be padded with 0."]
    pub fn av_buffersink_set_frame_size(
        ctx: *mut AVFilterContext,
        frame_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @defgroup lavfi_buffersink_accessors Buffer sink accessors\n Get the properties of the stream\n @{"]
    pub fn av_buffersink_get_type(ctx: *const AVFilterContext) -> AVMediaType;
}
extern "C" {
    pub fn av_buffersink_get_time_base(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_format(ctx: *const AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_frame_rate(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_w(ctx: *const AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_h(ctx: *const AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_aspect_ratio(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_channels(ctx: *const AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_channel_layout(ctx: *const AVFilterContext) -> u64;
}
extern "C" {
    pub fn av_buffersink_get_ch_layout(
        ctx: *const AVFilterContext,
        ch_layout: *mut AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_rate(ctx: *const AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffersink_get_hw_frames_ctx(ctx: *const AVFilterContext) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Get a frame with filtered data from sink and put it in frame.\n\n @param ctx pointer to a context of a buffersink or abuffersink AVFilter.\n @param frame pointer to an allocated frame that will be filled with data.\n              The data must be freed using av_frame_unref() / av_frame_free()\n\n @return\n         - >= 0 if a frame was successfully returned.\n         - AVERROR(EAGAIN) if no frames are available at this point; more\n           input frames must be added to the filtergraph to get more output.\n         - AVERROR_EOF if there will be no more output frames on this sink.\n         - A different negative AVERROR code in other failure cases."]
    pub fn av_buffersink_get_frame(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as av_buffersink_get_frame(), but with the ability to specify the number\n of samples read. This function is less efficient than\n av_buffersink_get_frame(), because it copies the data around.\n\n @param ctx pointer to a context of the abuffersink AVFilter.\n @param frame pointer to an allocated frame that will be filled with data.\n              The data must be freed using av_frame_unref() / av_frame_free()\n              frame will contain exactly nb_samples audio samples, except at\n              the end of stream, when it can contain less than nb_samples.\n\n @return The return codes have the same meaning as for\n         av_buffersink_get_frame().\n\n @warning do not mix this function with av_buffersink_get_frame(). Use only one or\n the other with a single sink, not both."]
    pub fn av_buffersink_get_samples(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Do not check for format changes."]
pub const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT: _bindgen_ty_7 = 1;
#[doc = " Immediately push the frame to the output."]
pub const AV_BUFFERSRC_FLAG_PUSH: _bindgen_ty_7 = 4;
#[doc = " Keep a reference to the frame.\n If the frame if reference-counted, create a new reference; otherwise\n copy the frame data."]
pub const AV_BUFFERSRC_FLAG_KEEP_REF: _bindgen_ty_7 = 8;
#[doc = " @defgroup lavfi_buffersrc Buffer source API\n @ingroup lavfi\n @{"]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the number of failed requests.\n\n A failed request is when the request_frame method is called while no\n frame is present in the buffer.\n The number is reset when a frame is added."]
    pub fn av_buffersrc_get_nb_failed_requests(
        buffer_src: *mut AVFilterContext,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " This structure contains the parameters describing the frames that will be\n passed to this filter.\n\n It should be allocated with av_buffersrc_parameters_alloc() and freed with\n av_free(). All the allocated fields in it remain owned by the caller."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVBufferSrcParameters {
    #[doc = " video: the pixel format, value corresponds to enum AVPixelFormat\n audio: the sample format, value corresponds to enum AVSampleFormat"]
    pub format: ::std::os::raw::c_int,
    #[doc = " The timebase to be used for the timestamps on the input frames."]
    pub time_base: AVRational,
    #[doc = " Video only, the display dimensions of the input frames."]
    pub width: ::std::os::raw::c_int,
    #[doc = " Video only, the display dimensions of the input frames."]
    pub height: ::std::os::raw::c_int,
    #[doc = " Video only, the sample (pixel) aspect ratio."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only, the frame rate of the input video. This field must only be\n set to a non-zero value if input stream has a known constant framerate\n and should be left at its initial value if the framerate is variable or\n unknown."]
    pub frame_rate: AVRational,
    #[doc = " Video with a hwaccel pixel format only. This should be a reference to an\n AVHWFramesContext instance describing the input frames."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Audio only, the audio sampling rate in samples per second."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Audio only, the audio channel layout\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Audio only, the audio channel layout"]
    pub ch_layout: AVChannelLayout,
}
#[test]
fn bindgen_test_layout_AVBufferSrcParameters() {
    const UNINIT: ::std::mem::MaybeUninit<AVBufferSrcParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBufferSrcParameters>(),
        88usize,
        concat!("Size of: ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferSrcParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_base) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_aspect_ratio) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_frames_ctx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch_layout) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(ch_layout)
        )
    );
}
impl ::std::fmt::Debug for AVBufferSrcParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "AVBufferSrcParameters {{ format: {:?}, time_base: {:?}, width: {:?}, height: {:?}, sample_aspect_ratio: {:?}, frame_rate: {:?}, hw_frames_ctx: {:?}, sample_rate: {:?}, channel_layout: {:?}, ch_layout: {:?} }}" , self . format , self . time_base , self . width , self . height , self . sample_aspect_ratio , self . frame_rate , self . hw_frames_ctx , self . sample_rate , self . channel_layout , self . ch_layout)
    }
}
extern "C" {
    #[doc = " Allocate a new AVBufferSrcParameters instance. It should be freed by the\n caller with av_free()."]
    pub fn av_buffersrc_parameters_alloc() -> *mut AVBufferSrcParameters;
}
extern "C" {
    #[doc = " Initialize the buffersrc or abuffersrc filter with the provided parameters.\n This function may be called multiple times, the later calls override the\n previous ones. Some of the parameters may also be set through AVOptions, then\n whatever method is used last takes precedence.\n\n @param ctx an instance of the buffersrc or abuffersrc filter\n @param param the stream parameters. The frames later passed to this filter\n              must conform to those parameters. All the allocated fields in\n              param remain owned by the caller, libavfilter will make internal\n              copies or references when necessary.\n @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_buffersrc_parameters_set(
        ctx: *mut AVFilterContext,
        param: *mut AVBufferSrcParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source.\n\n @param ctx   an instance of the buffersrc filter\n @param frame frame to be added. If the frame is reference counted, this\n function will make a new reference to it. Otherwise the frame data will be\n copied.\n\n @return 0 on success, a negative AVERROR on error\n\n This function is equivalent to av_buffersrc_add_frame_flags() with the\n AV_BUFFERSRC_FLAG_KEEP_REF flag."]
    pub fn av_buffersrc_write_frame(
        ctx: *mut AVFilterContext,
        frame: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source.\n\n @param ctx   an instance of the buffersrc filter\n @param frame frame to be added. If the frame is reference counted, this\n function will take ownership of the reference(s) and reset the frame.\n Otherwise the frame data will be copied. If this function returns an error,\n the input frame is not touched.\n\n @return 0 on success, a negative AVERROR on error.\n\n @note the difference between this function and av_buffersrc_write_frame() is\n that av_buffersrc_write_frame() creates a new reference to the input frame,\n while this function takes ownership of the reference passed to it.\n\n This function is equivalent to av_buffersrc_add_frame_flags() without the\n AV_BUFFERSRC_FLAG_KEEP_REF flag."]
    pub fn av_buffersrc_add_frame(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a frame to the buffer source.\n\n By default, if the frame is reference-counted, this function will take\n ownership of the reference(s) and reset the frame. This can be controlled\n using the flags.\n\n If this function returns an error, the input frame is not touched.\n\n @param buffer_src  pointer to a buffer source context\n @param frame       a frame, or NULL to mark EOF\n @param flags       a combination of AV_BUFFERSRC_FLAG_*\n @return            >= 0 in case of success, a negative AVERROR code\n                    in case of failure"]
    pub fn av_buffersrc_add_frame_flags(
        buffer_src: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the buffer source after EOF.\n\n This is similar to passing NULL to av_buffersrc_add_frame_flags()\n except it takes the timestamp of the EOF, i.e. the timestamp of the end\n of the last frame."]
    pub fn av_buffersrc_close(
        ctx: *mut AVFilterContext,
        pts: i64,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @defgroup lavu_adler32 Adler-32\n @ingroup lavu_hash\n Adler-32 hash function implementation.\n\n @{"]
pub type AVAdler = u32;
extern "C" {
    #[doc = " Calculate the Adler32 checksum of a buffer.\n\n Passing the return value to a subsequent av_adler32_update() call\n allows the checksum of multiple buffers to be calculated as though\n they were concatenated.\n\n @param adler initial checksum value\n @param buf   pointer to input buffer\n @param len   size of input buffer\n @return      updated checksum"]
    pub fn av_adler32_update(adler: AVAdler, buf: *const u8, len: usize) -> AVAdler;
}
extern "C" {
    #[doc = " @defgroup lavu_aes AES\n @ingroup lavu_crypto\n @{"]
    pub static av_aes_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAES {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVAES context."]
    pub fn av_aes_alloc() -> *mut AVAES;
}
extern "C" {
    #[doc = " Initialize an AVAES context.\n\n @param a The AVAES context\n @param key Pointer to the key\n @param key_bits 128, 192 or 256\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_init(
        a: *mut AVAES,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
        decrypt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param a The AVAES context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 16 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_aes_crypt(
        a: *mut AVAES,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAESCTR {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVAESCTR context."]
    pub fn av_aes_ctr_alloc() -> *mut AVAESCTR;
}
extern "C" {
    #[doc = " Initialize an AVAESCTR context.\n\n @param a The AVAESCTR context to initialize\n @param key encryption key, must have a length of AES_CTR_KEY_SIZE"]
    pub fn av_aes_ctr_init(a: *mut AVAESCTR, key: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release an AVAESCTR context.\n\n @param a The AVAESCTR context"]
    pub fn av_aes_ctr_free(a: *mut AVAESCTR);
}
extern "C" {
    #[doc = " Process a buffer using a previously initialized context.\n\n @param a The AVAESCTR context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param size the size of src and dst"]
    pub fn av_aes_ctr_crypt(
        a: *mut AVAESCTR,
        dst: *mut u8,
        src: *const u8,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the current iv"]
    pub fn av_aes_ctr_get_iv(a: *mut AVAESCTR) -> *const u8;
}
extern "C" {
    #[doc = " Generate a random iv"]
    pub fn av_aes_ctr_set_random_iv(a: *mut AVAESCTR);
}
extern "C" {
    #[doc = " Forcefully change the 8-byte iv"]
    pub fn av_aes_ctr_set_iv(a: *mut AVAESCTR, iv: *const u8);
}
extern "C" {
    #[doc = " Forcefully change the \"full\" 16-byte iv, including the counter"]
    pub fn av_aes_ctr_set_full_iv(a: *mut AVAESCTR, iv: *const u8);
}
extern "C" {
    #[doc = " Increment the top 64 bit of the iv (performed after each frame)"]
    pub fn av_aes_ctr_increment_iv(a: *mut AVAESCTR);
}
#[doc = " Ambient viewing environment metadata as defined by H.274. The values are\n saved in AVRationals so that they keep their exactness, while allowing for\n easy access to a double value with f.ex. av_q2d.\n\n @note sizeof(AVAmbientViewingEnvironment) is not part of the public ABI, and\n       it must be allocated using av_ambient_viewing_environment_alloc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAmbientViewingEnvironment {
    #[doc = " Environmental illuminance of the ambient viewing environment in lux."]
    pub ambient_illuminance: AVRational,
    #[doc = " Normalized x chromaticity coordinate of the environmental ambient light\n in the nominal viewing environment according to the CIE 1931 definition\n of x and y as specified in ISO/CIE 11664-1."]
    pub ambient_light_x: AVRational,
    #[doc = " Normalized y chromaticity coordinate of the environmental ambient light\n in the nominal viewing environment according to the CIE 1931 definition\n of x and y as specified in ISO/CIE 11664-1."]
    pub ambient_light_y: AVRational,
}
#[test]
fn bindgen_test_layout_AVAmbientViewingEnvironment() {
    const UNINIT: ::std::mem::MaybeUninit<AVAmbientViewingEnvironment> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVAmbientViewingEnvironment>(),
        24usize,
        concat!("Size of: ", stringify!(AVAmbientViewingEnvironment))
    );
    assert_eq!(
        ::std::mem::align_of::<AVAmbientViewingEnvironment>(),
        4usize,
        concat!("Alignment of ", stringify!(AVAmbientViewingEnvironment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ambient_illuminance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVAmbientViewingEnvironment),
            "::",
            stringify!(ambient_illuminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ambient_light_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVAmbientViewingEnvironment),
            "::",
            stringify!(ambient_light_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ambient_light_y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVAmbientViewingEnvironment),
            "::",
            stringify!(ambient_light_y)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVAmbientViewingEnvironment structure.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_ambient_viewing_environment_alloc(
        size: *mut usize,
    ) -> *mut AVAmbientViewingEnvironment;
}
extern "C" {
    #[doc = " Allocate and add an AVAmbientViewingEnvironment structure to an existing\n AVFrame as side data.\n\n @return the newly allocated struct, or NULL on failure"]
    pub fn av_ambient_viewing_environment_create_side_data(
        frame: *mut AVFrame,
    ) -> *mut AVAmbientViewingEnvironment;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAudioFifo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Free an AVAudioFifo.\n\n @param af  AVAudioFifo to free"]
    pub fn av_audio_fifo_free(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Allocate an AVAudioFifo.\n\n @param sample_fmt  sample format\n @param channels    number of channels\n @param nb_samples  initial allocation size, in samples\n @return            newly allocated AVAudioFifo, or NULL on error"]
    pub fn av_audio_fifo_alloc(
        sample_fmt: AVSampleFormat,
        channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
    ) -> *mut AVAudioFifo;
}
extern "C" {
    #[doc = " Reallocate an AVAudioFifo.\n\n @param af          AVAudioFifo to reallocate\n @param nb_samples  new allocation size, in samples\n @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_realloc(
        af: *mut AVAudioFifo,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write data to an AVAudioFifo.\n\n The AVAudioFifo will be reallocated automatically if the available space\n is less than nb_samples.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to write to\n @param data        audio data plane pointers\n @param nb_samples  number of samples to write\n @return            number of samples actually written, or negative AVERROR\n                    code on failure. If successful, the number of samples\n                    actually written will always be nb_samples."]
    pub fn av_audio_fifo_write(
        af: *mut AVAudioFifo,
        data: *const *mut ::std::os::raw::c_void,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to peek\n @return            number of samples actually peek, or negative AVERROR code\n                    on failure. The number of samples actually peek will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek(
        af: *const AVAudioFifo,
        data: *const *mut ::std::os::raw::c_void,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Peek data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to peek\n @param offset      offset from current read position\n @return            number of samples actually peek, or negative AVERROR code\n                    on failure. The number of samples actually peek will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_peek_at(
        af: *const AVAudioFifo,
        data: *const *mut ::std::os::raw::c_void,
        nb_samples: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data from an AVAudioFifo.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param af          AVAudioFifo to read from\n @param data        audio data plane pointers\n @param nb_samples  number of samples to read\n @return            number of samples actually read, or negative AVERROR code\n                    on failure. The number of samples actually read will not\n                    be greater than nb_samples, and will only be less than\n                    nb_samples if av_audio_fifo_size is less than nb_samples."]
    pub fn av_audio_fifo_read(
        af: *mut AVAudioFifo,
        data: *const *mut ::std::os::raw::c_void,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Drain data from an AVAudioFifo.\n\n Removes the data without reading it.\n\n @param af          AVAudioFifo to drain\n @param nb_samples  number of samples to drain\n @return            0 if OK, or negative AVERROR code on failure"]
    pub fn av_audio_fifo_drain(
        af: *mut AVAudioFifo,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the AVAudioFifo buffer.\n\n This empties all data in the buffer.\n\n @param af  AVAudioFifo to reset"]
    pub fn av_audio_fifo_reset(af: *mut AVAudioFifo);
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for reading.\n\n @param af  the AVAudioFifo to query\n @return    number of samples available for reading"]
    pub fn av_audio_fifo_size(af: *mut AVAudioFifo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current number of samples in the AVAudioFifo available for writing.\n\n @param af  the AVAudioFifo to query\n @return    number of samples available for writing"]
    pub fn av_audio_fifo_space(af: *mut AVAudioFifo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Assert that floating point operations can be executed.\n\n This will av_assert0() that the cpu is not in MMX state on X86"]
    pub fn av_assert0_fpu();
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str. If it is, *ptr is set to\n the address of the first character in str after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_strstart(
        str_: *const ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str independent of case. If\n it is, *ptr is set to the address of the first character in str\n after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_stristart(
        str_: *const ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Locate the first case-independent occurrence in the string haystack\n of the string needle.  A zero-length string needle is considered to\n match at the start of haystack.\n\n This function is a case-insensitive version of the standard strstr().\n\n @param haystack string to search in\n @param needle   string to search for\n @return         pointer to the located match within haystack\n                 or a null pointer if no match"]
    pub fn av_stristr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Locate the first occurrence of the string needle in the string haystack\n where not more than hay_length characters are searched. A zero-length\n string needle is considered to match at the start of haystack.\n\n This function is a length-limited version of the standard strstr().\n\n @param haystack   string to search in\n @param needle     string to search for\n @param hay_length length of string to search in\n @return           pointer to the located match within haystack\n                   or a null pointer if no match"]
    pub fn av_strnstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
        hay_length: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy the string src to dst, but no more than size - 1 bytes, and\n null-terminate dst.\n\n This function is the same as BSD strlcpy().\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the length of src\n\n @warning since the return value is the length of src, src absolutely\n _must_ be a properly 0-terminated string, otherwise this will read beyond\n the end of the buffer and possibly crash."]
    pub fn av_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Append the string src to the string dst, but to a total length of\n no more than size - 1 bytes, and null-terminate dst.\n\n This function is similar to BSD strlcat(), but differs when\n size <= strlen(dst).\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the total length of src and dst\n\n @warning since the return value use the length of src and dst, these\n absolutely _must_ be a properly 0-terminated strings, otherwise this\n will read beyond the end of the buffer and possibly crash."]
    pub fn av_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Append output to a string, according to a format. Never write out of\n the destination buffer, and always put a terminating 0 within\n the buffer.\n @param dst destination buffer (string to which the output is\n  appended)\n @param size total size of the destination buffer\n @param fmt printf-compatible format string, specifying how the\n  following parameters are used\n @return the length of the string that would have been generated\n  if enough space had been available"]
    pub fn av_strlcatf(
        dst: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> usize;
}
extern "C" {
    #[doc = " Print arguments following specified format into a large enough auto\n allocated buffer. It is similar to GNU asprintf().\n @param fmt printf-compatible format string, specifying how the\n            following parameters are used.\n @return the allocated string\n @note You have to free the string yourself with av_free()."]
    pub fn av_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Unescape the given string until a non escaped terminating char,\n and return the token corresponding to the unescaped string.\n\n The normal \\ and ' escaping is supported. Leading and trailing\n whitespaces are removed, unless they are escaped with '\\' or are\n enclosed between ''.\n\n @param buf the buffer to parse, buf will be updated to point to the\n terminating char\n @param term a 0-terminated list of terminating chars\n @return the malloced unescaped string, which must be av_freed by\n the user, NULL in case of allocation failure"]
    pub fn av_get_token(
        buf: *mut *const ::std::os::raw::c_char,
        term: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Split the string into several tokens which can be accessed by\n successive calls to av_strtok().\n\n A token is defined as a sequence of characters not belonging to the\n set specified in delim.\n\n On the first call to av_strtok(), s should point to the string to\n parse, and the value of saveptr is ignored. In subsequent calls, s\n should be NULL, and saveptr should be unchanged since the previous\n call.\n\n This function is similar to strtok_r() defined in POSIX.1.\n\n @param s the string to parse, may be NULL\n @param delim 0-terminated list of token delimiters, must be non-NULL\n @param saveptr user-provided pointer which points to stored\n information necessary for av_strtok() to continue scanning the same\n string. saveptr is updated to point to the next character after the\n first delimiter found, or to NULL if the string was terminated\n @return the found token, or NULL when no token is found"]
    pub fn av_strtok(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        saveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strcasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strncasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Locale-independent strings replace.\n @note This means only ASCII-range characters are replaced."]
    pub fn av_strireplace(
        str_: *const ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Thread safe basename.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return pointer to the basename substring.\n If path does not contain a slash, the function returns a copy of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned."]
    pub fn av_basename(path: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Thread safe dirname.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return A pointer to a string that's the parent directory of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned.\n @note the function may modify the contents of the path, so copies should be passed."]
    pub fn av_dirname(path: *mut ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Match instances of a name in a comma-separated list of names.\n List entries are checked from the start to the end of the names list,\n the first match ends further processing. If an entry prefixed with '-'\n matches, then 0 is returned. The \"ALL\" list entry is considered to\n match all names.\n\n @param name  Name to look for.\n @param names List of names.\n @return 1 on match, 0 otherwise."]
    pub fn av_match_name(
        name: *const ::std::os::raw::c_char,
        names: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append path component to the existing path.\n Path separator '/' is placed between when needed.\n Resulting string have to be freed with av_free().\n @param path      base path\n @param component component to be appended\n @return new path or NULL on error."]
    pub fn av_append_path_component(
        path: *const ::std::os::raw::c_char,
        component: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = "< Use auto-selected escaping mode."]
pub const AV_ESCAPE_MODE_AUTO: AVEscapeMode = 0;
#[doc = "< Use backslash escaping."]
pub const AV_ESCAPE_MODE_BACKSLASH: AVEscapeMode = 1;
#[doc = "< Use single-quote escaping."]
pub const AV_ESCAPE_MODE_QUOTE: AVEscapeMode = 2;
#[doc = "< Use XML non-markup character data escaping."]
pub const AV_ESCAPE_MODE_XML: AVEscapeMode = 3;
pub type AVEscapeMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Escape string in src, and put the escaped string in an allocated\n string in *dst, which must be freed with av_free().\n\n @param dst           pointer where an allocated string is put\n @param src           string to escape, must be non-NULL\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros\n @return the length of the allocated string, or a negative error code in case of error\n @see av_bprint_escape()"]
    pub fn av_escape(
        dst: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        special_chars: *const ::std::os::raw::c_char,
        mode: AVEscapeMode,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read and decode a single UTF-8 code point (character) from the\n buffer in *buf, and update *buf to point to the next byte to\n decode.\n\n In case of an invalid byte sequence, the pointer will be updated to\n the next byte after the invalid sequence and the function will\n return an error code.\n\n Depending on the specified flags, the function will also fail in\n case the decoded code point does not belong to a valid range.\n\n @note For speed-relevant code a carefully implemented use of\n GET_UTF8() may be preferred.\n\n @param codep   pointer used to return the parsed code in case of success.\n                The value in *codep is set even in case the range check fails.\n @param bufp    pointer to the address the first byte of the sequence\n                to decode, updated by the function to point to the\n                byte next after the decoded sequence\n @param buf_end pointer to the end of the buffer, points to the next\n                byte past the last in the buffer. This is used to\n                avoid buffer overreads (in case of an unfinished\n                UTF-8 sequence towards the end of the buffer).\n @param flags   a collection of AV_UTF8_FLAG_* flags\n @return >= 0 in case a sequence was successfully read, a negative\n value in case of invalid sequence"]
    pub fn av_utf8_decode(
        codep: *mut i32,
        bufp: *mut *const u8,
        buf_end: *const u8,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a name is in a list.\n @returns 0 if not found, or the 1 based index where it has been found in the\n            list."]
    pub fn av_match_list(
        name: *const ::std::os::raw::c_char,
        list: *const ::std::os::raw::c_char,
        separator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " See libc sscanf manual for more information.\n Locale-independent sscanf implementation."]
    pub fn av_sscanf(
        string: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a base64-encoded string.\n\n @param out      buffer for decoded data\n @param in       null-terminated input string\n @param out_size size in bytes of the out buffer, must be at\n                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))\n @return         number of bytes written, or a negative value in case of\n                 invalid input"]
    pub fn av_base64_decode(
        out: *mut u8,
        in_: *const ::std::os::raw::c_char,
        out_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode data to base64 and null-terminate.\n\n @param out      buffer for encoded data\n @param out_size size in bytes of the out buffer (including the\n                 null terminator), must be at least AV_BASE64_SIZE(in_size)\n @param in       input buffer containing the data to encode\n @param in_size  size in bytes of the in buffer\n @return         out or NULL in case of error"]
    pub fn av_base64_encode(
        out: *mut ::std::os::raw::c_char,
        out_size: ::std::os::raw::c_int,
        in_: *const u8,
        in_size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBlowfish {
    pub p: [u32; 18usize],
    pub s: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_AVBlowfish() {
    const UNINIT: ::std::mem::MaybeUninit<AVBlowfish> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBlowfish>(),
        4168usize,
        concat!("Size of: ", stringify!(AVBlowfish))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBlowfish>(),
        4usize,
        concat!("Alignment of ", stringify!(AVBlowfish))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVBlowfish context."]
    pub fn av_blowfish_alloc() -> *mut AVBlowfish;
}
extern "C" {
    #[doc = " Initialize an AVBlowfish context.\n\n @param ctx an AVBlowfish context\n @param key a key\n @param key_len length of the key"]
    pub fn av_blowfish_init(ctx: *mut AVBlowfish, key: *const u8, key_len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param ctx an AVBlowfish context\n @param xl left four bytes halves of input to be encrypted\n @param xr right four bytes halves of input to be encrypted\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt_ecb(
        ctx: *mut AVBlowfish,
        xl: *mut u32,
        xr: *mut u32,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param ctx an AVBlowfish context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_blowfish_crypt(
        ctx: *mut AVBlowfish,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ff_pad_helper_AVBPrint {
    pub str_: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub size_max: ::std::os::raw::c_uint,
    pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_ff_pad_helper_AVBPrint() {
    const UNINIT: ::std::mem::MaybeUninit<ff_pad_helper_AVBPrint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ff_pad_helper_AVBPrint>(),
        24usize,
        concat!("Size of: ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<ff_pad_helper_AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_internal_buffer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
}
#[doc = " Buffer to print data progressively\n\n The string buffer grows as necessary and is always 0-terminated.\n The content of the string is never accessed, and thus is\n encoding-agnostic and can even hold binary data.\n\n Small buffers are kept in the structure itself, and thus require no\n memory allocation at all (unless the contents of the buffer is needed\n after the structure goes out of scope). This is almost as lightweight as\n declaring a local `char buf[512]`.\n\n The length of the string can go beyond the allocated size: the buffer is\n then truncated, but the functions still keep account of the actual total\n length.\n\n In other words, AVBPrint.len can be greater than AVBPrint.size and records\n the total length of what would have been to the buffer if there had been\n enough memory.\n\n Append operations do not need to be tested for failure: if a memory\n allocation fails, data stop being appended to the buffer, but the length\n is still updated. This situation can be tested with\n av_bprint_is_complete().\n\n The AVBPrint.size_max field determines several possible behaviours:\n - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be\n   reallocated as necessary, with an amortized linear cost.\n - `size_max = 0` prevents writing anything to the buffer: only the total\n   length is computed. The write operations can then possibly be repeated in\n   a buffer with exactly the necessary size\n   (using `size_init = size_max = len + 1`).\n - `size_max = 1` is automatically replaced by the exact size available in the\n   structure itself, thus ensuring no dynamic memory allocation. The\n   internal buffer is large enough to hold a reasonable paragraph of text,\n   such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    pub str_: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub size_max: ::std::os::raw::c_uint,
    pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
    pub reserved_padding: [::std::os::raw::c_char; 1000usize],
}
#[test]
fn bindgen_test_layout_AVBPrint() {
    const UNINIT: ::std::mem::MaybeUninit<AVBPrint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVBPrint>(),
        1024usize,
        concat!("Size of: ", stringify!(AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBPrint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_internal_buffer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_padding) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_padding)
        )
    );
}
extern "C" {
    #[doc = " Init a print buffer.\n\n @param buf        buffer to init\n @param size_init  initial size (including the final 0)\n @param size_max   maximum size;\n                   - `0` means do not write anything, just count the length\n                   - `1` is replaced by the maximum value for automatic storage\n                       any large value means that the internal buffer will be\n                       reallocated as needed up to that limit\n                   - `-1` is converted to `UINT_MAX`, the largest limit possible.\n                   Check also `AV_BPRINT_SIZE_*` macros."]
    pub fn av_bprint_init(
        buf: *mut AVBPrint,
        size_init: ::std::os::raw::c_uint,
        size_max: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Init a print buffer using a pre-existing buffer.\n\n The buffer will not be reallocated.\n In case size equals zero, the AVBPrint will be initialized to use\n the internal buffer as if using AV_BPRINT_SIZE_COUNT_ONLY with\n av_bprint_init().\n\n @param buf     buffer structure to init\n @param buffer  byte buffer to use for the string data\n @param size    size of buffer"]
    pub fn av_bprint_init_for_buffer(
        buf: *mut AVBPrint,
        buffer: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_bprintf(buf: *mut AVBPrint, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_vbprintf(
        buf: *mut AVBPrint,
        fmt: *const ::std::os::raw::c_char,
        vl_arg: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Append char c n times to a print buffer."]
    pub fn av_bprint_chars(
        buf: *mut AVBPrint,
        c: ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Append data to a print buffer.\n\n param buf  bprint buffer to use\n param data pointer to data\n param size size of data"]
    pub fn av_bprint_append_data(
        buf: *mut AVBPrint,
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Append a formatted date and time to a print buffer.\n\n param buf  bprint buffer to use\n param fmt  date and time format string, see strftime()\n param tm   broken-down time structure to translate\n\n @note due to poor design of the standard strftime function, it may\n produce poor results if the format string expands to a very long text and\n the bprint buffer is near the limit stated by the size_max option."]
    pub fn av_bprint_strftime(
        buf: *mut AVBPrint,
        fmt: *const ::std::os::raw::c_char,
        tm: *const tm,
    );
}
extern "C" {
    #[doc = " Allocate bytes in the buffer for external use.\n\n @param[in]  buf          buffer structure\n @param[in]  size         required size\n @param[out] mem          pointer to the memory area\n @param[out] actual_size  size of the memory area after allocation;\n                          can be larger or smaller than size"]
    pub fn av_bprint_get_buffer(
        buf: *mut AVBPrint,
        size: ::std::os::raw::c_uint,
        mem: *mut *mut ::std::os::raw::c_uchar,
        actual_size: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Reset the string to \"\" but keep internal allocated data."]
    pub fn av_bprint_clear(buf: *mut AVBPrint);
}
extern "C" {
    #[doc = " Finalize a print buffer.\n\n The print buffer can no longer be used afterwards,\n but the len and size fields are still valid.\n\n @arg[out] ret_str  if not NULL, used to return a permanent copy of the\n                    buffer contents, or NULL if memory allocation fails;\n                    if NULL, the buffer is discarded and freed\n @return  0 for success or error code (probably AVERROR(ENOMEM))"]
    pub fn av_bprint_finalize(
        buf: *mut AVBPrint,
        ret_str: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Escape the content in src and append it to dstbuf.\n\n @param dstbuf        already inited destination bprint buffer\n @param src           string containing the text to escape\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros"]
    pub fn av_bprint_escape(
        dstbuf: *mut AVBPrint,
        src: *const ::std::os::raw::c_char,
        special_chars: *const ::std::os::raw::c_char,
        mode: AVEscapeMode,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil CAMELLIA algorithm\n @defgroup lavu_camellia CAMELLIA\n @ingroup lavu_crypto\n @{"]
    pub static av_camellia_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAMELLIA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAMELLIA context\n To free the struct: av_free(ptr)"]
    pub fn av_camellia_alloc() -> *mut AVCAMELLIA;
}
extern "C" {
    #[doc = " Initialize an AVCAMELLIA context.\n\n @param ctx an AVCAMELLIA context\n @param key a key of 16, 24, 32 bytes used for encryption/decryption\n @param key_bits number of keybits: possible are 128, 192, 256"]
    pub fn av_camellia_init(
        ctx: *mut AVCAMELLIA,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVCAMELLIA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 16 byte blocks\n @param iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_camellia_crypt(
        ctx: *mut AVCAMELLIA,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil CAST5 algorithm\n @defgroup lavu_cast5 CAST5\n @ingroup lavu_crypto\n @{"]
    pub static av_cast5_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAST5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVCAST5 context\n To free the struct: av_free(ptr)"]
    pub fn av_cast5_alloc() -> *mut AVCAST5;
}
extern "C" {
    #[doc = " Initialize an AVCAST5 context.\n\n @param ctx an AVCAST5 context\n @param key a key of 5,6,...16 bytes used for encryption/decryption\n @param key_bits number of keybits: possible are 40,48,...,128\n @return 0 on success, less than 0 on failure"]
    pub fn av_cast5_init(
        ctx: *mut AVCAST5,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context, ECB mode only\n\n @param ctx an AVCAST5 context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVCAST5 context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_cast5_crypt2(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return the flags which specify extensions supported by the CPU.\n The returned value is affected by av_force_cpu_flags() if that was used\n before. So av_get_cpu_flags() can easily be used in an application to\n detect the enabled cpu flags."]
    pub fn av_get_cpu_flags() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disables cpu detection and forces the specified flags.\n -1 is a special case that disables forcing of specific flags."]
    pub fn av_force_cpu_flags(flags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Parse CPU caps from a string and update the given AV_CPU_* flags based on that.\n\n @return negative on error."]
    pub fn av_parse_cpu_caps(
        flags: *mut ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the number of logical CPU cores present."]
    pub fn av_cpu_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overrides cpu count detection and forces the specified count.\n Count < 1 disables forcing of specific count."]
    pub fn av_cpu_force_count(count: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the maximum data alignment that may be required by FFmpeg.\n\n Note that this is affected by the build configuration and the CPU flags mask,\n so e.g. if the CPU supports AVX, but libavutil has been built with\n --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through\n  av_set_cpu_flags_mask(), then this function will behave as if AVX is not\n  present."]
    pub fn av_cpu_max_align() -> usize;
}
#[doc = " @defgroup lavu_crc32 CRC\n @ingroup lavu_hash\n CRC (Cyclic Redundancy Check) hash function implementation.\n\n This module supports numerous CRC polynomials, in addition to the most\n widely used CRC-32-IEEE. See @ref AVCRCId for a list of available\n polynomials.\n\n @{"]
pub type AVCRC = u32;
pub const AV_CRC_8_ATM: AVCRCId = 0;
pub const AV_CRC_16_ANSI: AVCRCId = 1;
pub const AV_CRC_16_CCITT: AVCRCId = 2;
pub const AV_CRC_32_IEEE: AVCRCId = 3;
pub const AV_CRC_32_IEEE_LE: AVCRCId = 4;
pub const AV_CRC_16_ANSI_LE: AVCRCId = 5;
pub const AV_CRC_24_IEEE: AVCRCId = 6;
pub const AV_CRC_8_EBU: AVCRCId = 7;
pub const AV_CRC_MAX: AVCRCId = 8;
pub type AVCRCId = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Initialize a CRC table.\n @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024\n @param le If 1, the lowest bit represents the coefficient for the highest\n           exponent of the corresponding polynomial (both for poly and\n           actual CRC).\n           If 0, you must swap the CRC parameter and the result of av_crc\n           if you need the standard representation (can be simplified in\n           most cases to e.g. bswap16):\n           av_bswap32(crc << (32-bits))\n @param bits number of bits for the CRC\n @param poly generator polynomial without the x**bits coefficient, in the\n             representation as specified by le\n @param ctx_size size of ctx in bytes\n @return <0 on failure"]
    pub fn av_crc_init(
        ctx: *mut AVCRC,
        le: ::std::os::raw::c_int,
        bits: ::std::os::raw::c_int,
        poly: u32,
        ctx_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an initialized standard CRC table.\n @param crc_id ID of a standard CRC\n @return a pointer to the CRC table or NULL on failure"]
    pub fn av_crc_get_table(crc_id: AVCRCId) -> *const AVCRC;
}
extern "C" {
    #[doc = " Calculate the CRC of a block.\n @param ctx initialized AVCRC array (see av_crc_init())\n @param crc CRC of previous blocks if any or initial value for CRC\n @param buffer buffer whose CRC to calculate\n @param length length of the buffer\n @return CRC updated with the data from the given block\n\n @see av_crc_init() \"le\" parameter"]
    pub fn av_crc(ctx: *const AVCRC, crc: u32, buffer: *const u8, length: usize) -> u32;
}
#[doc = " Struct containing luma coefficients to be used for RGB to YUV/YCoCg, or similar\n calculations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVLumaCoefficients {
    pub cr: AVRational,
    pub cg: AVRational,
    pub cb: AVRational,
}
#[test]
fn bindgen_test_layout_AVLumaCoefficients() {
    const UNINIT: ::std::mem::MaybeUninit<AVLumaCoefficients> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVLumaCoefficients>(),
        24usize,
        concat!("Size of: ", stringify!(AVLumaCoefficients))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLumaCoefficients>(),
        4usize,
        concat!("Alignment of ", stringify!(AVLumaCoefficients))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLumaCoefficients),
            "::",
            stringify!(cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLumaCoefficients),
            "::",
            stringify!(cg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLumaCoefficients),
            "::",
            stringify!(cb)
        )
    );
}
#[doc = " Struct containing chromaticity x and y values for the standard CIE 1931\n chromaticity definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCIExy {
    pub x: AVRational,
    pub y: AVRational,
}
#[test]
fn bindgen_test_layout_AVCIExy() {
    const UNINIT: ::std::mem::MaybeUninit<AVCIExy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVCIExy>(),
        16usize,
        concat!("Size of: ", stringify!(AVCIExy))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCIExy>(),
        4usize,
        concat!("Alignment of ", stringify!(AVCIExy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCIExy),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCIExy),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Struct defining the red, green, and blue primary locations in terms of CIE\n 1931 chromaticity x and y."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPrimaryCoefficients {
    pub r: AVCIExy,
    pub g: AVCIExy,
    pub b: AVCIExy,
}
#[test]
fn bindgen_test_layout_AVPrimaryCoefficients() {
    const UNINIT: ::std::mem::MaybeUninit<AVPrimaryCoefficients> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPrimaryCoefficients>(),
        48usize,
        concat!("Size of: ", stringify!(AVPrimaryCoefficients))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPrimaryCoefficients>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPrimaryCoefficients))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPrimaryCoefficients),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPrimaryCoefficients),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPrimaryCoefficients),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " Struct defining white point location in terms of CIE 1931 chromaticity x\n and y."]
pub type AVWhitepointCoefficients = AVCIExy;
#[doc = " Struct that contains both white point location and primaries location, providing\n the complete description of a color gamut."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVColorPrimariesDesc {
    pub wp: AVWhitepointCoefficients,
    pub prim: AVPrimaryCoefficients,
}
#[test]
fn bindgen_test_layout_AVColorPrimariesDesc() {
    const UNINIT: ::std::mem::MaybeUninit<AVColorPrimariesDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVColorPrimariesDesc>(),
        64usize,
        concat!("Size of: ", stringify!(AVColorPrimariesDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<AVColorPrimariesDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(AVColorPrimariesDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVColorPrimariesDesc),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prim) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVColorPrimariesDesc),
            "::",
            stringify!(prim)
        )
    );
}
#[doc = " Function pointer representing a double -> double transfer function that performs\n an EOTF transfer inversion. This function outputs linear light."]
pub type av_csp_trc_function = ::std::option::Option<unsafe extern "C" fn(arg1: f64) -> f64>;
extern "C" {
    #[doc = " Retrieves the Luma coefficients necessary to construct a conversion matrix\n from an enum constant describing the colorspace.\n @param csp An enum constant indicating YUV or similar colorspace.\n @return The Luma coefficients associated with that colorspace, or NULL\n     if the constant is unknown to libavutil."]
    pub fn av_csp_luma_coeffs_from_avcsp(csp: AVColorSpace) -> *const AVLumaCoefficients;
}
extern "C" {
    #[doc = " Retrieves a complete gamut description from an enum constant describing the\n color primaries.\n @param prm An enum constant indicating primaries\n @return A description of the colorspace gamut associated with that enum\n     constant, or NULL if the constant is unknown to libavutil."]
    pub fn av_csp_primaries_desc_from_id(prm: AVColorPrimaries) -> *const AVColorPrimariesDesc;
}
extern "C" {
    #[doc = " Detects which enum AVColorPrimaries constant corresponds to the given complete\n gamut description.\n @see enum AVColorPrimaries\n @param prm A description of the colorspace gamut\n @return The enum constant associated with this gamut, or\n     AVCOL_PRI_UNSPECIFIED if no clear match can be idenitified."]
    pub fn av_csp_primaries_id_from_desc(prm: *const AVColorPrimariesDesc) -> AVColorPrimaries;
}
extern "C" {
    #[doc = " Determine a suitable 'gamma' value to match the supplied\n AVColorTransferCharacteristic.\n\n See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/_index.html)\n\n This function returns the gamma exponent for the OETF. For example, sRGB is approximated\n by gamma 2.2, not by gamma 0.45455.\n\n @return Will return an approximation to the simple gamma function matching\n         the supplied Transfer Characteristic, Will return 0.0 for any\n         we cannot reasonably match against."]
    pub fn av_csp_approximate_trc_gamma(trc: AVColorTransferCharacteristic) -> f64;
}
extern "C" {
    #[doc = " Determine the function needed to apply the given\n AVColorTransferCharacteristic to linear input.\n\n The function returned should expect a nominal domain and range of [0.0-1.0]\n values outside of this range maybe valid depending on the chosen\n characteristic function.\n\n @return Will return pointer to the function matching the\n         supplied Transfer Characteristic. If unspecified will\n         return NULL:"]
    pub fn av_csp_trc_func_from_id(trc: AVColorTransferCharacteristic) -> av_csp_trc_function;
}
#[doc = " @defgroup lavu_des DES\n @ingroup lavu_crypto\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDES {
    pub round_keys: [[u64; 16usize]; 3usize],
    pub triple_des: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVDES() {
    const UNINIT: ::std::mem::MaybeUninit<AVDES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDES>(),
        392usize,
        concat!("Size of: ", stringify!(AVDES))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDES>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).round_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDES),
            "::",
            stringify!(round_keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triple_des) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDES),
            "::",
            stringify!(triple_des)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVDES context."]
    pub fn av_des_alloc() -> *mut AVDES;
}
extern "C" {
    #[doc = " @brief Initializes an AVDES context.\n\n @param d pointer to a AVDES structure to initialize\n @param key pointer to the key to use\n @param key_bits must be 64 or 192\n @param decrypt 0 for encryption/CBC-MAC, 1 for decryption\n @return zero on success, negative value otherwise"]
    pub fn av_des_init(
        d: *mut AVDES,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
        decrypt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Encrypts / decrypts using the DES algorithm.\n\n @param d pointer to the AVDES structure\n @param dst destination array, can be equal to src, must be 8-byte aligned\n @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used,\n           must be 8-byte aligned\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_des_crypt(
        d: *mut AVDES,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates CBC-MAC using the DES algorithm.\n\n @param d pointer to the AVDES structure\n @param dst destination array, can be equal to src, must be 8-byte aligned\n @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n @param count number of 8 byte blocks"]
    pub fn av_des_mac(d: *mut AVDES, dst: *mut u8, src: *const u8, count: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDetectionBBox {
    #[doc = " Distance in pixels from the left/top edge of the frame,\n together with width and height, defining the bounding box."]
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    #[doc = " Detect result with confidence"]
    pub detect_label: [::std::os::raw::c_char; 64usize],
    pub detect_confidence: AVRational,
    pub classify_count: u32,
    pub classify_labels: [[::std::os::raw::c_char; 64usize]; 4usize],
    pub classify_confidences: [AVRational; 4usize],
}
#[test]
fn bindgen_test_layout_AVDetectionBBox() {
    const UNINIT: ::std::mem::MaybeUninit<AVDetectionBBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDetectionBBox>(),
        380usize,
        concat!("Size of: ", stringify!(AVDetectionBBox))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDetectionBBox>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDetectionBBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detect_label) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(detect_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detect_confidence) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(detect_confidence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classify_count) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(classify_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classify_labels) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(classify_labels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classify_confidences) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBox),
            "::",
            stringify!(classify_confidences)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDetectionBBoxHeader {
    #[doc = " Information about how the bounding box is generated.\n for example, the DNN model name."]
    pub source: [::std::os::raw::c_char; 256usize],
    #[doc = " Number of bounding boxes in the array."]
    pub nb_bboxes: u32,
    #[doc = " Offset in bytes from the beginning of this structure at which\n the array of bounding boxes starts."]
    pub bboxes_offset: usize,
    #[doc = " Size of each bounding box in bytes."]
    pub bbox_size: usize,
}
#[test]
fn bindgen_test_layout_AVDetectionBBoxHeader() {
    const UNINIT: ::std::mem::MaybeUninit<AVDetectionBBoxHeader> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDetectionBBoxHeader>(),
        280usize,
        concat!("Size of: ", stringify!(AVDetectionBBoxHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDetectionBBoxHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDetectionBBoxHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBoxHeader),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_bboxes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBoxHeader),
            "::",
            stringify!(nb_bboxes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxes_offset) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBoxHeader),
            "::",
            stringify!(bboxes_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox_size) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDetectionBBoxHeader),
            "::",
            stringify!(bbox_size)
        )
    );
}
extern "C" {
    #[doc = " Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}\n AVDetectionBBox, and initializes the variables.\n Can be freed with a normal av_free() call.\n\n @param nb_bboxes number of AVDetectionBBox structures to allocate\n @param out_size if non-NULL, the size in bytes of the resulting data array is\n written here."]
    pub fn av_detection_bbox_alloc(
        nb_bboxes: u32,
        out_size: *mut usize,
    ) -> *mut AVDetectionBBoxHeader;
}
extern "C" {
    #[doc = " Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}\n AVDetectionBBox, in the given AVFrame {@code frame} as AVFrameSideData of type\n AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables."]
    pub fn av_detection_bbox_create_side_data(
        frame: *mut AVFrame,
        nb_bboxes: u32,
    ) -> *mut AVDetectionBBoxHeader;
}
extern "C" {
    #[doc = " Extract the rotation component of the transformation matrix.\n\n @param matrix the transformation matrix\n @return the angle (in degrees) by which the transformation rotates the frame\n         counterclockwise. The angle will be in range [-180.0, 180.0],\n         or NaN if the matrix is singular.\n\n @note floating point numbers are inherently inexact, so callers are\n       recommended to round the return value to nearest integer before use."]
    pub fn av_display_rotation_get(matrix: *const i32) -> f64;
}
extern "C" {
    #[doc = " Initialize a transformation matrix describing a pure clockwise\n rotation by the specified angle (in degrees).\n\n @param[out] matrix a transformation matrix (will be fully overwritten\n                    by this function)\n @param angle rotation angle in degrees."]
    pub fn av_display_rotation_set(matrix: *mut i32, angle: f64);
}
extern "C" {
    #[doc = " Flip the input matrix horizontally and/or vertically.\n\n @param[in,out] matrix a transformation matrix\n @param hflip whether the matrix should be flipped horizontally\n @param vflip whether the matrix should be flipped vertically"]
    pub fn av_display_matrix_flip(
        matrix: *mut i32,
        hflip: ::std::os::raw::c_int,
        vflip: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIDecoderConfigurationRecord {
    pub dv_version_major: u8,
    pub dv_version_minor: u8,
    pub dv_profile: u8,
    pub dv_level: u8,
    pub rpu_present_flag: u8,
    pub el_present_flag: u8,
    pub bl_present_flag: u8,
    pub dv_bl_signal_compatibility_id: u8,
}
#[test]
fn bindgen_test_layout_AVDOVIDecoderConfigurationRecord() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIDecoderConfigurationRecord> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIDecoderConfigurationRecord>(),
        8usize,
        concat!("Size of: ", stringify!(AVDOVIDecoderConfigurationRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIDecoderConfigurationRecord>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(AVDOVIDecoderConfigurationRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(dv_version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_version_minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(dv_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_profile) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(dv_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_level) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(dv_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rpu_present_flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(rpu_present_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_present_flag) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(el_present_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl_present_flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(bl_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dv_bl_signal_compatibility_id) as usize - ptr as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDecoderConfigurationRecord),
            "::",
            stringify!(dv_bl_signal_compatibility_id)
        )
    );
}
extern "C" {
    #[doc = " Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its\n fields to default values.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_dovi_alloc(size: *mut usize) -> *mut AVDOVIDecoderConfigurationRecord;
}
#[doc = " Dolby Vision RPU data header.\n\n @note sizeof(AVDOVIRpuDataHeader) is not part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIRpuDataHeader {
    pub rpu_type: u8,
    pub rpu_format: u16,
    pub vdr_rpu_profile: u8,
    pub vdr_rpu_level: u8,
    pub chroma_resampling_explicit_filter_flag: u8,
    pub coef_data_type: u8,
    pub coef_log2_denom: u8,
    pub vdr_rpu_normalized_idc: u8,
    pub bl_video_full_range_flag: u8,
    pub bl_bit_depth: u8,
    pub el_bit_depth: u8,
    pub vdr_bit_depth: u8,
    pub spatial_resampling_filter_flag: u8,
    pub el_spatial_resampling_filter_flag: u8,
    pub disable_residual_flag: u8,
}
#[test]
fn bindgen_test_layout_AVDOVIRpuDataHeader() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIRpuDataHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIRpuDataHeader>(),
        18usize,
        concat!("Size of: ", stringify!(AVDOVIRpuDataHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIRpuDataHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(AVDOVIRpuDataHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rpu_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(rpu_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rpu_format) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(rpu_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_rpu_profile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(vdr_rpu_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_rpu_level) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(vdr_rpu_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chroma_resampling_explicit_filter_flag) as usize
                - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(chroma_resampling_explicit_filter_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coef_data_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(coef_data_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coef_log2_denom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(coef_log2_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_rpu_normalized_idc) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(vdr_rpu_normalized_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl_video_full_range_flag) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(bl_video_full_range_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl_bit_depth) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(bl_bit_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_bit_depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(el_bit_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_bit_depth) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(vdr_bit_depth)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).spatial_resampling_filter_flag) as usize - ptr as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(spatial_resampling_filter_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).el_spatial_resampling_filter_flag) as usize - ptr as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(el_spatial_resampling_filter_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_residual_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIRpuDataHeader),
            "::",
            stringify!(disable_residual_flag)
        )
    );
}
pub const AV_DOVI_MAPPING_POLYNOMIAL: AVDOVIMappingMethod = 0;
pub const AV_DOVI_MAPPING_MMR: AVDOVIMappingMethod = 1;
pub type AVDOVIMappingMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIReshapingCurve {
    pub num_pivots: u8,
    pub pivots: [u16; 9usize],
    pub mapping_idc: [AVDOVIMappingMethod; 8usize],
    pub poly_order: [u8; 8usize],
    pub poly_coef: [[i64; 3usize]; 8usize],
    pub mmr_order: [u8; 8usize],
    pub mmr_constant: [i64; 8usize],
    pub mmr_coef: [[[i64; 7usize]; 3usize]; 8usize],
}
#[test]
fn bindgen_test_layout_AVDOVIReshapingCurve() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIReshapingCurve> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIReshapingCurve>(),
        1672usize,
        concat!("Size of: ", stringify!(AVDOVIReshapingCurve))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIReshapingCurve>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDOVIReshapingCurve))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_pivots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(num_pivots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pivots) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(pivots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapping_idc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(mapping_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poly_order) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(poly_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poly_coef) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(poly_coef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmr_order) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(mmr_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmr_constant) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(mmr_constant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmr_coef) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIReshapingCurve),
            "::",
            stringify!(mmr_coef)
        )
    );
}
pub const AV_DOVI_NLQ_NONE: AVDOVINLQMethod = -1;
pub const AV_DOVI_NLQ_LINEAR_DZ: AVDOVINLQMethod = 0;
pub type AVDOVINLQMethod = ::std::os::raw::c_int;
#[doc = " Coefficients of the non-linear inverse quantization. For the interpretation\n of these, see ETSI GS CCM 001."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVINLQParams {
    pub nlq_offset: u16,
    pub vdr_in_max: u64,
    pub linear_deadzone_slope: u64,
    pub linear_deadzone_threshold: u64,
}
#[test]
fn bindgen_test_layout_AVDOVINLQParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVINLQParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVINLQParams>(),
        32usize,
        concat!("Size of: ", stringify!(AVDOVINLQParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVINLQParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDOVINLQParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlq_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVINLQParams),
            "::",
            stringify!(nlq_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_in_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVINLQParams),
            "::",
            stringify!(vdr_in_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_deadzone_slope) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVINLQParams),
            "::",
            stringify!(linear_deadzone_slope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_deadzone_threshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVINLQParams),
            "::",
            stringify!(linear_deadzone_threshold)
        )
    );
}
#[doc = " Dolby Vision RPU data mapping parameters.\n\n @note sizeof(AVDOVIDataMapping) is not part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIDataMapping {
    pub vdr_rpu_id: u8,
    pub mapping_color_space: u8,
    pub mapping_chroma_format_idc: u8,
    pub curves: [AVDOVIReshapingCurve; 3usize],
    pub nlq_method_idc: AVDOVINLQMethod,
    pub num_x_partitions: u32,
    pub num_y_partitions: u32,
    pub nlq: [AVDOVINLQParams; 3usize],
}
#[test]
fn bindgen_test_layout_AVDOVIDataMapping() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIDataMapping> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIDataMapping>(),
        5136usize,
        concat!("Size of: ", stringify!(AVDOVIDataMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIDataMapping>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDOVIDataMapping))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdr_rpu_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(vdr_rpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapping_color_space) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(mapping_color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapping_chroma_format_idc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(mapping_chroma_format_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(curves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlq_method_idc) as usize - ptr as usize },
        5024usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(nlq_method_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_x_partitions) as usize - ptr as usize },
        5028usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(num_x_partitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_y_partitions) as usize - ptr as usize },
        5032usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(num_y_partitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlq) as usize - ptr as usize },
        5040usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIDataMapping),
            "::",
            stringify!(nlq)
        )
    );
}
#[doc = " Dolby Vision RPU colorspace metadata parameters.\n\n @note sizeof(AVDOVIColorMetadata) is not part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIColorMetadata {
    pub dm_metadata_id: u8,
    pub scene_refresh_flag: u8,
    #[doc = " Coefficients of the custom Dolby Vision IPT-PQ matrices. These are to be\n used instead of the matrices indicated by the frame's colorspace tags.\n The output of rgb_to_lms_matrix is to be fed into a BT.2020 LMS->RGB\n matrix based on a Hunt-Pointer-Estevez transform, but without any\n crosstalk. (See the definition of the ICtCp colorspace for more\n information.)"]
    pub ycc_to_rgb_matrix: [AVRational; 9usize],
    pub ycc_to_rgb_offset: [AVRational; 3usize],
    pub rgb_to_lms_matrix: [AVRational; 9usize],
    #[doc = " Extra signal metadata (see Dolby patents for more info)."]
    pub signal_eotf: u16,
    pub signal_eotf_param0: u16,
    pub signal_eotf_param1: u16,
    pub signal_eotf_param2: u32,
    pub signal_bit_depth: u8,
    pub signal_color_space: u8,
    pub signal_chroma_format: u8,
    pub signal_full_range_flag: u8,
    pub source_min_pq: u16,
    pub source_max_pq: u16,
    pub source_diagonal: u16,
}
#[test]
fn bindgen_test_layout_AVDOVIColorMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIColorMetadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIColorMetadata>(),
        196usize,
        concat!("Size of: ", stringify!(AVDOVIColorMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIColorMetadata>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDOVIColorMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dm_metadata_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(dm_metadata_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scene_refresh_flag) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(scene_refresh_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc_to_rgb_matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(ycc_to_rgb_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycc_to_rgb_offset) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(ycc_to_rgb_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb_to_lms_matrix) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(rgb_to_lms_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eotf) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_eotf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eotf_param0) as usize - ptr as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_eotf_param0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eotf_param1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_eotf_param1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eotf_param2) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_eotf_param2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_bit_depth) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_bit_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_color_space) as usize - ptr as usize },
        185usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_chroma_format) as usize - ptr as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_chroma_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_full_range_flag) as usize - ptr as usize },
        187usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(signal_full_range_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_min_pq) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(source_min_pq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_max_pq) as usize - ptr as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(source_max_pq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_diagonal) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIColorMetadata),
            "::",
            stringify!(source_diagonal)
        )
    );
}
#[doc = " Combined struct representing a combination of header, mapping and color\n metadata, for attaching to frames as side data.\n\n @note The struct must be allocated with av_dovi_metadata_alloc() and\n       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDOVIMetadata {
    #[doc = " Offset in bytes from the beginning of this structure at which the\n respective structs start."]
    pub header_offset: usize,
    pub mapping_offset: usize,
    pub color_offset: usize,
}
#[test]
fn bindgen_test_layout_AVDOVIMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<AVDOVIMetadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDOVIMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(AVDOVIMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDOVIMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDOVIMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIMetadata),
            "::",
            stringify!(header_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapping_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIMetadata),
            "::",
            stringify!(mapping_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDOVIMetadata),
            "::",
            stringify!(color_offset)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVDOVIMetadata structure and initialize its\n fields to default values.\n\n @param size If this parameter is non-NULL, the size in bytes of the\n             allocated struct will be written here on success\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_dovi_metadata_alloc(size: *mut usize) -> *mut AVDOVIMetadata;
}
#[doc = "< Not indicated."]
pub const AV_DOWNMIX_TYPE_UNKNOWN: AVDownmixType = 0;
#[doc = "< Lo/Ro 2-channel downmix (Stereo)."]
pub const AV_DOWNMIX_TYPE_LORO: AVDownmixType = 1;
#[doc = "< Lt/Rt 2-channel downmix, Dolby Surround compatible."]
pub const AV_DOWNMIX_TYPE_LTRT: AVDownmixType = 2;
#[doc = "< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible."]
pub const AV_DOWNMIX_TYPE_DPLII: AVDownmixType = 3;
#[doc = "< Number of downmix types. Not part of ABI."]
pub const AV_DOWNMIX_TYPE_NB: AVDownmixType = 4;
#[doc = " Possible downmix types."]
pub type AVDownmixType = ::std::os::raw::c_uint;
#[doc = " This structure describes optional metadata relevant to a downmix procedure.\n\n All fields are set by the decoder to the value indicated in the audio\n bitstream (if present), or to a \"sane\" default otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDownmixInfo {
    #[doc = " Type of downmix preferred by the mastering engineer."]
    pub preferred_downmix_type: AVDownmixType,
    #[doc = " Absolute scale factor representing the nominal level of the center\n channel during a regular downmix."]
    pub center_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the center\n channel during an Lt/Rt compatible downmix."]
    pub center_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround\n channels during a regular downmix."]
    pub surround_mix_level: f64,
    #[doc = " Absolute scale factor representing the nominal level of the surround\n channels during an Lt/Rt compatible downmix."]
    pub surround_mix_level_ltrt: f64,
    #[doc = " Absolute scale factor representing the level at which the LFE data is\n mixed into L/R channels during downmixing."]
    pub lfe_mix_level: f64,
}
#[test]
fn bindgen_test_layout_AVDownmixInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AVDownmixInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDownmixInfo>(),
        48usize,
        concat!("Size of: ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDownmixInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferred_downmix_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(preferred_downmix_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_mix_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_mix_level_ltrt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surround_mix_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surround_mix_level_ltrt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lfe_mix_level) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(lfe_mix_level)
        )
    );
}
extern "C" {
    #[doc = " Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.\n\n If the side data is absent, it is created and added to the frame.\n\n @param frame the frame for which the side data is to be obtained or created\n\n @return the AVDownmixInfo structure to be edited by the caller, or NULL if\n         the structure cannot be allocated."]
    pub fn av_downmix_info_update_side_data(frame: *mut AVFrame) -> *mut AVDownmixInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubsampleEncryptionInfo {
    #[doc = " The number of bytes that are clear."]
    pub bytes_of_clear_data: ::std::os::raw::c_uint,
    #[doc = " The number of bytes that are protected.  If using pattern encryption,\n the pattern applies to only the protected bytes; if not using pattern\n encryption, all these bytes are encrypted."]
    pub bytes_of_protected_data: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_AVSubsampleEncryptionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AVSubsampleEncryptionInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVSubsampleEncryptionInfo>(),
        8usize,
        concat!("Size of: ", stringify!(AVSubsampleEncryptionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubsampleEncryptionInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(AVSubsampleEncryptionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_of_clear_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubsampleEncryptionInfo),
            "::",
            stringify!(bytes_of_clear_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_of_protected_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubsampleEncryptionInfo),
            "::",
            stringify!(bytes_of_protected_data)
        )
    );
}
#[doc = " This describes encryption info for a packet.  This contains frame-specific\n info for how to decrypt the packet before passing it to the decoder.\n\n The size of this struct is not part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVEncryptionInfo {
    #[doc = " The fourcc encryption scheme, in big-endian byte order."]
    pub scheme: u32,
    #[doc = " Only used for pattern encryption.  This is the number of 16-byte blocks\n that are encrypted."]
    pub crypt_byte_block: u32,
    #[doc = " Only used for pattern encryption.  This is the number of 16-byte blocks\n that are clear."]
    pub skip_byte_block: u32,
    #[doc = " The ID of the key used to encrypt the packet.  This should always be\n 16 bytes long, but may be changed in the future."]
    pub key_id: *mut u8,
    pub key_id_size: u32,
    #[doc = " The initialization vector.  This may have been zero-filled to be the\n correct block size.  This should always be 16 bytes long, but may be\n changed in the future."]
    pub iv: *mut u8,
    pub iv_size: u32,
    #[doc = " An array of subsample encryption info specifying how parts of the sample\n are encrypted.  If there are no subsamples, then the whole sample is\n encrypted."]
    pub subsamples: *mut AVSubsampleEncryptionInfo,
    pub subsample_count: u32,
}
#[test]
fn bindgen_test_layout_AVEncryptionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AVEncryptionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVEncryptionInfo>(),
        64usize,
        concat!("Size of: ", stringify!(AVEncryptionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVEncryptionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVEncryptionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crypt_byte_block) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(crypt_byte_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_byte_block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(skip_byte_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_id_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(key_id_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subsamples) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(subsamples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subsample_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInfo),
            "::",
            stringify!(subsample_count)
        )
    );
}
#[doc = " This describes info used to initialize an encryption key system.\n\n The size of this struct is not part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVEncryptionInitInfo {
    #[doc = " A unique identifier for the key system this is for, can be NULL if it\n is not known.  This should always be 16 bytes, but may change in the\n future."]
    pub system_id: *mut u8,
    pub system_id_size: u32,
    #[doc = " An array of key IDs this initialization data is for.  All IDs are the\n same length.  Can be NULL if there are no known key IDs."]
    pub key_ids: *mut *mut u8,
    #[doc = " The number of key IDs."]
    pub num_key_ids: u32,
    #[doc = " The number of bytes in each key ID.  This should always be 16, but may\n change in the future."]
    pub key_id_size: u32,
    #[doc = " Key-system specific initialization data.  This data is copied directly\n from the file and the format depends on the specific key system.  This\n can be NULL if there is no initialization data; in that case, there\n will be at least one key ID."]
    pub data: *mut u8,
    pub data_size: u32,
    #[doc = " An optional pointer to the next initialization info in the list."]
    pub next: *mut AVEncryptionInitInfo,
}
#[test]
fn bindgen_test_layout_AVEncryptionInitInfo() {
    const UNINIT: ::std::mem::MaybeUninit<AVEncryptionInitInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVEncryptionInitInfo>(),
        56usize,
        concat!("Size of: ", stringify!(AVEncryptionInitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVEncryptionInitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVEncryptionInitInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(system_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_id_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(system_id_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_ids) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(key_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_key_ids) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(num_key_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_id_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(key_id_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVEncryptionInitInfo),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Allocates an AVEncryptionInfo structure and sub-pointers to hold the given\n number of subsamples.  This will allocate pointers for the key ID, IV,\n and subsample entries, set the size members, and zero-initialize the rest.\n\n @param subsample_count The number of subsamples.\n @param key_id_size The number of bytes in the key ID, should be 16.\n @param iv_size The number of bytes in the IV, should be 16.\n\n @return The new AVEncryptionInfo structure, or NULL on error."]
    pub fn av_encryption_info_alloc(
        subsample_count: u32,
        key_id_size: u32,
        iv_size: u32,
    ) -> *mut AVEncryptionInfo;
}
extern "C" {
    #[doc = " Allocates an AVEncryptionInfo structure with a copy of the given data.\n @return The new AVEncryptionInfo structure, or NULL on error."]
    pub fn av_encryption_info_clone(info: *const AVEncryptionInfo) -> *mut AVEncryptionInfo;
}
extern "C" {
    #[doc = " Frees the given encryption info object.  This MUST NOT be used to free the\n side-data data pointer, that should use normal side-data methods."]
    pub fn av_encryption_info_free(info: *mut AVEncryptionInfo);
}
extern "C" {
    #[doc = " Creates a copy of the AVEncryptionInfo that is contained in the given side\n data.  The resulting object should be passed to av_encryption_info_free()\n when done.\n\n @return The new AVEncryptionInfo structure, or NULL on error."]
    pub fn av_encryption_info_get_side_data(
        side_data: *const u8,
        side_data_size: usize,
    ) -> *mut AVEncryptionInfo;
}
extern "C" {
    #[doc = " Allocates and initializes side data that holds a copy of the given encryption\n info.  The resulting pointer should be either freed using av_free or given\n to av_packet_add_side_data().\n\n @return The new side-data pointer, or NULL."]
    pub fn av_encryption_info_add_side_data(
        info: *const AVEncryptionInfo,
        side_data_size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the\n given sizes.  This will allocate pointers and set all the fields.\n\n @return The new AVEncryptionInitInfo structure, or NULL on error."]
    pub fn av_encryption_init_info_alloc(
        system_id_size: u32,
        num_key_ids: u32,
        key_id_size: u32,
        data_size: u32,
    ) -> *mut AVEncryptionInitInfo;
}
extern "C" {
    #[doc = " Frees the given encryption init info object.  This MUST NOT be used to free\n the side-data data pointer, that should use normal side-data methods."]
    pub fn av_encryption_init_info_free(info: *mut AVEncryptionInitInfo);
}
extern "C" {
    #[doc = " Creates a copy of the AVEncryptionInitInfo that is contained in the given\n side data.  The resulting object should be passed to\n av_encryption_init_info_free() when done.\n\n @return The new AVEncryptionInitInfo structure, or NULL on error."]
    pub fn av_encryption_init_info_get_side_data(
        side_data: *const u8,
        side_data_size: usize,
    ) -> *mut AVEncryptionInitInfo;
}
extern "C" {
    #[doc = " Allocates and initializes side data that holds a copy of the given encryption\n init info.  The resulting pointer should be either freed using av_free or\n given to av_packet_add_side_data().\n\n @return The new side-data pointer, or NULL."]
    pub fn av_encryption_init_info_add_side_data(
        info: *const AVEncryptionInitInfo,
        side_data_size: *mut usize,
    ) -> *mut u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVExpr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Parse and evaluate an expression.\n Note, this is significantly slower than av_expr_eval().\n\n @param res a pointer to a double where is put the result value of\n the expression, or NAN in case of error\n @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n @param const_values a zero terminated array of values for the identifiers from const_names\n @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n @param log_offset log level offset, can be used to silence error messages\n @param log_ctx parent logging context\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_expr_parse_and_eval(
        res: *mut f64,
        s: *const ::std::os::raw::c_char,
        const_names: *const *const ::std::os::raw::c_char,
        const_values: *const f64,
        func1_names: *const *const ::std::os::raw::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const ::std::os::raw::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        opaque: *mut ::std::os::raw::c_void,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an expression.\n\n @param expr a pointer where is put an AVExpr containing the parsed\n value in case of successful parsing, or NULL otherwise.\n The pointed to AVExpr must be freed with av_expr_free() by the user\n when it is not needed anymore.\n @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n @param log_offset log level offset, can be used to silence error messages\n @param log_ctx parent logging context\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_expr_parse(
        expr: *mut *mut AVExpr,
        s: *const ::std::os::raw::c_char,
        const_names: *const *const ::std::os::raw::c_char,
        func1_names: *const *const ::std::os::raw::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const ::std::os::raw::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Evaluate a previously parsed expression.\n\n @param e the AVExpr to evaluate\n @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names\n @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n @return the value of the expression"]
    pub fn av_expr_eval(
        e: *mut AVExpr,
        const_values: *const f64,
        opaque: *mut ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    #[doc = " Track the presence of variables and their number of occurrences in a parsed expression\n\n @param e the AVExpr to track variables in\n @param counter a zero-initialized array where the count of each variable will be stored\n @param size size of array\n @return 0 on success, a negative value indicates that no expression or array was passed\n or size was zero"]
    pub fn av_expr_count_vars(
        e: *mut AVExpr,
        counter: *mut ::std::os::raw::c_uint,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Track the presence of user provided functions and their number of occurrences\n in a parsed expression.\n\n @param e the AVExpr to track user provided functions in\n @param counter a zero-initialized array where the count of each function will be stored\n                if you passed 5 functions with 2 arguments to av_expr_parse()\n                then for arg=2 this will use upto 5 entries.\n @param size size of array\n @param arg number of arguments the counted functions have\n @return 0 on success, a negative value indicates that no expression or array was passed\n or size was zero"]
    pub fn av_expr_count_func(
        e: *mut AVExpr,
        counter: *mut ::std::os::raw::c_uint,
        size: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a parsed expression previously created with av_expr_parse()."]
    pub fn av_expr_free(e: *mut AVExpr);
}
extern "C" {
    #[doc = " Parse the string in numstr and return its value as a double. If\n the string is empty, contains only whitespaces, or does not contain\n an initial substring that has the expected syntax for a\n floating-point number, no conversion is performed. In this case,\n returns a value of zero and the value returned in tail is the value\n of numstr.\n\n @param numstr a string representing a number, may contain one of\n the International System number postfixes, for example 'K', 'M',\n 'G'. If 'i' is appended after the postfix, powers of 2 are used\n instead of powers of 10. The 'B' postfix multiplies the value by\n 8, and can be appended after another postfix or used alone. This\n allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.\n @param tail if non-NULL puts here the pointer to the char next\n after the last parsed character"]
    pub fn av_strtod(
        numstr: *const ::std::os::raw::c_char,
        tail: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVExecutor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTask {
    pub next: *mut AVTask,
}
#[test]
fn bindgen_test_layout_AVTask() {
    const UNINIT: ::std::mem::MaybeUninit<AVTask> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVTask>(),
        8usize,
        concat!("Size of: ", stringify!(AVTask))
    );
    assert_eq!(
        ::std::mem::align_of::<AVTask>(),
        8usize,
        concat!("Alignment of ", stringify!(AVTask))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTask),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTaskCallbacks {
    pub user_data: *mut ::std::os::raw::c_void,
    pub local_context_size: ::std::os::raw::c_int,
    pub priority_higher: ::std::option::Option<
        unsafe extern "C" fn(a: *const AVTask, b: *const AVTask) -> ::std::os::raw::c_int,
    >,
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            t: *const AVTask,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            t: *mut AVTask,
            local_context: *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVTaskCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<AVTaskCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVTaskCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(AVTaskCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<AVTaskCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(AVTaskCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTaskCallbacks),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_context_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTaskCallbacks),
            "::",
            stringify!(local_context_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_higher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTaskCallbacks),
            "::",
            stringify!(priority_higher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTaskCallbacks),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTaskCallbacks),
            "::",
            stringify!(run)
        )
    );
}
extern "C" {
    #[doc = " Alloc executor\n @param callbacks callback structure for executor\n @param thread_count worker thread number\n @return return the executor"]
    pub fn av_executor_alloc(
        callbacks: *const AVTaskCallbacks,
        thread_count: ::std::os::raw::c_int,
    ) -> *mut AVExecutor;
}
extern "C" {
    #[doc = " Free executor\n @param e  pointer to executor"]
    pub fn av_executor_free(e: *mut *mut AVExecutor);
}
extern "C" {
    #[doc = " Add task to executor\n @param e pointer to executor\n @param t pointer to task. If NULL, it will wakeup one work thread"]
    pub fn av_executor_execute(e: *mut AVExecutor, t: *mut AVTask);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFifo {
    _unused: [u8; 0],
}
#[doc = " Callback for writing or reading from a FIFO, passed to (and invoked from) the\n av_fifo_*_cb() functions. It may be invoked multiple times from a single\n av_fifo_*_cb() call and may process less data than the maximum size indicated\n by nb_elems.\n\n @param opaque the opaque pointer provided to the av_fifo_*_cb() function\n @param buf the buffer for reading or writing the data, depending on which\n            av_fifo_*_cb function is called\n @param nb_elems On entry contains the maximum number of elements that can be\n                 read from / written into buf. On success, the callback should\n                 update it to contain the number of elements actually written.\n\n @return 0 on success, a negative error code on failure (will be returned from\n         the invoking av_fifo_*_cb() function)"]
pub type AVFifoCB = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        nb_elems: *mut usize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Allocate and initialize an AVFifo with a given element size.\n\n @param elems     initial number of elements that can be stored in the FIFO\n @param elem_size Size in bytes of a single element. Further operations on\n                  the returned FIFO will implicitly use this element size.\n @param flags a combination of AV_FIFO_FLAG_*\n\n @return newly-allocated AVFifo on success, a negative error code on failure"]
    pub fn av_fifo_alloc2(
        elems: usize,
        elem_size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> *mut AVFifo;
}
extern "C" {
    #[doc = " @return Element size for FIFO operations. This element size is set at\n         FIFO allocation and remains constant during its lifetime"]
    pub fn av_fifo_elem_size(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " Set the maximum size (in elements) to which the FIFO can be resized\n automatically. Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used."]
    pub fn av_fifo_auto_grow_limit(f: *mut AVFifo, max_elems: usize);
}
extern "C" {
    #[doc = " @return number of elements available for reading from the given FIFO."]
    pub fn av_fifo_can_read(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " @return Number of elements that can be written into the given FIFO without\n         growing it.\n\n         In other words, this number of elements or less is guaranteed to fit\n         into the FIFO. More data may be written when the\n         AV_FIFO_FLAG_AUTO_GROW flag was specified at FIFO creation, but this\n         may involve memory allocation, which can fail."]
    pub fn av_fifo_can_write(f: *const AVFifo) -> usize;
}
extern "C" {
    #[doc = " Enlarge an AVFifo.\n\n On success, the FIFO will be large enough to hold exactly\n inc + av_fifo_can_read() + av_fifo_can_write()\n elements. In case of failure, the old FIFO is kept unchanged.\n\n @param f AVFifo to resize\n @param inc number of elements to allocate for, in addition to the current\n            allocated size\n @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_grow2(f: *mut AVFifo, inc: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write data into a FIFO.\n\n In case nb_elems > av_fifo_can_write(f) and the AV_FIFO_FLAG_AUTO_GROW flag\n was not specified at FIFO creation, nothing is written and an error\n is returned.\n\n Calling function is guaranteed to succeed if nb_elems <= av_fifo_can_write(f).\n\n @param f the FIFO buffer\n @param buf Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be\n            read from buf on success.\n @param nb_elems number of elements to write into FIFO\n\n @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_write(
        f: *mut AVFifo,
        buf: *const ::std::os::raw::c_void,
        nb_elems: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write data from a user-provided callback into a FIFO.\n\n @param f the FIFO buffer\n @param read_cb Callback supplying the data to the FIFO. May be called\n                multiple times.\n @param opaque opaque user data to be provided to read_cb\n @param nb_elems Should point to the maximum number of elements that can be\n                 written. Will be updated to contain the number of elements\n                 actually written.\n\n @return non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_write_from_cb(
        f: *mut AVFifo,
        read_cb: AVFifoCB,
        opaque: *mut ::std::os::raw::c_void,
        nb_elems: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data from a FIFO.\n\n In case nb_elems > av_fifo_can_read(f), nothing is read and an error\n is returned.\n\n @param f the FIFO buffer\n @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes\n            will be written into buf on success.\n @param nb_elems number of elements to read from FIFO\n\n @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_read(
        f: *mut AVFifo,
        buf: *mut ::std::os::raw::c_void,
        nb_elems: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data from a FIFO into a user-provided callback.\n\n @param f the FIFO buffer\n @param write_cb Callback the data will be supplied to. May be called\n                 multiple times.\n @param opaque opaque user data to be provided to write_cb\n @param nb_elems Should point to the maximum number of elements that can be\n                 read. Will be updated to contain the total number of elements\n                 actually sent to the callback.\n\n @return non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_read_to_cb(
        f: *mut AVFifo,
        write_cb: AVFifoCB,
        opaque: *mut ::std::os::raw::c_void,
        nb_elems: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data from a FIFO without modifying FIFO state.\n\n Returns an error if an attempt is made to peek to nonexistent elements\n (i.e. if offset + nb_elems is larger than av_fifo_can_read(f)).\n\n @param f the FIFO buffer\n @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes\n            will be written into buf.\n @param nb_elems number of elements to read from FIFO\n @param offset number of initial elements to skip.\n\n @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_peek(
        f: *const AVFifo,
        buf: *mut ::std::os::raw::c_void,
        nb_elems: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data from a FIFO into a user-provided callback.\n\n @param f the FIFO buffer\n @param write_cb Callback the data will be supplied to. May be called\n                 multiple times.\n @param opaque opaque user data to be provided to write_cb\n @param nb_elems Should point to the maximum number of elements that can be\n                 read. Will be updated to contain the total number of elements\n                 actually sent to the callback.\n @param offset number of initial elements to skip; offset + *nb_elems must not\n               be larger than av_fifo_can_read(f).\n\n @return a non-negative number on success, a negative error code on failure"]
    pub fn av_fifo_peek_to_cb(
        f: *const AVFifo,
        write_cb: AVFifoCB,
        opaque: *mut ::std::os::raw::c_void,
        nb_elems: *mut usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Discard the specified amount of data from an AVFifo.\n @param size number of elements to discard, MUST NOT be larger than\n             av_fifo_can_read(f)"]
    pub fn av_fifo_drain2(f: *mut AVFifo, size: usize);
}
extern "C" {
    pub fn av_fifo_reset2(f: *mut AVFifo);
}
extern "C" {
    #[doc = " Free an AVFifo and reset pointer to NULL.\n @param f Pointer to an AVFifo to free. *f == NULL is allowed."]
    pub fn av_fifo_freep2(f: *mut *mut AVFifo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFifoBuffer {
    pub buffer: *mut u8,
    pub rptr: *mut u8,
    pub wptr: *mut u8,
    pub end: *mut u8,
    pub rndx: u32,
    pub wndx: u32,
}
#[test]
fn bindgen_test_layout_AVFifoBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<AVFifoBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFifoBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFifoBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rndx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rndx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wndx) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wndx)
        )
    );
}
extern "C" {
    #[doc = " Initialize an AVFifoBuffer.\n @param size of FIFO\n @return AVFifoBuffer or NULL in case of memory allocation failure\n @deprecated use av_fifo_alloc2()"]
    pub fn av_fifo_alloc(size: ::std::os::raw::c_uint) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Initialize an AVFifoBuffer.\n @param nmemb number of elements\n @param size  size of the single element\n @return AVFifoBuffer or NULL in case of memory allocation failure\n @deprecated use av_fifo_alloc2()"]
    pub fn av_fifo_alloc_array(nmemb: usize, size: usize) -> *mut AVFifoBuffer;
}
extern "C" {
    #[doc = " Free an AVFifoBuffer.\n @param f AVFifoBuffer to free\n @deprecated use the AVFifo API with av_fifo_freep2()"]
    pub fn av_fifo_free(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Free an AVFifoBuffer and reset pointer to NULL.\n @param f AVFifoBuffer to free\n @deprecated use the AVFifo API with av_fifo_freep2()"]
    pub fn av_fifo_freep(f: *mut *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.\n @param f AVFifoBuffer to reset\n @deprecated use av_fifo_reset2() with the new AVFifo-API"]
    pub fn av_fifo_reset(f: *mut AVFifoBuffer);
}
extern "C" {
    #[doc = " Return the amount of data in bytes in the AVFifoBuffer, that is the\n amount of data you can read from it.\n @param f AVFifoBuffer to read from\n @return size\n @deprecated use av_fifo_can_read() with the new AVFifo-API"]
    pub fn av_fifo_size(f: *const AVFifoBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the amount of space in bytes in the AVFifoBuffer, that is the\n amount of data you can write into it.\n @param f AVFifoBuffer to write into\n @return size\n @deprecated use av_fifo_can_write() with the new AVFifo-API"]
    pub fn av_fifo_space(f: *const AVFifoBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data at specific position from an AVFifoBuffer to a user-supplied callback.\n Similar as av_fifo_gereric_read but without discarding data.\n @param f AVFifoBuffer to read from\n @param offset offset from current read position\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination\n\n @return a non-negative number on success, a negative error code on failure\n\n @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,\n             av_fifo_peek_to_cb() otherwise"]
    pub fn av_fifo_generic_peek_at(
        f: *mut AVFifoBuffer,
        dest: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        buf_size: ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback.\n Similar as av_fifo_gereric_read but without discarding data.\n @param f AVFifoBuffer to read from\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination\n\n @return a non-negative number on success, a negative error code on failure\n\n @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,\n             av_fifo_peek_to_cb() otherwise"]
    pub fn av_fifo_generic_peek(
        f: *mut AVFifoBuffer,
        dest: *mut ::std::os::raw::c_void,
        buf_size: ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data from an AVFifoBuffer to a user-supplied callback.\n @param f AVFifoBuffer to read from\n @param buf_size number of bytes to read\n @param func generic read function\n @param dest data destination\n\n @return a non-negative number on success, a negative error code on failure\n\n @deprecated use the new AVFifo-API with av_fifo_read() when func == NULL,\n             av_fifo_read_to_cb() otherwise"]
    pub fn av_fifo_generic_read(
        f: *mut AVFifoBuffer,
        dest: *mut ::std::os::raw::c_void,
        buf_size: ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed data from a user-supplied callback to an AVFifoBuffer.\n @param f AVFifoBuffer to write to\n @param src data source; non-const since it may be used as a\n modifiable context by the function defined in func\n @param size number of bytes to write\n @param func generic write function; the first parameter is src,\n the second is dest_buf, the third is dest_buf_size.\n func must return the number of bytes written to dest_buf, or <= 0 to\n indicate no more data available to write.\n If func is NULL, src is interpreted as a simple byte array for source data.\n @return the number of bytes written to the FIFO or a negative error code on failure\n\n @deprecated use the new AVFifo-API with av_fifo_write() when func == NULL,\n             av_fifo_write_from_cb() otherwise"]
    pub fn av_fifo_generic_write(
        f: *mut AVFifoBuffer,
        src: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resize an AVFifoBuffer.\n In case of reallocation failure, the old FIFO is kept unchanged.\n\n @param f AVFifoBuffer to resize\n @param size new AVFifoBuffer size in bytes\n @return <0 for failure, >=0 otherwise\n\n @deprecated use the new AVFifo-API with av_fifo_grow2() to increase FIFO size,\n             decreasing FIFO size is not supported"]
    pub fn av_fifo_realloc2(
        f: *mut AVFifoBuffer,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enlarge an AVFifoBuffer.\n In case of reallocation failure, the old FIFO is kept unchanged.\n The new fifo size may be larger than the requested size.\n\n @param f AVFifoBuffer to resize\n @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()\n @return <0 for failure, >=0 otherwise\n\n @deprecated use the new AVFifo-API with av_fifo_grow2(); note that unlike\n this function it adds to the allocated size, rather than to the used size"]
    pub fn av_fifo_grow(
        f: *mut AVFifoBuffer,
        additional_space: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read and discard the specified amount of data from an AVFifoBuffer.\n @param f AVFifoBuffer to read from\n @param size amount of data to read in bytes\n\n @deprecated use the new AVFifo-API with av_fifo_drain2()"]
    pub fn av_fifo_drain(f: *mut AVFifoBuffer, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Read the file with name filename, and put its content in a newly\n allocated buffer or map it with mmap() when available.\n In case of success set *bufptr to the read or mmapped buffer, and\n *size to the size in bytes of the buffer in *bufptr.\n Unlike mmap this function succeeds with zero sized files, in this\n case *bufptr will be set to NULL and *size will be set to 0.\n The returned buffer must be released with av_file_unmap().\n\n @param filename path to the file\n @param[out] bufptr pointee is set to the mapped or allocated buffer\n @param[out] size pointee is set to the size in bytes of the buffer\n @param log_offset loglevel offset used for logging\n @param log_ctx context used for logging\n @return a non negative number in case of success, a negative value\n corresponding to an AVERROR error code in case of failure"]
    pub fn av_file_map(
        filename: *const ::std::os::raw::c_char,
        bufptr: *mut *mut u8,
        size: *mut usize,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unmap or free the buffer bufptr created by av_file_map().\n\n @param bufptr the buffer previously created with av_file_map()\n @param size size in bytes of bufptr, must be the same as returned\n by av_file_map()"]
    pub fn av_file_unmap(bufptr: *mut u8, size: usize);
}
extern "C" {
    #[doc = " Wrapper to work around the lack of mkstemp() on mingw.\n Also, tries to create file in /tmp first, if possible.\n *prefix can be a character constant; *filename will be allocated internally.\n @return file descriptor of opened file (or negative value corresponding to an\n AVERROR code on error)\n and opened file name in **filename.\n @note On very old libcs it is necessary to set a secure umask before\n       calling this, av_tempfile() can't call umask itself as it is used in\n       libraries and could interfere with the calling application.\n @deprecated as fd numbers cannot be passed saftely between libs on some platforms"]
    pub fn av_tempfile(
        prefix: *const ::std::os::raw::c_char,
        filename: *mut *mut ::std::os::raw::c_char,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const AV_FILM_GRAIN_PARAMS_NONE: AVFilmGrainParamsType = 0;
#[doc = " The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)"]
pub const AV_FILM_GRAIN_PARAMS_AV1: AVFilmGrainParamsType = 1;
#[doc = " The union is valid when interpreted as AVFilmGrainH274Params (codec.h274)"]
pub const AV_FILM_GRAIN_PARAMS_H274: AVFilmGrainParamsType = 2;
pub type AVFilmGrainParamsType = ::std::os::raw::c_uint;
#[doc = " This structure describes how to handle film grain synthesis for AOM codecs.\n\n @note The struct must be allocated as part of AVFilmGrainParams using\n       av_film_grain_params_alloc(). Its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilmGrainAOMParams {
    #[doc = " Number of points, and the scale and value for each point of the\n piecewise linear scaling function for the uma plane."]
    pub num_y_points: ::std::os::raw::c_int,
    pub y_points: [[u8; 2usize]; 14usize],
    #[doc = " Signals whether to derive the chroma scaling function from the luma.\n Not equivalent to copying the luma values and scales."]
    pub chroma_scaling_from_luma: ::std::os::raw::c_int,
    #[doc = " If chroma_scaling_from_luma is set to 0, signals the chroma scaling\n function parameters."]
    pub num_uv_points: [::std::os::raw::c_int; 2usize],
    pub uv_points: [[[u8; 2usize]; 10usize]; 2usize],
    #[doc = " Specifies the shift applied to the chroma components. For AV1, its within\n [8; 11] and determines the range and quantization of the film grain."]
    pub scaling_shift: ::std::os::raw::c_int,
    #[doc = " Specifies the auto-regression lag."]
    pub ar_coeff_lag: ::std::os::raw::c_int,
    #[doc = " Luma auto-regression coefficients. The number of coefficients is given by\n 2 * ar_coeff_lag * (ar_coeff_lag + 1)."]
    pub ar_coeffs_y: [i8; 24usize],
    #[doc = " Chroma auto-regression coefficients. The number of coefficients is given by\n 2 * ar_coeff_lag * (ar_coeff_lag + 1) + !!num_y_points."]
    pub ar_coeffs_uv: [[i8; 25usize]; 2usize],
    #[doc = " Specifies the range of the auto-regressive coefficients. Values of 6,\n 7, 8 and so on represent a range of [-2, 2), [-1, 1), [-0.5, 0.5) and\n so on. For AV1 must be between 6 and 9."]
    pub ar_coeff_shift: ::std::os::raw::c_int,
    #[doc = " Signals the down shift applied to the generated gaussian numbers during\n synthesis."]
    pub grain_scale_shift: ::std::os::raw::c_int,
    #[doc = " Specifies the luma/chroma multipliers for the index to the component\n scaling function."]
    pub uv_mult: [::std::os::raw::c_int; 2usize],
    pub uv_mult_luma: [::std::os::raw::c_int; 2usize],
    #[doc = " Offset used for component scaling function. For AV1 its a 9-bit value\n with a range [-256, 255]"]
    pub uv_offset: [::std::os::raw::c_int; 2usize],
    #[doc = " Signals whether to overlap film grain blocks."]
    pub overlap_flag: ::std::os::raw::c_int,
    #[doc = " Signals to clip to limited color levels after film grain application."]
    pub limit_output_range: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVFilmGrainAOMParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilmGrainAOMParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilmGrainAOMParams>(),
        208usize,
        concat!("Size of: ", stringify!(AVFilmGrainAOMParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilmGrainAOMParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AVFilmGrainAOMParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_y_points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(num_y_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_points) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(y_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_scaling_from_luma) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(chroma_scaling_from_luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_uv_points) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(num_uv_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_points) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(uv_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_shift) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(scaling_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeff_lag) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(ar_coeff_lag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_y) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(ar_coeffs_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_uv) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(ar_coeffs_uv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeff_shift) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(ar_coeff_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grain_scale_shift) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(grain_scale_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_mult) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(uv_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_mult_luma) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(uv_mult_luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_offset) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(uv_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlap_flag) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(overlap_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_output_range) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainAOMParams),
            "::",
            stringify!(limit_output_range)
        )
    );
}
#[doc = " This structure describes how to handle film grain synthesis for codecs using\n the ITU-T H.274 Versatile suplemental enhancement information message.\n\n @note The struct must be allocated as part of AVFilmGrainParams using\n       av_film_grain_params_alloc(). Its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilmGrainH274Params {
    #[doc = " Specifies the film grain simulation mode.\n 0 = Frequency filtering, 1 = Auto-regression"]
    pub model_id: ::std::os::raw::c_int,
    #[doc = " Specifies the bit depth used for the luma component."]
    pub bit_depth_luma: ::std::os::raw::c_int,
    #[doc = " Specifies the bit depth used for the chroma components."]
    pub bit_depth_chroma: ::std::os::raw::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    #[doc = " Specifies the blending mode used to blend the simulated film grain\n with the decoded images.\n\n 0 = Additive, 1 = Multiplicative"]
    pub blending_mode_id: ::std::os::raw::c_int,
    #[doc = " Specifies a scale factor used in the film grain characterization equations."]
    pub log2_scale_factor: ::std::os::raw::c_int,
    #[doc = " Indicates if the modelling of film grain for a given component is present."]
    pub component_model_present: [::std::os::raw::c_int; 3usize],
    #[doc = " Specifies the number of intensity intervals for which a specific set of\n model values has been estimated, with a range of [1, 256]."]
    pub num_intensity_intervals: [u16; 3usize],
    #[doc = " Specifies the number of model values present for each intensity interval\n in which the film grain has been modelled, with a range of [1, 6]."]
    pub num_model_values: [u8; 3usize],
    #[doc = " Specifies the lower ounds of each intensity interval for whichthe set of\n model values applies for the component."]
    pub intensity_interval_lower_bound: [[u8; 256usize]; 3usize],
    #[doc = " Specifies the upper bound of each intensity interval for which the set of\n model values applies for the component."]
    pub intensity_interval_upper_bound: [[u8; 256usize]; 3usize],
    #[doc = " Specifies the model values for the component for each intensity interval.\n - When model_id == 0, the following applies:\n     For comp_model_value[y], the range of values is [0, 2^bit_depth_luma - 1]\n     For comp_model_value[cb..cr], the range of values is [0, 2^bit_depth_chroma - 1]\n - Otherwise, the following applies:\n     For comp_model_value[y], the range of values is [-2^(bit_depth_luma - 1), 2^(bit_depth_luma - 1) - 1]\n     For comp_model_value[cb..cr], the range of values is [-2^(bit_depth_chroma - 1), 2^(bit_depth_chroma - 1) - 1]"]
    pub comp_model_value: [[[i16; 6usize]; 256usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVFilmGrainH274Params() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilmGrainH274Params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilmGrainH274Params>(),
        10812usize,
        concat!("Size of: ", stringify!(AVFilmGrainH274Params))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilmGrainH274Params>(),
        4usize,
        concat!("Alignment of ", stringify!(AVFilmGrainH274Params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(model_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_luma) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(bit_depth_luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_chroma) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(bit_depth_chroma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_trc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_space) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blending_mode_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(blending_mode_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_scale_factor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(log2_scale_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_model_present) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(component_model_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_intensity_intervals) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(num_intensity_intervals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_model_values) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(num_model_values)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).intensity_interval_lower_bound) as usize - ptr as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(intensity_interval_lower_bound)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).intensity_interval_upper_bound) as usize - ptr as usize
        },
        825usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(intensity_interval_upper_bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_model_value) as usize - ptr as usize },
        1594usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainH274Params),
            "::",
            stringify!(comp_model_value)
        )
    );
}
#[doc = " This structure describes how to handle film grain synthesis in video\n for specific codecs. Must be present on every frame where film grain is\n meant to be synthesised for correct presentation.\n\n @note The struct must be allocated with av_film_grain_params_alloc() and\n       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilmGrainParams {
    #[doc = " Specifies the codec for which this structure is valid."]
    pub type_: AVFilmGrainParamsType,
    #[doc = " Seed to use for the synthesis process, if the codec allows for it.\n\n @note For H.264, this refers to `pic_offset` as defined in\n       SMPTE RDD 5-2006."]
    pub seed: u64,
    pub codec: AVFilmGrainParams__bindgen_ty_1,
}
#[doc = " Additional fields may be added both here and in any structure included.\n If a codec's film grain structure differs slightly over another\n codec's, fields within may change meaning depending on the type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVFilmGrainParams__bindgen_ty_1 {
    pub aom: AVFilmGrainAOMParams,
    pub h274: AVFilmGrainH274Params,
}
#[test]
fn bindgen_test_layout_AVFilmGrainParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilmGrainParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilmGrainParams__bindgen_ty_1>(),
        10812usize,
        concat!("Size of: ", stringify!(AVFilmGrainParams__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilmGrainParams__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AVFilmGrainParams__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainParams__bindgen_ty_1),
            "::",
            stringify!(aom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h274) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainParams__bindgen_ty_1),
            "::",
            stringify!(h274)
        )
    );
}
impl ::std::fmt::Debug for AVFilmGrainParams__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "AVFilmGrainParams__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_AVFilmGrainParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVFilmGrainParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVFilmGrainParams>(),
        10832usize,
        concat!("Size of: ", stringify!(AVFilmGrainParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilmGrainParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilmGrainParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainParams),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilmGrainParams),
            "::",
            stringify!(codec)
        )
    );
}
impl ::std::fmt::Debug for AVFilmGrainParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "AVFilmGrainParams {{ type: {:?}, seed: {:?}, codec: {:?} }}",
            self.type_, self.seed, self.codec
        )
    }
}
extern "C" {
    #[doc = " Allocate an AVFilmGrainParams structure and set its fields to\n default values. The resulting struct can be freed using av_freep().\n If size is not NULL it will be set to the number of bytes allocated.\n\n @return An AVFilmGrainParams filled with default values or NULL\n         on failure."]
    pub fn av_film_grain_params_alloc(size: *mut usize) -> *mut AVFilmGrainParams;
}
extern "C" {
    #[doc = " Allocate a complete AVFilmGrainParams and add it to the frame.\n\n @param frame The frame which side data is added to.\n\n @return The AVFilmGrainParams structure to be filled by caller."]
    pub fn av_film_grain_params_create_side_data(frame: *mut AVFrame) -> *mut AVFilmGrainParams;
}
#[doc = " @example ffhash.c\n This example is a simple command line application that takes one or more\n arguments. It demonstrates a typical use of the hashing API with allocation,\n initialization, updating, and finalizing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHashContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a hash context for the algorithm specified by name.\n\n @return  >= 0 for success, a negative error code for failure\n\n @note The context is not initialized after a call to this function; you must\n call av_hash_init() to do so."]
    pub fn av_hash_alloc(
        ctx: *mut *mut AVHashContext,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the names of available hash algorithms.\n\n This function can be used to enumerate the algorithms.\n\n @param[in] i  Index of the hash algorithm, starting from 0\n @return       Pointer to a static string or `NULL` if `i` is out of range"]
    pub fn av_hash_names(i: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the algorithm corresponding to the given hash context."]
    pub fn av_hash_get_name(ctx: *const AVHashContext) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the size of the resulting hash value in bytes.\n\n The maximum value this function will currently return is available as macro\n #AV_HASH_MAX_SIZE.\n\n @param[in]     ctx Hash context\n @return            Size of the hash value in bytes"]
    pub fn av_hash_get_size(ctx: *const AVHashContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize or reset a hash context.\n\n @param[in,out] ctx Hash context"]
    pub fn av_hash_init(ctx: *mut AVHashContext);
}
extern "C" {
    #[doc = " Update a hash context with additional data.\n\n @param[in,out] ctx Hash context\n @param[in]     src Data to be added to the hash context\n @param[in]     len Size of the additional data"]
    pub fn av_hash_update(ctx: *mut AVHashContext, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finalize a hash context and compute the actual hash value.\n\n The minimum size of `dst` buffer is given by av_hash_get_size() or\n #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n @param[in,out] ctx Hash context\n @param[out]    dst Where the final hash value will be stored\n\n @see av_hash_final_bin() provides an alternative API"]
    pub fn av_hash_final(ctx: *mut AVHashContext, dst: *mut u8);
}
extern "C" {
    #[doc = " Finalize a hash context and store the actual hash value in a buffer.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n If `size` is smaller than the hash size (given by av_hash_get_size()), the\n hash is truncated; if size is larger, the buffer is padded with 0.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the final hash value will be stored\n @param[in]     size Number of bytes to write to `dst`"]
    pub fn av_hash_final_bin(ctx: *mut AVHashContext, dst: *mut u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the hexadecimal representation of the\n actual hash value as a string.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n The string is always 0-terminated.\n\n If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the\n value returned by av_hash_get_size(), the string will be truncated.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the string will be stored\n @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_hex(ctx: *mut AVHashContext, dst: *mut u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Finalize a hash context and store the Base64 representation of the\n actual hash value as a string.\n\n It is not safe to update or finalize a hash context again, if it has already\n been finalized.\n\n The string is always 0-terminated.\n\n If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is\n the value returned by av_hash_get_size(), the string will be truncated.\n\n @param[in,out] ctx  Hash context\n @param[out]    dst  Where the final hash value will be stored\n @param[in]     size Maximum number of bytes to write to `dst`"]
    pub fn av_hash_final_b64(ctx: *mut AVHashContext, dst: *mut u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Free hash context and set hash context pointer to `NULL`.\n\n @param[in,out] ctx  Pointer to hash context"]
    pub fn av_hash_freep(ctx: *mut *mut AVHashContext);
}
pub const AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING: AVHDRPlusOverlapProcessOption = 0;
pub const AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING: AVHDRPlusOverlapProcessOption = 1;
#[doc = " Option for overlapping elliptical pixel selectors in an image."]
pub type AVHDRPlusOverlapProcessOption = ::std::os::raw::c_uint;
#[doc = " Represents the percentile at a specific percentage in\n a distribution."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHDRPlusPercentile {
    #[doc = " The percentage value corresponding to a specific percentile linearized\n RGB value in the processing window in the scene. The value shall be in\n the range of 0 to100, inclusive."]
    pub percentage: u8,
    #[doc = " The linearized maxRGB value at a specific percentile in the processing\n window in the scene. The value shall be in the range of 0 to 1, inclusive\n and in multiples of 0.00001."]
    pub percentile: AVRational,
}
#[test]
fn bindgen_test_layout_AVHDRPlusPercentile() {
    const UNINIT: ::std::mem::MaybeUninit<AVHDRPlusPercentile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHDRPlusPercentile>(),
        12usize,
        concat!("Size of: ", stringify!(AVHDRPlusPercentile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHDRPlusPercentile>(),
        4usize,
        concat!("Alignment of ", stringify!(AVHDRPlusPercentile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusPercentile),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusPercentile),
            "::",
            stringify!(percentile)
        )
    );
}
#[doc = " Color transform parameters at a processing window in a dynamic metadata for\n SMPTE 2094-40."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHDRPlusColorTransformParams {
    #[doc = " The relative x coordinate of the top left pixel of the processing\n window. The value shall be in the range of 0 and 1, inclusive and\n in multiples of 1/(width of Picture - 1). The value 1 corresponds\n to the absolute coordinate of width of Picture - 1. The value for\n first processing window shall be 0."]
    pub window_upper_left_corner_x: AVRational,
    #[doc = " The relative y coordinate of the top left pixel of the processing\n window. The value shall be in the range of 0 and 1, inclusive and\n in multiples of 1/(height of Picture - 1). The value 1 corresponds\n to the absolute coordinate of height of Picture - 1. The value for\n first processing window shall be 0."]
    pub window_upper_left_corner_y: AVRational,
    #[doc = " The relative x coordinate of the bottom right pixel of the processing\n window. The value shall be in the range of 0 and 1, inclusive and\n in multiples of 1/(width of Picture - 1). The value 1 corresponds\n to the absolute coordinate of width of Picture - 1. The value for\n first processing window shall be 1."]
    pub window_lower_right_corner_x: AVRational,
    #[doc = " The relative y coordinate of the bottom right pixel of the processing\n window. The value shall be in the range of 0 and 1, inclusive and\n in multiples of 1/(height of Picture - 1). The value 1 corresponds\n to the absolute coordinate of height of Picture - 1. The value for\n first processing window shall be 1."]
    pub window_lower_right_corner_y: AVRational,
    #[doc = " The x coordinate of the center position of the concentric internal and\n external ellipses of the elliptical pixel selector in the processing\n window. The value shall be in the range of 0 to (width of Picture - 1),\n inclusive and in multiples of 1 pixel."]
    pub center_of_ellipse_x: u16,
    #[doc = " The y coordinate of the center position of the concentric internal and\n external ellipses of the elliptical pixel selector in the processing\n window. The value shall be in the range of 0 to (height of Picture - 1),\n inclusive and in multiples of 1 pixel."]
    pub center_of_ellipse_y: u16,
    #[doc = " The clockwise rotation angle in degree of arc with respect to the\n positive direction of the x-axis of the concentric internal and external\n ellipses of the elliptical pixel selector in the processing window. The\n value shall be in the range of 0 to 180, inclusive and in multiples of 1."]
    pub rotation_angle: u8,
    #[doc = " The semi-major axis value of the internal ellipse of the elliptical pixel\n selector in amount of pixels in the processing window. The value shall be\n in the range of 1 to 65535, inclusive and in multiples of 1 pixel."]
    pub semimajor_axis_internal_ellipse: u16,
    #[doc = " The semi-major axis value of the external ellipse of the elliptical pixel\n selector in amount of pixels in the processing window. The value\n shall not be less than semimajor_axis_internal_ellipse of the current\n processing window. The value shall be in the range of 1 to 65535,\n inclusive and in multiples of 1 pixel."]
    pub semimajor_axis_external_ellipse: u16,
    #[doc = " The semi-minor axis value of the external ellipse of the elliptical pixel\n selector in amount of pixels in the processing window. The value shall be\n in the range of 1 to 65535, inclusive and in multiples of 1 pixel."]
    pub semiminor_axis_external_ellipse: u16,
    #[doc = " Overlap process option indicates one of the two methods of combining\n rendered pixels in the processing window in an image with at least one\n elliptical pixel selector. For overlapping elliptical pixel selectors\n in an image, overlap_process_option shall have the same value."]
    pub overlap_process_option: AVHDRPlusOverlapProcessOption,
    #[doc = " The maximum of the color components of linearized RGB values in the\n processing window in the scene. The values should be in the range of 0 to\n 1, inclusive and in multiples of 0.00001. maxscl[ 0 ], maxscl[ 1 ], and\n maxscl[ 2 ] are corresponding to R, G, B color components respectively."]
    pub maxscl: [AVRational; 3usize],
    #[doc = " The average of linearized maxRGB values in the processing window in the\n scene. The value should be in the range of 0 to 1, inclusive and in\n multiples of 0.00001."]
    pub average_maxrgb: AVRational,
    #[doc = " The number of linearized maxRGB values at given percentiles in the\n processing window in the scene. The maximum value shall be 15."]
    pub num_distribution_maxrgb_percentiles: u8,
    #[doc = " The linearized maxRGB values at given percentiles in the\n processing window in the scene."]
    pub distribution_maxrgb: [AVHDRPlusPercentile; 15usize],
    #[doc = " The fraction of selected pixels in the image that contains the brightest\n pixel in the scene. The value shall be in the range of 0 to 1, inclusive\n and in multiples of 0.001."]
    pub fraction_bright_pixels: AVRational,
    #[doc = " This flag indicates that the metadata for the tone mapping function in\n the processing window is present (for value of 1)."]
    pub tone_mapping_flag: u8,
    #[doc = " The x coordinate of the separation point between the linear part and the\n curved part of the tone mapping function. The value shall be in the range\n of 0 to 1, excluding 0 and in multiples of 1/4095."]
    pub knee_point_x: AVRational,
    #[doc = " The y coordinate of the separation point between the linear part and the\n curved part of the tone mapping function. The value shall be in the range\n of 0 to 1, excluding 0 and in multiples of 1/4095."]
    pub knee_point_y: AVRational,
    #[doc = " The number of the intermediate anchor parameters of the tone mapping\n function in the processing window. The maximum value shall be 15."]
    pub num_bezier_curve_anchors: u8,
    #[doc = " The intermediate anchor parameters of the tone mapping function in the\n processing window in the scene. The values should be in the range of 0\n to 1, inclusive and in multiples of 1/1023."]
    pub bezier_curve_anchors: [AVRational; 15usize],
    #[doc = " This flag shall be equal to 0 in bitstreams conforming to this version of\n this Specification. Other values are reserved for future use."]
    pub color_saturation_mapping_flag: u8,
    #[doc = " The color saturation gain in the processing window in the scene. The\n value shall be in the range of 0 to 63/8, inclusive and in multiples of\n 1/8. The default value shall be 1."]
    pub color_saturation_weight: AVRational,
}
#[test]
fn bindgen_test_layout_AVHDRPlusColorTransformParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVHDRPlusColorTransformParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHDRPlusColorTransformParams>(),
        428usize,
        concat!("Size of: ", stringify!(AVHDRPlusColorTransformParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHDRPlusColorTransformParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AVHDRPlusColorTransformParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_upper_left_corner_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(window_upper_left_corner_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_upper_left_corner_y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(window_upper_left_corner_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_lower_right_corner_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(window_lower_right_corner_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_lower_right_corner_y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(window_lower_right_corner_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_of_ellipse_x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(center_of_ellipse_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center_of_ellipse_y) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(center_of_ellipse_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation_angle) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(rotation_angle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).semimajor_axis_internal_ellipse) as usize - ptr as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(semimajor_axis_internal_ellipse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).semimajor_axis_external_ellipse) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(semimajor_axis_external_ellipse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).semiminor_axis_external_ellipse) as usize - ptr as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(semiminor_axis_external_ellipse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlap_process_option) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(overlap_process_option)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxscl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(maxscl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_maxrgb) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(average_maxrgb)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_distribution_maxrgb_percentiles) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(num_distribution_maxrgb_percentiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distribution_maxrgb) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(distribution_maxrgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fraction_bright_pixels) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(fraction_bright_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_mapping_flag) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(tone_mapping_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).knee_point_x) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(knee_point_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).knee_point_y) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(knee_point_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bezier_curve_anchors) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(num_bezier_curve_anchors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bezier_curve_anchors) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(bezier_curve_anchors)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).color_saturation_mapping_flag) as usize - ptr as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(color_saturation_mapping_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_saturation_weight) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRPlusColorTransformParams),
            "::",
            stringify!(color_saturation_weight)
        )
    );
}
#[doc = " This struct represents dynamic metadata for color volume transform -\n application 4 of SMPTE 2094-40:2016 standard.\n\n To be used as payload of a AVFrameSideData or AVPacketSideData with the\n appropriate type.\n\n @note The struct should be allocated with\n av_dynamic_hdr_plus_alloc() and its size is not a part of\n the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDynamicHDRPlus {
    #[doc = " Country code by Rec. ITU-T T.35 Annex A. The value shall be 0xB5."]
    pub itu_t_t35_country_code: u8,
    #[doc = " Application version in the application defining document in ST-2094\n suite. The value shall be set to 0."]
    pub application_version: u8,
    #[doc = " The number of processing windows. The value shall be in the range\n of 1 to 3, inclusive."]
    pub num_windows: u8,
    #[doc = " The color transform parameters for every processing window."]
    pub params: [AVHDRPlusColorTransformParams; 3usize],
    #[doc = " The nominal maximum display luminance of the targeted system display,\n in units of 0.0001 candelas per square metre. The value shall be in\n the range of 0 to 10000, inclusive."]
    pub targeted_system_display_maximum_luminance: AVRational,
    #[doc = " This flag shall be equal to 0 in bit streams conforming to this version\n of this Specification. The value 1 is reserved for future use."]
    pub targeted_system_display_actual_peak_luminance_flag: u8,
    #[doc = " The number of rows in the targeted system_display_actual_peak_luminance\n array. The value shall be in the range of 2 to 25, inclusive."]
    pub num_rows_targeted_system_display_actual_peak_luminance: u8,
    #[doc = " The number of columns in the\n targeted_system_display_actual_peak_luminance array. The value shall be\n in the range of 2 to 25, inclusive."]
    pub num_cols_targeted_system_display_actual_peak_luminance: u8,
    #[doc = " The normalized actual peak luminance of the targeted system display. The\n values should be in the range of 0 to 1, inclusive and in multiples of\n 1/15."]
    pub targeted_system_display_actual_peak_luminance: [[AVRational; 25usize]; 25usize],
    #[doc = " This flag shall be equal to 0 in bitstreams conforming to this version of\n this Specification. The value 1 is reserved for future use."]
    pub mastering_display_actual_peak_luminance_flag: u8,
    #[doc = " The number of rows in the mastering_display_actual_peak_luminance array.\n The value shall be in the range of 2 to 25, inclusive."]
    pub num_rows_mastering_display_actual_peak_luminance: u8,
    #[doc = " The number of columns in the mastering_display_actual_peak_luminance\n array. The value shall be in the range of 2 to 25, inclusive."]
    pub num_cols_mastering_display_actual_peak_luminance: u8,
    #[doc = " The normalized actual peak luminance of the mastering display used for\n mastering the image essence. The values should be in the range of 0 to 1,\n inclusive and in multiples of 1/15."]
    pub mastering_display_actual_peak_luminance: [[AVRational; 25usize]; 25usize],
}
#[test]
fn bindgen_test_layout_AVDynamicHDRPlus() {
    const UNINIT: ::std::mem::MaybeUninit<AVDynamicHDRPlus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDynamicHDRPlus>(),
        11304usize,
        concat!("Size of: ", stringify!(AVDynamicHDRPlus))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDynamicHDRPlus>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDynamicHDRPlus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itu_t_t35_country_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(itu_t_t35_country_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(application_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_windows) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(num_windows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).targeted_system_display_maximum_luminance) as usize
                - ptr as usize
        },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(targeted_system_display_maximum_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).targeted_system_display_actual_peak_luminance_flag) as usize
                - ptr as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(targeted_system_display_actual_peak_luminance_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_rows_targeted_system_display_actual_peak_luminance)
                as usize
                - ptr as usize
        },
        1297usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(num_rows_targeted_system_display_actual_peak_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_cols_targeted_system_display_actual_peak_luminance)
                as usize
                - ptr as usize
        },
        1298usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(num_cols_targeted_system_display_actual_peak_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).targeted_system_display_actual_peak_luminance) as usize
                - ptr as usize
        },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(targeted_system_display_actual_peak_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).mastering_display_actual_peak_luminance_flag) as usize
                - ptr as usize
        },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(mastering_display_actual_peak_luminance_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_rows_mastering_display_actual_peak_luminance) as usize
                - ptr as usize
        },
        6301usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(num_rows_mastering_display_actual_peak_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_cols_mastering_display_actual_peak_luminance) as usize
                - ptr as usize
        },
        6302usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(num_cols_mastering_display_actual_peak_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).mastering_display_actual_peak_luminance) as usize
                - ptr as usize
        },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRPlus),
            "::",
            stringify!(mastering_display_actual_peak_luminance)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVDynamicHDRPlus structure and set its fields to\n default values. The resulting struct can be freed using av_freep().\n\n @return An AVDynamicHDRPlus filled with default values or NULL\n         on failure."]
    pub fn av_dynamic_hdr_plus_alloc(size: *mut usize) -> *mut AVDynamicHDRPlus;
}
extern "C" {
    #[doc = " Allocate a complete AVDynamicHDRPlus and add it to the frame.\n @param frame The frame which side data is added to.\n\n @return The AVDynamicHDRPlus structure to be filled by caller or NULL\n         on failure."]
    pub fn av_dynamic_hdr_plus_create_side_data(frame: *mut AVFrame) -> *mut AVDynamicHDRPlus;
}
extern "C" {
    #[doc = " Parse the user data registered ITU-T T.35 to AVbuffer (AVDynamicHDRPlus).\n The T.35 buffer must begin with the application mode, skipping the\n country code, terminal provider codes, and application identifier.\n @param s A pointer containing the decoded AVDynamicHDRPlus structure.\n @param data The byte array containing the raw ITU-T T.35 data.\n @param size Size of the data array in bytes.\n\n @return >= 0 on success. Otherwise, returns the appropriate AVERROR."]
    pub fn av_dynamic_hdr_plus_from_t35(
        s: *mut AVDynamicHDRPlus,
        data: *const u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer,\n excluding the first 48 bytes of the header, and beginning with the application mode.\n @param s A pointer containing the decoded AVDynamicHDRPlus structure.\n @param data[in,out] A pointer to pointer to a byte buffer to be filled with the\n                     serialized metadata.\n                     If *data is NULL, a buffer be will be allocated and a pointer to\n                     it stored in its place. The caller assumes ownership of the buffer.\n                     May be NULL, in which case the function will only store the\n                     required buffer size in *size.\n @param size[in,out] A pointer to a size to be set to the returned buffer's size.\n                     If *data is not NULL, *size must contain the size of the input\n                     buffer. May be NULL only if *data is NULL.\n\n @return >= 0 on success. Otherwise, returns the appropriate AVERROR."]
    pub fn av_dynamic_hdr_plus_to_t35(
        s: *const AVDynamicHDRPlus,
        data: *mut *mut u8,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " HDR Vivid three spline params."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHDRVivid3SplineParams {
    #[doc = " The mode of three Spline. the value shall be in the range\n of 0 to 3, inclusive."]
    pub th_mode: ::std::os::raw::c_int,
    #[doc = " three_Spline_TH_enable_MB is in the range of 0.0 to 1.0, inclusive\n and in multiples of 1.0/255.\n"]
    pub th_enable_mb: AVRational,
    #[doc = " 3Spline_TH_enable of three Spline.\n The value shall be in the range of 0.0 to 1.0, inclusive.\n and in multiples of 1.0/4095."]
    pub th_enable: AVRational,
    #[doc = " 3Spline_TH_Delta1 of three Spline.\n The value shall be in the range of 0.0 to 0.25, inclusive,\n and in multiples of 0.25/1023."]
    pub th_delta1: AVRational,
    #[doc = " 3Spline_TH_Delta2 of three Spline.\n The value shall be in the range of 0.0 to 0.25, inclusive,\n and in multiples of 0.25/1023."]
    pub th_delta2: AVRational,
    #[doc = " 3Spline_enable_Strength of three Spline.\n The value shall be in the range of 0.0 to 1.0, inclusive,\n and in multiples of 1.0/255."]
    pub enable_strength: AVRational,
}
#[test]
fn bindgen_test_layout_AVHDRVivid3SplineParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVHDRVivid3SplineParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHDRVivid3SplineParams>(),
        44usize,
        concat!("Size of: ", stringify!(AVHDRVivid3SplineParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHDRVivid3SplineParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AVHDRVivid3SplineParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(th_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_enable_mb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(th_enable_mb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_enable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(th_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_delta1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(th_delta1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_delta2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(th_delta2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_strength) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVivid3SplineParams),
            "::",
            stringify!(enable_strength)
        )
    );
}
#[doc = " Color tone mapping parameters at a processing window in a dynamic metadata for\n CUVA 005.1:2021."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHDRVividColorToneMappingParams {
    #[doc = " The nominal maximum display luminance of the targeted system display,\n in multiples of 1.0/4095 candelas per square metre. The value shall be in\n the range of 0.0 to 1.0, inclusive."]
    pub targeted_system_display_maximum_luminance: AVRational,
    #[doc = " This flag indicates that transfer the base paramter(for value of 1)"]
    pub base_enable_flag: ::std::os::raw::c_int,
    #[doc = " base_param_m_p in the base parameter,\n in multiples of 1.0/16383. The value shall be in\n the range of 0.0 to 1.0, inclusive."]
    pub base_param_m_p: AVRational,
    #[doc = " base_param_m_m in the base parameter,\n in multiples of 1.0/10. The value shall be in\n the range of 0.0 to 6.3, inclusive."]
    pub base_param_m_m: AVRational,
    #[doc = " base_param_m_a in the base parameter,\n in multiples of 1.0/1023. The value shall be in\n the range of 0.0 to 1.0 inclusive."]
    pub base_param_m_a: AVRational,
    #[doc = " base_param_m_b in the base parameter,\n in multiples of 1/1023. The value shall be in\n the range of 0.0 to 1.0, inclusive."]
    pub base_param_m_b: AVRational,
    #[doc = " base_param_m_n in the base parameter,\n in multiples of 1.0/10. The value shall be in\n the range of 0.0 to 6.3, inclusive."]
    pub base_param_m_n: AVRational,
    #[doc = " indicates k1_0 in the base parameter,\n base_param_k1 <= 1: k1_0 = base_param_k1\n base_param_k1 > 1: reserved"]
    pub base_param_k1: ::std::os::raw::c_int,
    #[doc = " indicates k2_0 in the base parameter,\n base_param_k2 <= 1: k2_0 = base_param_k2\n base_param_k2 > 1: reserved"]
    pub base_param_k2: ::std::os::raw::c_int,
    #[doc = " indicates k3_0 in the base parameter,\n base_param_k3 == 1: k3_0 = base_param_k3\n base_param_k3 == 2: k3_0 = maximum_maxrgb\n base_param_k3 > 2: reserved"]
    pub base_param_k3: ::std::os::raw::c_int,
    #[doc = " This flag indicates that delta mode of base paramter(for value of 1)"]
    pub base_param_Delta_enable_mode: ::std::os::raw::c_int,
    #[doc = " base_param_Delta in the base parameter,\n in multiples of 1.0/127. The value shall be in\n the range of 0.0 to 1.0, inclusive."]
    pub base_param_Delta: AVRational,
    #[doc = " indicates 3Spline_enable_flag in the base parameter,\n This flag indicates that transfer three Spline of base paramter(for value of 1)"]
    pub three_Spline_enable_flag: ::std::os::raw::c_int,
    #[doc = " The number of three Spline. The value shall be in the range\n of 1 to 2, inclusive."]
    pub three_Spline_num: ::std::os::raw::c_int,
    #[doc = " The mode of three Spline. the value shall be in the range\n of 0 to 3, inclusive.\n @deprecated Use three_spline instead"]
    pub three_Spline_TH_mode: ::std::os::raw::c_int,
    #[doc = " three_Spline_TH_enable_MB is in the range of 0.0 to 1.0, inclusive\n and in multiples of 1.0/255.\n @deprecated Use three_spline instead"]
    pub three_Spline_TH_enable_MB: AVRational,
    #[doc = " 3Spline_TH_enable of three Spline.\n The value shall be in the range of 0.0 to 1.0, inclusive.\n and in multiples of 1.0/4095.\n @deprecated Use three_spline instead"]
    pub three_Spline_TH_enable: AVRational,
    #[doc = " 3Spline_TH_Delta1 of three Spline.\n The value shall be in the range of 0.0 to 0.25, inclusive,\n and in multiples of 0.25/1023.\n @deprecated Use three_spline instead"]
    pub three_Spline_TH_Delta1: AVRational,
    #[doc = " 3Spline_TH_Delta2 of three Spline.\n The value shall be in the range of 0.0 to 0.25, inclusive,\n and in multiples of 0.25/1023.\n @deprecated Use three_spline instead"]
    pub three_Spline_TH_Delta2: AVRational,
    #[doc = " 3Spline_enable_Strength of three Spline.\n The value shall be in the range of 0.0 to 1.0, inclusive,\n and in multiples of 1.0/255.\n @deprecated Use three_spline instead"]
    pub three_Spline_enable_Strength: AVRational,
    pub three_spline: [AVHDRVivid3SplineParams; 2usize],
}
#[test]
fn bindgen_test_layout_AVHDRVividColorToneMappingParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVHDRVividColorToneMappingParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHDRVividColorToneMappingParams>(),
        216usize,
        concat!("Size of: ", stringify!(AVHDRVividColorToneMappingParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHDRVividColorToneMappingParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AVHDRVividColorToneMappingParams)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).targeted_system_display_maximum_luminance) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(targeted_system_display_maximum_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_enable_flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_enable_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_m_p) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_m_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_m_m) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_m_m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_m_a) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_m_a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_m_b) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_m_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_m_n) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_m_n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_k1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_k1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_k2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_k2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_k3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_k3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).base_param_Delta_enable_mode) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_Delta_enable_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_param_Delta) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(base_param_Delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_enable_flag) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_enable_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_num) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_TH_mode) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_TH_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_TH_enable_MB) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_TH_enable_MB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_TH_enable) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_TH_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_TH_Delta1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_TH_Delta1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_Spline_TH_Delta2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_TH_Delta2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).three_Spline_enable_Strength) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_Spline_enable_Strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).three_spline) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorToneMappingParams),
            "::",
            stringify!(three_spline)
        )
    );
}
#[doc = " Color transform parameters at a processing window in a dynamic metadata for\n CUVA 005.1:2021."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHDRVividColorTransformParams {
    #[doc = " Indicates the minimum brightness of the displayed content.\n The values should be in the range of 0.0 to 1.0,\n inclusive and in multiples of 1/4095."]
    pub minimum_maxrgb: AVRational,
    #[doc = " Indicates the average brightness of the displayed content.\n The values should be in the range of 0.0 to 1.0,\n inclusive and in multiples of 1/4095."]
    pub average_maxrgb: AVRational,
    #[doc = " Indicates the variance brightness of the displayed content.\n The values should be in the range of 0.0 to 1.0,\n inclusive and in multiples of 1/4095."]
    pub variance_maxrgb: AVRational,
    #[doc = " Indicates the maximum brightness of the displayed content.\n The values should be in the range of 0.0 to 1.0, inclusive\n and in multiples of 1/4095."]
    pub maximum_maxrgb: AVRational,
    #[doc = " This flag indicates that the metadata for the tone mapping function in\n the processing window is present (for value of 1)."]
    pub tone_mapping_mode_flag: ::std::os::raw::c_int,
    #[doc = " The number of tone mapping param. The value shall be in the range\n of 1 to 2, inclusive."]
    pub tone_mapping_param_num: ::std::os::raw::c_int,
    #[doc = " The color tone mapping parameters."]
    pub tm_params: [AVHDRVividColorToneMappingParams; 2usize],
    #[doc = " This flag indicates that the metadata for the color saturation mapping in\n the processing window is present (for value of 1)."]
    pub color_saturation_mapping_flag: ::std::os::raw::c_int,
    #[doc = " The number of color saturation param. The value shall be in the range\n of 0 to 7, inclusive."]
    pub color_saturation_num: ::std::os::raw::c_int,
    #[doc = " Indicates the color correction strength parameter.\n The values should be in the range of 0.0 to 2.0, inclusive\n and in multiples of 1/128."]
    pub color_saturation_gain: [AVRational; 8usize],
}
#[test]
fn bindgen_test_layout_AVHDRVividColorTransformParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVHDRVividColorTransformParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVHDRVividColorTransformParams>(),
        544usize,
        concat!("Size of: ", stringify!(AVHDRVividColorTransformParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHDRVividColorTransformParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AVHDRVividColorTransformParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum_maxrgb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(minimum_maxrgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_maxrgb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(average_maxrgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).variance_maxrgb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(variance_maxrgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum_maxrgb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(maximum_maxrgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_mapping_mode_flag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(tone_mapping_mode_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_mapping_param_num) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(tone_mapping_param_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(tm_params)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).color_saturation_mapping_flag) as usize - ptr as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(color_saturation_mapping_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_saturation_num) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(color_saturation_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_saturation_gain) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHDRVividColorTransformParams),
            "::",
            stringify!(color_saturation_gain)
        )
    );
}
#[doc = " This struct represents dynamic metadata for color volume transform -\n CUVA 005.1:2021 standard\n\n To be used as payload of a AVFrameSideData or AVPacketSideData with the\n appropriate type.\n\n @note The struct should be allocated with\n av_dynamic_hdr_vivid_alloc() and its size is not a part of\n the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDynamicHDRVivid {
    #[doc = " The system start code. The value shall be set to 0x01."]
    pub system_start_code: u8,
    #[doc = " The number of processing windows. The value shall be set to 0x01\n if the system_start_code is 0x01."]
    pub num_windows: u8,
    #[doc = " The color transform parameters for every processing window."]
    pub params: [AVHDRVividColorTransformParams; 3usize],
}
#[test]
fn bindgen_test_layout_AVDynamicHDRVivid() {
    const UNINIT: ::std::mem::MaybeUninit<AVDynamicHDRVivid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVDynamicHDRVivid>(),
        1636usize,
        concat!("Size of: ", stringify!(AVDynamicHDRVivid))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDynamicHDRVivid>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDynamicHDRVivid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_start_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRVivid),
            "::",
            stringify!(system_start_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_windows) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRVivid),
            "::",
            stringify!(num_windows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDynamicHDRVivid),
            "::",
            stringify!(params)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVDynamicHDRVivid structure and set its fields to\n default values. The resulting struct can be freed using av_freep().\n\n @return An AVDynamicHDRVivid filled with default values or NULL\n         on failure."]
    pub fn av_dynamic_hdr_vivid_alloc(size: *mut usize) -> *mut AVDynamicHDRVivid;
}
extern "C" {
    #[doc = " Allocate a complete AVDynamicHDRVivid and add it to the frame.\n @param frame The frame which side data is added to.\n\n @return The AVDynamicHDRVivid structure to be filled by caller or NULL\n         on failure."]
    pub fn av_dynamic_hdr_vivid_create_side_data(frame: *mut AVFrame) -> *mut AVDynamicHDRVivid;
}
pub const AV_HMAC_MD5: AVHMACType = 0;
pub const AV_HMAC_SHA1: AVHMACType = 1;
pub const AV_HMAC_SHA224: AVHMACType = 2;
pub const AV_HMAC_SHA256: AVHMACType = 3;
pub const AV_HMAC_SHA384: AVHMACType = 4;
pub const AV_HMAC_SHA512: AVHMACType = 5;
#[doc = " @defgroup lavu_hmac HMAC\n @ingroup lavu_crypto\n @{"]
pub type AVHMACType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHMAC {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVHMAC context.\n @param type The hash function used for the HMAC."]
    pub fn av_hmac_alloc(type_: AVHMACType) -> *mut AVHMAC;
}
extern "C" {
    #[doc = " Free an AVHMAC context.\n @param ctx The context to free, may be NULL"]
    pub fn av_hmac_free(ctx: *mut AVHMAC);
}
extern "C" {
    #[doc = " Initialize an AVHMAC context with an authentication key.\n @param ctx    The HMAC context\n @param key    The authentication key\n @param keylen The length of the key, in bytes"]
    pub fn av_hmac_init(ctx: *mut AVHMAC, key: *const u8, keylen: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Hash data with the HMAC.\n @param ctx  The HMAC context\n @param data The data to hash\n @param len  The length of the data, in bytes"]
    pub fn av_hmac_update(ctx: *mut AVHMAC, data: *const u8, len: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Finish hashing and output the HMAC digest.\n @param ctx    The HMAC context\n @param out    The output buffer to write the digest into\n @param outlen The length of the out buffer, in bytes\n @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_final(
        ctx: *mut AVHMAC,
        out: *mut u8,
        outlen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hash an array of data with a key.\n @param ctx    The HMAC context\n @param data   The data to hash\n @param len    The length of the data, in bytes\n @param key    The authentication key\n @param keylen The length of the key, in bytes\n @param out    The output buffer to write the digest into\n @param outlen The length of the out buffer, in bytes\n @return       The number of bytes written to out, or a negative error code."]
    pub fn av_hmac_calc(
        ctx: *mut AVHMAC,
        data: *const u8,
        len: ::std::os::raw::c_uint,
        key: *const u8,
        keylen: ::std::os::raw::c_uint,
        out: *mut u8,
        outlen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComponentDescriptor {
    #[doc = " Which of the 4 planes contains the component."]
    pub plane: ::std::os::raw::c_int,
    #[doc = " Number of elements between 2 horizontally consecutive pixels.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub step: ::std::os::raw::c_int,
    #[doc = " Number of elements before the component of the first pixel.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub offset: ::std::os::raw::c_int,
    #[doc = " Number of least significant bits that must be shifted away\n to get the value."]
    pub shift: ::std::os::raw::c_int,
    #[doc = " Number of bits in the component."]
    pub depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVComponentDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<AVComponentDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVComponentDescriptor>(),
        20usize,
        concat!("Size of: ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComponentDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " Descriptor that unambiguously describes how the bits of a pixel are\n stored in the up to 4 data planes of an image. It also stores the\n subsampling factors and number of components.\n\n @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV\n       and all the YUV variants) AVPixFmtDescriptor just stores how values\n       are stored not what these values represent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPixFmtDescriptor {
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< The number of components each pixel has, (1-4)"]
    pub nb_components: u8,
    #[doc = " Amount to shift the luma width right to find the chroma width.\n For YV12 this is 1 for example.\n chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_w: u8,
    #[doc = " Amount to shift the luma height right to find the chroma height.\n For YV12 this is 1 for example.\n chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_h: u8,
    #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
    pub flags: u64,
    #[doc = " Parameters that describe how pixels are packed.\n If the format has 1 or 2 components, then luma is 0.\n If the format has 3 or 4 components:\n   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;\n   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.\n\n If present, the Alpha channel is always the last component."]
    pub comp: [AVComponentDescriptor; 4usize],
    #[doc = " Alternative comma-separated names."]
    pub alias: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVPixFmtDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<AVPixFmtDescriptor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVPixFmtDescriptor>(),
        112usize,
        concat!("Size of: ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPixFmtDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_components) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(nb_components)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_chroma_w) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_chroma_h) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(alias)
        )
    );
}
extern "C" {
    #[doc = " Return the number of bits per pixel used by the pixel format\n described by pixdesc. Note that this is not the same as the number\n of bits per sample.\n\n The returned number of bits refers to the number of bits actually\n used for storing the pixel information, that is padding bits are\n not counted."]
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of bits per pixel for the pixel format\n described by pixdesc, including any padding or unused bits."]
    pub fn av_get_padded_bits_per_pixel(
        pixdesc: *const AVPixFmtDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a pixel format descriptor for provided pixel format or NULL if\n this pixel format is unknown."]
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " Iterate over all pixel format descriptors known to libavutil.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc\n is not a valid pointer to a pixel format descriptor."]
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Utility function to access log2_chroma_w log2_chroma_h from\n the pixel format AVPixFmtDescriptor.\n\n @param[in]  pix_fmt the pixel format\n @param[out] h_shift store log2_chroma_w (horizontal/width shift)\n @param[out] v_shift store log2_chroma_h (vertical/height shift)\n\n @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut ::std::os::raw::c_int,
        v_shift: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a\n valid pixel format."]
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color range or NULL if unknown."]
    pub fn av_color_range_name(range: AVColorRange) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorRange value for name or an AVError if not found."]
    pub fn av_color_range_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color primaries or NULL if unknown."]
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
    pub fn av_color_primaries_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color transfer or NULL if unknown."]
    pub fn av_color_transfer_name(
        transfer: AVColorTransferCharacteristic,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
    pub fn av_color_transfer_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color space or NULL if unknown."]
    pub fn av_color_space_name(space: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
    pub fn av_color_space_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided chroma location or NULL if unknown."]
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
    pub fn av_chroma_location_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn av_chroma_location_enum_to_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn av_chroma_location_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Return the pixel format corresponding to name.\n\n If there is no pixel format with name name, then looks for a\n pixel format with the name corresponding to the native endian\n format of name.\n For example in a little-endian system, first looks for \"gray16\",\n then for \"gray16le\".\n\n Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
    pub fn av_get_pix_fmt(name: *const ::std::os::raw::c_char) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is\n unknown.\n\n @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Print in buf the string corresponding to the pixel format with\n number pix_fmt, or a header if pix_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param pix_fmt the number of the pixel format to print the\n corresponding info string, or a negative value to print the\n corresponding header."]
    pub fn av_get_pix_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a line from an image, and write the values of the\n pixel format component c to dst.\n\n @param data the array containing the pointers to the planes of the image\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to read\n @param y the vertical coordinate of the first pixel to read\n @param w the width of the line to read, that is the number of\n values to write to dst\n @param read_pal_component if not zero and the format is a paletted\n format writes the values corresponding to the palette\n component c in data[1] to dst, rather than the palette indexes in\n data[0]. The behavior is undefined if the format is not paletted.\n @param dst_element_size size of elements in dst array (2 or 4 byte)"]
    pub fn av_read_image_line2(
        dst: *mut ::std::os::raw::c_void,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
        dst_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write the values from src to the pixel format component c of an\n image line.\n\n @param src array containing the values to write\n @param data the array containing the pointers to the planes of the\n image to write into. It is supposed to be zeroed.\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to write\n @param y the vertical coordinate of the first pixel to write\n @param w the width of the line to write, that is the number of\n values to write to the image line\n @param src_element_size size of elements in src array (2 or 4 byte)"]
    pub fn av_write_image_line2(
        src: *const ::std::os::raw::c_void,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        src_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Utility function to swap the endianness of a pixel format.\n\n @param[in]  pix_fmt the pixel format\n\n @return pixel format with swapped endianness if it exists,\n otherwise AV_PIX_FMT_NONE"]
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute the max pixel step for each plane of an image with a\n format described by pixdesc.\n\n The pixel step is the distance in bytes between the first byte of\n the group of bytes which describe a pixel component and the first\n byte of the successive group in the same plane for the same\n component.\n\n @param max_pixsteps an array which is filled with the max pixel step\n for each plane. Since a plane may contain different pixel\n components, the computed max_pixsteps[plane] is relative to the\n component in the plane with the max pixel step.\n @param max_pixstep_comps an array which is filled with the component\n for each plane which has the max pixel step. May be NULL.\n @param pixdesc the AVPixFmtDescriptor for the image, describing its format"]
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut ::std::os::raw::c_int,
        max_pixstep_comps: *mut ::std::os::raw::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    #[doc = " Compute the size of an image line with format pix_fmt and width\n width for the plane plane.\n\n @return the computed size in bytes"]
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane linesizes for an image with pixel format pix_fmt and\n width width.\n\n @param linesizes array to be filled with the linesize for each plane\n @param pix_fmt the AVPixelFormat of the image\n @param width width of the image in pixels\n @return >= 0 in case of success, a negative error code otherwise"]
    pub fn av_image_fill_linesizes(
        linesizes: *mut ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane sizes for an image with pixel format pix_fmt and height height.\n\n @param size the array to be filled with the size of each image plane\n @param pix_fmt the AVPixelFormat of the image\n @param height height of the image in pixels\n @param linesizes the array containing the linesize for each\n        plane, should be filled by av_image_fill_linesizes()\n @return >= 0 in case of success, a negative error code otherwise\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_fill_linesizes()."]
    pub fn av_image_fill_plane_sizes(
        size: *mut usize,
        pix_fmt: AVPixelFormat,
        height: ::std::os::raw::c_int,
        linesizes: *const isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers for an image with pixel format pix_fmt and\n height height.\n\n @param data pointers array to be filled with the pointer for each image plane\n @param pix_fmt the AVPixelFormat of the image\n @param height height of the image in pixels\n @param ptr the pointer to a buffer which will contain the image\n @param linesizes the array containing the linesize for each\n plane, should be filled by av_image_fill_linesizes()\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: ::std::os::raw::c_int,
        ptr: *mut u8,
        linesizes: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an image with size w and h and pixel format pix_fmt, and\n fill pointers and linesizes accordingly.\n The allocated image buffer has to be freed by using\n av_freep(&pointers[0]).\n\n @param pointers array to be filled with the pointer for each image plane\n @param linesizes the array filled with the linesize for each plane\n @param w width of the image in pixels\n @param h height of the image in pixels\n @param pix_fmt the AVPixelFormat of the image\n @param align the value to use for buffer size alignment\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy image plane from src to dst.\n That is, copy \"height\" number of lines of \"bytewidth\" bytes each.\n The first byte of each successive line is separated by *_linesize\n bytes.\n\n bytewidth must be contained by both absolute values of dst_linesize\n and src_linesize, otherwise the function behavior is undefined.\n\n @param dst          destination plane to copy to\n @param dst_linesize linesize for the image plane in dst\n @param src          source plane to copy from\n @param src_linesize linesize for the image plane in src\n @param height       height (number of lines) of the plane"]
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: ::std::os::raw::c_int,
        src: *const u8,
        src_linesize: ::std::os::raw::c_int,
        bytewidth: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n available, this function will use special functionality for reading from such\n memory, which may result in greatly improved performance compared to plain\n av_image_copy_plane().\n\n bytewidth must be contained by both absolute values of dst_linesize\n and src_linesize, otherwise the function behavior is undefined.\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_copy_plane().\n @note On x86, the linesizes currently need to be aligned to the cacheline\n       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_plane_uc_from(
        dst: *mut u8,
        dst_linesize: isize,
        src: *const u8,
        src_linesize: isize,
        bytewidth: isize,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image in src_data to dst_data.\n\n @param dst_data      destination image data buffer to copy to\n @param dst_linesizes linesizes for the image in dst_data\n @param src_data      source image data buffer to copy from\n @param src_linesizes linesizes for the image in src_data\n @param pix_fmt       the AVPixelFormat of the image\n @param width         width of the image in pixels\n @param height        height of the image in pixels"]
    pub fn av_image_copy(
        dst_data: *const *mut u8,
        dst_linesizes: *const ::std::os::raw::c_int,
        src_data: *const *const u8,
        src_linesizes: *const ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n available, this function will use special functionality for reading from such\n memory, which may result in greatly improved performance compared to plain\n av_image_copy().\n\n The data pointers and the linesizes must be aligned to the maximum required\n by the CPU architecture.\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_copy().\n @note On x86, the linesizes currently need to be aligned to the cacheline\n       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_uc_from(
        dst_data: *const *mut u8,
        dst_linesizes: *const isize,
        src_data: *const *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Setup the data pointers and linesizes based on the specified image\n parameters and the provided array.\n\n The fields of the given image are filled in by using the src\n address which points to the image data buffer. Depending on the\n specified pixel format, one or multiple image data pointers and\n line sizes will be set.  If a planar format is specified, several\n pointers will be set pointing to the different picture planes and\n the line sizes of the different planes will be stored in the\n lines_sizes array. Call with src == NULL to get the required\n size for the src buffer.\n\n To allocate the buffer and fill in the dst_data and dst_linesize in\n one call, use av_image_alloc().\n\n @param dst_data      data pointers to be filled in\n @param dst_linesize  linesizes for the image in dst_data to be filled in\n @param src           buffer which will contain or contains the actual image data, can be NULL\n @param pix_fmt       the pixel format of the image\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @param align         the value used in src for linesize alignment\n @return the size in bytes required for src, a negative error code\n in case of failure"]
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut ::std::os::raw::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the size in bytes of the amount of data required to store an\n image with the given parameters.\n\n @param pix_fmt  the pixel format of the image\n @param width    the width of the image in pixels\n @param height   the height of the image in pixels\n @param align    the assumed linesize alignment\n @return the buffer size in bytes, a negative error code in case of failure"]
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy image data from an image into a buffer.\n\n av_image_get_buffer_size() can be used to compute the required size\n for the buffer to fill.\n\n @param dst           a buffer into which picture data will be copied\n @param dst_size      the size in bytes of dst\n @param src_data      pointers containing the source image data\n @param src_linesize  linesizes for the image in src_data\n @param pix_fmt       the pixel format of the source image\n @param width         the width of the source image in pixels\n @param height        the height of the source image in pixels\n @param align         the assumed linesize alignment for dst\n @return the number of bytes written to dst, or a negative value\n (error code) on error"]
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: ::std::os::raw::c_int,
        src_data: *const *const u8,
        src_linesize: *const ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of the image can be addressed with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of a plane of an image with the specified pix_fmt can be addressed\n with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param max_pixels the maximum number of pixels the user wants to accept\n @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size2(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given sample aspect ratio of an image is valid.\n\n It is considered invalid if the denominator is 0 or if applying the ratio\n to the image size would make the smaller dimension less than 1. If the\n sar numerator is 0, it is considered unknown and will return as valid.\n\n @param w width of the image\n @param h height of the image\n @param sar sample aspect ratio of the image\n @return 0 if valid, a negative AVERROR code otherwise"]
    pub fn av_image_check_sar(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        sar: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the image data with black. This is suitable for filling a\n sub-rectangle of an image, meaning the padding between the right most pixel\n and the left most pixel on the next line will not be overwritten. For some\n formats, the image size might be rounded up due to inherent alignment.\n\n If the pixel format has alpha, the alpha is cleared to opaque.\n\n This can return an error if the pixel format is not supported. Normally, all\n non-hwaccel pixel formats should be supported.\n\n Passing NULL for dst_data is allowed. Then the function returns whether the\n operation would have succeeded. (It can return an error if the pix_fmt is\n not supported.)\n\n @param dst_data      data pointers to destination image\n @param dst_linesize  linesizes for the destination image\n @param pix_fmt       the pixel format of the image\n @param range         the color range of the image (important for colorspaces such as YUV)\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @return 0 if the image data was cleared, a negative AVERROR code otherwise"]
    pub fn av_image_fill_black(
        dst_data: *const *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_alias64 {
    pub u64_: u64,
    pub u32_: [u32; 2usize],
    pub u16_: [u16; 4usize],
    pub u8_: [u8; 8usize],
    pub f64_: f64,
    pub f32_: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_av_alias64() {
    const UNINIT: ::std::mem::MaybeUninit<av_alias64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<av_alias64>(),
        8usize,
        concat!("Size of: ", stringify!(av_alias64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_alias64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_alias64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias64),
            "::",
            stringify!(f32_)
        )
    );
}
impl ::std::fmt::Debug for av_alias64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "av_alias64 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_alias32 {
    pub u32_: u32,
    pub u16_: [u16; 2usize],
    pub u8_: [u8; 4usize],
    pub f32_: f32,
}
#[test]
fn bindgen_test_layout_av_alias32() {
    const UNINIT: ::std::mem::MaybeUninit<av_alias32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<av_alias32>(),
        4usize,
        concat!("Size of: ", stringify!(av_alias32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_alias32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_alias32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias32),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias32),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias32),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias32),
            "::",
            stringify!(f32_)
        )
    );
}
impl ::std::fmt::Debug for av_alias32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "av_alias32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_alias16 {
    pub u16_: u16,
    pub u8_: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_av_alias16() {
    const UNINIT: ::std::mem::MaybeUninit<av_alias16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<av_alias16>(),
        2usize,
        concat!("Size of: ", stringify!(av_alias16))
    );
    assert_eq!(
        ::std::mem::align_of::<av_alias16>(),
        2usize,
        concat!("Alignment of ", stringify!(av_alias16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias16),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_alias16),
            "::",
            stringify!(u8_)
        )
    );
}
impl ::std::fmt::Debug for av_alias16 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "av_alias16 {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_64 {
    pub l: u64,
}
#[test]
fn bindgen_test_layout_unaligned_64() {
    const UNINIT: ::std::mem::MaybeUninit<unaligned_64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unaligned_64>(),
        8usize,
        concat!("Size of: ", stringify!(unaligned_64))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_64>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_64),
            "::",
            stringify!(l)
        )
    );
}
impl ::std::fmt::Debug for unaligned_64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "unaligned_64 {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_32 {
    pub l: u32,
}
#[test]
fn bindgen_test_layout_unaligned_32() {
    const UNINIT: ::std::mem::MaybeUninit<unaligned_32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unaligned_32>(),
        4usize,
        concat!("Size of: ", stringify!(unaligned_32))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_32>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_32),
            "::",
            stringify!(l)
        )
    );
}
impl ::std::fmt::Debug for unaligned_32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "unaligned_32 {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_16 {
    pub l: u16,
}
#[test]
fn bindgen_test_layout_unaligned_16() {
    const UNINIT: ::std::mem::MaybeUninit<unaligned_16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unaligned_16>(),
        2usize,
        concat!("Size of: ", stringify!(unaligned_16))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_16>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_16),
            "::",
            stringify!(l)
        )
    );
}
impl ::std::fmt::Debug for unaligned_16 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "unaligned_16 {{ union }}")
    }
}
#[doc = " Context structure for the Lagged Fibonacci PRNG.\n The exact layout, types and content of this struct may change and should\n not be accessed directly. Only its `sizeof()` is guaranteed to stay the same\n to allow easy instanciation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVLFG {
    pub state: [::std::os::raw::c_uint; 64usize],
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVLFG() {
    const UNINIT: ::std::mem::MaybeUninit<AVLFG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVLFG>(),
        260usize,
        concat!("Size of: ", stringify!(AVLFG))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLFG>(),
        4usize,
        concat!("Alignment of ", stringify!(AVLFG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn av_lfg_init(c: *mut AVLFG, seed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Seed the state of the ALFG using binary data.\n\n @return 0 on success, negative value (AVERROR) on failure."]
    pub fn av_lfg_init_from_data(
        c: *mut AVLFG,
        data: *const u8,
        length: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next two numbers generated by a Box-Muller Gaussian\n generator using the random numbers issued by lfg.\n\n @param lfg pointer to the contex structure\n @param out array where the two generated numbers are placed"]
    pub fn av_bmg_get(lfg: *mut AVLFG, out: *mut f64);
}
extern "C" {
    #[doc = " @brief Decodes LZO 1x compressed data.\n @param out output buffer\n @param outlen size of output buffer, number of bytes left are returned here\n @param in input buffer\n @param inlen size of input buffer, number of bytes left are returned here\n @return 0 on success, otherwise a combination of the error flags above\n\n Make sure all buffers are appropriately padded, in must provide\n AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes."]
    pub fn av_lzo1x_decode(
        out: *mut ::std::os::raw::c_void,
        outlen: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_void,
        inlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Mastering display metadata capable of representing the color volume of\n the display used to master the content (SMPTE 2086:2014).\n\n To be used as payload of a AVFrameSideData or AVPacketSideData with the\n appropriate type.\n\n @note The struct should be allocated with av_mastering_display_metadata_alloc()\n       and its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMasteringDisplayMetadata {
    #[doc = " CIE 1931 xy chromaticity coords of color primaries (r, g, b order)."]
    pub display_primaries: [[AVRational; 2usize]; 3usize],
    #[doc = " CIE 1931 xy chromaticity coords of white point."]
    pub white_point: [AVRational; 2usize],
    #[doc = " Min luminance of mastering display (cd/m^2)."]
    pub min_luminance: AVRational,
    #[doc = " Max luminance of mastering display (cd/m^2)."]
    pub max_luminance: AVRational,
    #[doc = " Flag indicating whether the display primaries (and white point) are set."]
    pub has_primaries: ::std::os::raw::c_int,
    #[doc = " Flag indicating whether the luminance (min_ and max_) have been set."]
    pub has_luminance: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVMasteringDisplayMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<AVMasteringDisplayMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVMasteringDisplayMetadata>(),
        88usize,
        concat!("Size of: ", stringify!(AVMasteringDisplayMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<AVMasteringDisplayMetadata>(),
        4usize,
        concat!("Alignment of ", stringify!(AVMasteringDisplayMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(display_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(white_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_luminance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(min_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_luminance) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(max_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_primaries) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(has_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_luminance) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMasteringDisplayMetadata),
            "::",
            stringify!(has_luminance)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVMasteringDisplayMetadata structure and set its fields to\n default values. The resulting struct can be freed using av_freep().\n\n @return An AVMasteringDisplayMetadata filled with default values or NULL\n         on failure."]
    pub fn av_mastering_display_metadata_alloc() -> *mut AVMasteringDisplayMetadata;
}
extern "C" {
    #[doc = " Allocate a complete AVMasteringDisplayMetadata and add it to the frame.\n\n @param frame The frame which side data is added to.\n\n @return The AVMasteringDisplayMetadata structure to be filled by caller."]
    pub fn av_mastering_display_metadata_create_side_data(
        frame: *mut AVFrame,
    ) -> *mut AVMasteringDisplayMetadata;
}
#[doc = " Content light level needed by to transmit HDR over HDMI (CTA-861.3).\n\n To be used as payload of a AVFrameSideData or AVPacketSideData with the\n appropriate type.\n\n @note The struct should be allocated with av_content_light_metadata_alloc()\n       and its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVContentLightMetadata {
    #[doc = " Max content light level (cd/m^2)."]
    pub MaxCLL: ::std::os::raw::c_uint,
    #[doc = " Max average light level per frame (cd/m^2)."]
    pub MaxFALL: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_AVContentLightMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<AVContentLightMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVContentLightMetadata>(),
        8usize,
        concat!("Size of: ", stringify!(AVContentLightMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<AVContentLightMetadata>(),
        4usize,
        concat!("Alignment of ", stringify!(AVContentLightMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxCLL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVContentLightMetadata),
            "::",
            stringify!(MaxCLL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFALL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVContentLightMetadata),
            "::",
            stringify!(MaxFALL)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVContentLightMetadata structure and set its fields to\n default values. The resulting struct can be freed using av_freep().\n\n @return An AVContentLightMetadata filled with default values or NULL\n         on failure."]
    pub fn av_content_light_metadata_alloc(size: *mut usize) -> *mut AVContentLightMetadata;
}
extern "C" {
    #[doc = " Allocate a complete AVContentLightMetadata and add it to the frame.\n\n @param frame The frame which side data is added to.\n\n @return The AVContentLightMetadata structure to be filled by caller."]
    pub fn av_content_light_metadata_create_side_data(
        frame: *mut AVFrame,
    ) -> *mut AVContentLightMetadata;
}
extern "C" {
    #[doc = " @defgroup lavu_md5 MD5\n @ingroup lavu_hash\n MD5 hash function implementation.\n\n @{"]
    pub static av_md5_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMD5 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMD5 context."]
    pub fn av_md5_alloc() -> *mut AVMD5;
}
extern "C" {
    #[doc = " Initialize MD5 hashing.\n\n @param ctx pointer to the function context (of size av_md5_size)"]
    pub fn av_md5_init(ctx: *mut AVMD5);
}
extern "C" {
    #[doc = " Update hash value.\n\n @param ctx hash function context\n @param src input data to update hash with\n @param len input data length"]
    pub fn av_md5_update(ctx: *mut AVMD5, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param ctx hash function context\n @param dst buffer where output digest value is stored"]
    pub fn av_md5_final(ctx: *mut AVMD5, dst: *mut u8);
}
extern "C" {
    #[doc = " Hash an array of data.\n\n @param dst The output buffer to write the digest into\n @param src The data to hash\n @param len The length of the data, in bytes"]
    pub fn av_md5_sum(dst: *mut u8, src: *const u8, len: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMotionVector {
    #[doc = " Where the current macroblock comes from; negative value when it comes\n from the past, positive value when it comes from the future.\n XXX: set exact relative ref frame reference instead of a +/- 1 \"direction\"."]
    pub source: i32,
    #[doc = " Width and height of the block."]
    pub w: u8,
    #[doc = " Width and height of the block."]
    pub h: u8,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_x: i16,
    #[doc = " Absolute source position. Can be outside the frame area."]
    pub src_y: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_x: i16,
    #[doc = " Absolute destination position. Can be outside the frame area."]
    pub dst_y: i16,
    #[doc = " Extra flag information.\n Currently unused."]
    pub flags: u64,
    #[doc = " Motion vector\n src_x = dst_x + motion_x / motion_scale\n src_y = dst_y + motion_y / motion_scale"]
    pub motion_x: i32,
    #[doc = " Motion vector\n src_x = dst_x + motion_x / motion_scale\n src_y = dst_y + motion_y / motion_scale"]
    pub motion_y: i32,
    pub motion_scale: u16,
}
#[test]
fn bindgen_test_layout_AVMotionVector() {
    const UNINIT: ::std::mem::MaybeUninit<AVMotionVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVMotionVector>(),
        40usize,
        concat!("Size of: ", stringify!(AVMotionVector))
    );
    assert_eq!(
        ::std::mem::align_of::<AVMotionVector>(),
        8usize,
        concat!("Alignment of ", stringify!(AVMotionVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motion_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motion_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motion_scale) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_scale)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMurMur3 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVMurMur3 hash context.\n\n @return Uninitialized hash context or `NULL` in case of error"]
    pub fn av_murmur3_alloc() -> *mut AVMurMur3;
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context with a seed.\n\n @param[out] c    Hash context\n @param[in]  seed Random seed\n\n @see av_murmur3_init()\n @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n seeds for MurmurHash3."]
    pub fn av_murmur3_init_seeded(c: *mut AVMurMur3, seed: u64);
}
extern "C" {
    #[doc = " Initialize or reinitialize an AVMurMur3 hash context.\n\n Equivalent to av_murmur3_init_seeded() with a built-in seed.\n\n @param[out] c    Hash context\n\n @see av_murmur3_init_seeded()\n @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n seeds for MurmurHash3."]
    pub fn av_murmur3_init(c: *mut AVMurMur3);
}
extern "C" {
    #[doc = " Update hash context with new data.\n\n @param[out] c    Hash context\n @param[in]  src  Input data to update hash with\n @param[in]  len  Number of bytes to read from `src`"]
    pub fn av_murmur3_update(c: *mut AVMurMur3, src: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param[in,out] c    Hash context\n @param[out]    dst  Buffer where output digest value is stored"]
    pub fn av_murmur3_final(c: *mut AVMurMur3, dst: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse str and store the parsed ratio in q.\n\n Note that a ratio with infinite (1/0) or negative value is\n considered valid, so you should check on the returned value if you\n want to exclude those values.\n\n The undefined value can be expressed using the \"0:0\" string.\n\n @param[in,out] q pointer to the AVRational which will contain the ratio\n @param[in] str the string to parse: it has to be a string in the format\n num:den, a float number or an expression\n @param[in] max the maximum allowed numerator and denominator\n @param[in] log_offset log level offset which is applied to the log\n level of log_ctx\n @param[in] log_ctx parent logging context\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_ratio(
        q: *mut AVRational,
        str_: *const ::std::os::raw::c_char,
        max: ::std::os::raw::c_int,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse str and put in width_ptr and height_ptr the detected values.\n\n @param[in,out] width_ptr pointer to the variable which will contain the detected\n width value\n @param[in,out] height_ptr pointer to the variable which will contain the detected\n height value\n @param[in] str the string to parse: it has to be a string in the format\n width x height or a valid video size abbreviation.\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_size(
        width_ptr: *mut ::std::os::raw::c_int,
        height_ptr: *mut ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse str and store the detected values in *rate.\n\n @param[in,out] rate pointer to the AVRational which will contain the detected\n frame rate\n @param[in] str the string to parse: it has to be a string in the format\n rate_num / rate_den, a float number or a valid video rate abbreviation\n @return >= 0 on success, a negative error code otherwise"]
    pub fn av_parse_video_rate(
        rate: *mut AVRational,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the RGBA values that correspond to color_string in rgba_color.\n\n @param rgba_color 4-elements array of uint8_t values, where the respective\n red, green, blue and alpha component values are written.\n @param color_string a string specifying a color. It can be the name of\n a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,\n possibly followed by \"@\" and a string representing the alpha\n component.\n The alpha component may be a string composed by \"0x\" followed by an\n hexadecimal number or a decimal number between 0.0 and 1.0, which\n represents the opacity value (0x00/0.0 means completely transparent,\n 0xff/1.0 completely opaque).\n If the alpha component is not specified then 0xff is assumed.\n The string \"random\" will result in a random color.\n @param slen length of the initial part of color_string containing the\n color. It can be set to -1 if color_string is a null terminated string\n containing nothing else than the color.\n @param log_ctx a pointer to an arbitrary struct of which the first field\n is a pointer to an AVClass struct (used for av_log()). Can be NULL.\n @return >= 0 in case of success, a negative value in case of\n failure (for example if color_string cannot be parsed)."]
    pub fn av_parse_color(
        rgba_color: *mut u8,
        color_string: *const ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a color from the internal table of hard-coded named\n colors.\n\n This function is meant to enumerate the color names recognized by\n av_parse_color().\n\n @param color_idx index of the requested color, starting from 0\n @param rgb      if not NULL, will point to a 3-elements array with the color value in RGB\n @return the color name string or NULL if color_idx is not in the array"]
    pub fn av_get_known_color_name(
        color_idx: ::std::os::raw::c_int,
        rgb: *mut *const u8,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse timestr and return in *time a corresponding number of\n microseconds.\n\n @param timeval puts here the number of microseconds corresponding\n to the string in timestr. If the string represents a duration, it\n is the number of microseconds contained in the time interval.  If\n the string is a date, is the number of microseconds since 1st of\n January, 1970 up to the time of the parsed date.  If timestr cannot\n be successfully parsed, set *time to INT64_MIN.\n\n @param timestr a string representing a date or a duration.\n - If a date the syntax is:\n @code\n [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]\n now\n @endcode\n If the value is \"now\" it takes the current time.\n Time is local time unless Z is appended, in which case it is\n interpreted as UTC.\n If the year-month-day part is not specified it takes the current\n year-month-day.\n - If a duration the syntax is:\n @code\n [-][HH:]MM:SS[.m...]\n [-]S+[.m...]\n @endcode\n @param duration flag which tells how to interpret timestr, if not\n zero timestr is interpreted as a duration, otherwise as a date\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code otherwise"]
    pub fn av_parse_time(
        timeval: *mut i64,
        timestr: *const ::std::os::raw::c_char,
        duration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempt to find a specific tag in a URL.\n\n syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.\n Return 1 if found."]
    pub fn av_find_info_tag(
        arg: *mut ::std::os::raw::c_char,
        arg_size: ::std::os::raw::c_int,
        tag1: *const ::std::os::raw::c_char,
        info: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Simplified version of strptime\n\n Parse the input string p according to the format string fmt and\n store its results in the structure dt.\n This implementation supports only a subset of the formats supported\n by the standard strptime().\n\n The supported input field descriptors are listed below.\n - `%%H`: the hour as a decimal number, using a 24-hour clock, in the\n   range '00' through '23'\n - `%%J`: hours as a decimal number, in the range '0' through INT_MAX\n - `%%M`: the minute as a decimal number, using a 24-hour clock, in the\n   range '00' through '59'\n - `%%S`: the second as a decimal number, using a 24-hour clock, in the\n   range '00' through '59'\n - `%%Y`: the year as a decimal number, using the Gregorian calendar\n - `%%m`: the month as a decimal number, in the range '1' through '12'\n - `%%d`: the day of the month as a decimal number, in the range '1'\n   through '31'\n - `%%T`: alias for `%%H:%%M:%%S`\n - `%%`: a literal `%`\n\n @return a pointer to the first character not processed in this function\n         call. In case the input string contains more characters than\n         required by the format string the return value points right after\n         the last consumed input character. In case the whole input string\n         is consumed the return value points to the null byte at the end of\n         the string. On failure NULL is returned."]
    pub fn av_small_strptime(
        p: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        dt: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the decomposed UTC time in tm to a time_t value."]
    pub fn av_timegm(tm: *mut tm) -> time_t;
}
#[doc = " Sum of abs(src1[x] - src2[x])"]
pub type av_pixelutils_sad_fn = ::std::option::Option<
    unsafe extern "C" fn(
        src1: *const u8,
        stride1: isize,
        src2: *const u8,
        stride2: isize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Get a potentially optimized pointer to a Sum-of-absolute-differences\n function (see the av_pixelutils_sad_fn prototype).\n\n @param w_bits  1<<w_bits is the requested width of the block size\n @param h_bits  1<<h_bits is the requested height of the block size\n @param aligned If set to 2, the returned sad function will assume src1 and\n                src2 addresses are aligned on the block size.\n                If set to 1, the returned sad function will assume src1 is\n                aligned on the block size.\n                If set to 0, the returned sad function assume no particular\n                alignment.\n @param log_ctx context used for logging, can be NULL\n\n @return a pointer to the SAD function or NULL in case of error (because of\n         invalid parameters)"]
    pub fn av_pixelutils_get_sad_fn(
        w_bits: ::std::os::raw::c_int,
        h_bits: ::std::os::raw::c_int,
        aligned: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> av_pixelutils_sad_fn;
}
extern "C" {
    #[doc = " Get a seed to use in conjunction with random functions.\n This function tries to provide a good seed at a best effort bases.\n Its possible to call this function multiple times if more bits are needed.\n It can be quite slow, which is why it should only be used as seed for a faster\n PRNG. The quality of the seed depends on the platform."]
    pub fn av_get_random_seed() -> u32;
}
extern "C" {
    #[doc = " Generate cryptographically secure random data, i.e. suitable for use as\n encryption keys and similar.\n\n @param buf buffer into which the random data will be written\n @param len size of buf in bytes\n\n @retval 0                         success, len bytes of random data was written\n                                   into buf\n @retval \"a negative AVERROR code\" random data could not be generated"]
    pub fn av_random_bytes(buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
#[doc = " @defgroup lavu_rc4 RC4\n @ingroup lavu_crypto\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRC4 {
    pub state: [u8; 256usize],
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVRC4() {
    const UNINIT: ::std::mem::MaybeUninit<AVRC4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVRC4>(),
        264usize,
        concat!("Size of: ", stringify!(AVRC4))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRC4>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRC4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRC4),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        256usize,
        concat!("Offset of field: ", stringify!(AVRC4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        260usize,
        concat!("Offset of field: ", stringify!(AVRC4), "::", stringify!(y))
    );
}
extern "C" {
    #[doc = " Allocate an AVRC4 context."]
    pub fn av_rc4_alloc() -> *mut AVRC4;
}
extern "C" {
    #[doc = " @brief Initializes an AVRC4 context.\n\n @param d pointer to the AVRC4 context\n @param key buffer containig the key\n @param key_bits must be a multiple of 8\n @param decrypt 0 for encryption, 1 for decryption, currently has no effect\n @return zero on success, negative value otherwise"]
    pub fn av_rc4_init(
        d: *mut AVRC4,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
        decrypt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Encrypts / decrypts using the RC4 algorithm.\n\n @param d pointer to the AVRC4 context\n @param count number of bytes\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst, may be NULL\n @param iv not (yet) used for RC4, should be NULL\n @param decrypt 0 for encryption, 1 for decryption, not (yet) used"]
    pub fn av_rc4_crypt(
        d: *mut AVRC4,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
#[doc = " ReplayGain information (see\n http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).\n The size of this struct is a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVReplayGain {
    #[doc = " Track replay gain in microbels (divide by 100000 to get the value in dB).\n Should be set to INT32_MIN when unknown."]
    pub track_gain: i32,
    #[doc = " Peak track amplitude, with 100000 representing full scale (but values\n may overflow). 0 when unknown."]
    pub track_peak: u32,
    #[doc = " Same as track_gain, but for the whole album."]
    pub album_gain: i32,
    #[doc = " Same as track_peak, but for the whole album,"]
    pub album_peak: u32,
}
#[test]
fn bindgen_test_layout_AVReplayGain() {
    const UNINIT: ::std::mem::MaybeUninit<AVReplayGain> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVReplayGain>(),
        16usize,
        concat!("Size of: ", stringify!(AVReplayGain))
    );
    assert_eq!(
        ::std::mem::align_of::<AVReplayGain>(),
        4usize,
        concat!("Alignment of ", stringify!(AVReplayGain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).track_gain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).track_peak) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_peak)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).album_gain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).album_peak) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_peak)
        )
    );
}
extern "C" {
    #[doc = " @defgroup lavu_ripemd RIPEMD\n @ingroup lavu_hash\n RIPEMD hash function implementation.\n\n @{"]
    pub static av_ripemd_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRIPEMD {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVRIPEMD context."]
    pub fn av_ripemd_alloc() -> *mut AVRIPEMD;
}
extern "C" {
    #[doc = " Initialize RIPEMD hashing.\n\n @param context pointer to the function context (of size av_ripemd_size)\n @param bits    number of bits in digest (128, 160, 256 or 320 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_ripemd_init(
        context: *mut AVRIPEMD,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update hash value.\n\n @param context hash function context\n @param data    input data to update hash with\n @param len     input data length"]
    pub fn av_ripemd_update(context: *mut AVRIPEMD, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_ripemd_final(context: *mut AVRIPEMD, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha SHA\n @ingroup lavu_hash\n SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations.\n\n This module supports the following SHA hash functions:\n\n - SHA-1: 160 bits\n - SHA-224: 224 bits, as a variant of SHA-2\n - SHA-256: 256 bits, as a variant of SHA-2\n\n @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512.\n\n @{"]
    pub static av_sha_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA context."]
    pub fn av_sha_alloc() -> *mut AVSHA;
}
extern "C" {
    #[doc = " Initialize SHA-1 or SHA-2 hashing.\n\n @param context pointer to the function context (of size av_sha_size)\n @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha_init(context: *mut AVSHA, bits: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update hash value.\n\n @param ctx     hash function context\n @param data    input data to update hash with\n @param len     input data length"]
    pub fn av_sha_update(ctx: *mut AVSHA, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_sha_final(context: *mut AVSHA, digest: *mut u8);
}
extern "C" {
    #[doc = " @defgroup lavu_sha512 SHA-512\n @ingroup lavu_hash\n SHA-512 (Secure Hash Algorithm) hash function implementations.\n\n This module supports the following SHA-2 hash functions:\n\n - SHA-512/224: 224 bits\n - SHA-512/256: 256 bits\n - SHA-384: 384 bits\n - SHA-512: 512 bits\n\n @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha.\n\n @{"]
    pub static av_sha512_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA512 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVSHA512 context."]
    pub fn av_sha512_alloc() -> *mut AVSHA512;
}
extern "C" {
    #[doc = " Initialize SHA-2 512 hashing.\n\n @param context pointer to the function context (of size av_sha512_size)\n @param bits    number of bits in digest (224, 256, 384 or 512 bits)\n @return        zero if initialization succeeded, -1 otherwise"]
    pub fn av_sha512_init(
        context: *mut AVSHA512,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update hash value.\n\n @param context hash function context\n @param data    input data to update hash with\n @param len     input data length"]
    pub fn av_sha512_update(context: *mut AVSHA512, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Finish hashing and output digest value.\n\n @param context hash function context\n @param digest  buffer where output digest value is stored"]
    pub fn av_sha512_final(context: *mut AVSHA512, digest: *mut u8);
}
#[doc = " Video represents a sphere mapped on a flat surface using\n equirectangular projection."]
pub const AV_SPHERICAL_EQUIRECTANGULAR: AVSphericalProjection = 0;
#[doc = " Video frame is split into 6 faces of a cube, and arranged on a\n 3x2 layout. Faces are oriented upwards for the front, left, right,\n and back faces. The up face is oriented so the top of the face is\n forwards and the down face is oriented so the top of the face is\n to the back."]
pub const AV_SPHERICAL_CUBEMAP: AVSphericalProjection = 1;
#[doc = " Video represents a portion of a sphere mapped on a flat surface\n using equirectangular projection. The @ref bounding fields indicate\n the position of the current video in a larger surface."]
pub const AV_SPHERICAL_EQUIRECTANGULAR_TILE: AVSphericalProjection = 2;
#[doc = " Projection of the video surface(s) on a sphere."]
pub type AVSphericalProjection = ::std::os::raw::c_uint;
#[doc = " This structure describes how to handle spherical videos, outlining\n information about projection, initial layout, and any other view modifier.\n\n @note The struct must be allocated with av_spherical_alloc() and\n       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSphericalMapping {
    #[doc = " Projection type."]
    pub projection: AVSphericalProjection,
    #[doc = "< Rotation around the up vector [-180, 180]."]
    pub yaw: i32,
    #[doc = "< Rotation around the right vector [-90, 90]."]
    pub pitch: i32,
    #[doc = "< Rotation around the forward vector [-180, 180]."]
    pub roll: i32,
    #[doc = "< Distance from the left edge"]
    pub bound_left: u32,
    #[doc = "< Distance from the top edge"]
    pub bound_top: u32,
    #[doc = "< Distance from the right edge"]
    pub bound_right: u32,
    #[doc = "< Distance from the bottom edge"]
    pub bound_bottom: u32,
    #[doc = " Number of pixels to pad from the edge of each cube face.\n\n @note This value is valid for only for the cubemap projection type\n       (@ref AV_SPHERICAL_CUBEMAP), and should be ignored in all other\n       cases."]
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_AVSphericalMapping() {
    const UNINIT: ::std::mem::MaybeUninit<AVSphericalMapping> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVSphericalMapping>(),
        36usize,
        concat!("Size of: ", stringify!(AVSphericalMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSphericalMapping>(),
        4usize,
        concat!("Alignment of ", stringify!(AVSphericalMapping))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).projection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(projection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(yaw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bound_left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(bound_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bound_top) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(bound_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bound_right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(bound_right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bound_bottom) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(bound_bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSphericalMapping),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[doc = " Allocate a AVSphericalVideo structure and initialize its fields to default\n values.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_spherical_alloc(size: *mut usize) -> *mut AVSphericalMapping;
}
extern "C" {
    #[doc = " Convert the @ref bounding fields from an AVSphericalVideo\n from 0.32 fixed point to pixels.\n\n @param map    The AVSphericalVideo map to read bound values from.\n @param width  Width of the current frame or stream.\n @param height Height of the current frame or stream.\n @param left   Pixels from the left edge.\n @param top    Pixels from the top edge.\n @param right  Pixels from the right edge.\n @param bottom Pixels from the bottom edge."]
    pub fn av_spherical_tile_bounds(
        map: *const AVSphericalMapping,
        width: usize,
        height: usize,
        left: *mut usize,
        top: *mut usize,
        right: *mut usize,
        bottom: *mut usize,
    );
}
extern "C" {
    #[doc = " Provide a human-readable name of a given AVSphericalProjection.\n\n @param projection The input AVSphericalProjection.\n\n @return The name of the AVSphericalProjection, or \"unknown\"."]
    pub fn av_spherical_projection_name(
        projection: AVSphericalProjection,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the AVSphericalProjection form a human-readable name.\n\n @param name The input string.\n\n @return The AVSphericalProjection value, or -1 if not found."]
    pub fn av_spherical_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " Video is not stereoscopic (and metadata has to be there)."]
pub const AV_STEREO3D_2D: AVStereo3DType = 0;
#[doc = " Views are next to each other.\n\n @code{.unparsed}\n    LLLLRRRR\n    LLLLRRRR\n    LLLLRRRR\n    ...\n @endcode"]
pub const AV_STEREO3D_SIDEBYSIDE: AVStereo3DType = 1;
#[doc = " Views are on top of each other.\n\n @code{.unparsed}\n    LLLLLLLL\n    LLLLLLLL\n    RRRRRRRR\n    RRRRRRRR\n @endcode"]
pub const AV_STEREO3D_TOPBOTTOM: AVStereo3DType = 2;
#[doc = " Views are alternated temporally.\n\n @code{.unparsed}\n     frame0   frame1   frame2   ...\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    LLLLLLLL RRRRRRRR LLLLLLLL\n    ...      ...      ...\n @endcode"]
pub const AV_STEREO3D_FRAMESEQUENCE: AVStereo3DType = 3;
#[doc = " Views are packed in a checkerboard-like structure per pixel.\n\n @code{.unparsed}\n    LRLRLRLR\n    RLRLRLRL\n    LRLRLRLR\n    ...\n @endcode"]
pub const AV_STEREO3D_CHECKERBOARD: AVStereo3DType = 4;
#[doc = " Views are next to each other, but when upscaling\n apply a checkerboard pattern.\n\n @code{.unparsed}\n     LLLLRRRR          L L L L    R R R R\n     LLLLRRRR    =>     L L L L  R R R R\n     LLLLRRRR          L L L L    R R R R\n     LLLLRRRR           L L L L  R R R R\n @endcode"]
pub const AV_STEREO3D_SIDEBYSIDE_QUINCUNX: AVStereo3DType = 5;
#[doc = " Views are packed per line, as if interlaced.\n\n @code{.unparsed}\n    LLLLLLLL\n    RRRRRRRR\n    LLLLLLLL\n    ...\n @endcode"]
pub const AV_STEREO3D_LINES: AVStereo3DType = 6;
#[doc = " Views are packed per column.\n\n @code{.unparsed}\n    LRLRLRLR\n    LRLRLRLR\n    LRLRLRLR\n    ...\n @endcode"]
pub const AV_STEREO3D_COLUMNS: AVStereo3DType = 7;
#[doc = " List of possible 3D Types"]
pub type AVStereo3DType = ::std::os::raw::c_uint;
#[doc = " Frame contains two packed views."]
pub const AV_STEREO3D_VIEW_PACKED: AVStereo3DView = 0;
#[doc = " Frame contains only the left view."]
pub const AV_STEREO3D_VIEW_LEFT: AVStereo3DView = 1;
#[doc = " Frame contains only the right view."]
pub const AV_STEREO3D_VIEW_RIGHT: AVStereo3DView = 2;
#[doc = " List of possible view types."]
pub type AVStereo3DView = ::std::os::raw::c_uint;
#[doc = " Stereo 3D type: this structure describes how two videos are packed\n within a single video surface, with additional information as needed.\n\n @note The struct must be allocated with av_stereo3d_alloc() and\n       its size is not a part of the public ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStereo3D {
    #[doc = " How views are packed within the video."]
    pub type_: AVStereo3DType,
    #[doc = " Additional information about the frame packing."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Determines which views are packed."]
    pub view: AVStereo3DView,
}
#[test]
fn bindgen_test_layout_AVStereo3D() {
    const UNINIT: ::std::mem::MaybeUninit<AVStereo3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVStereo3D>(),
        12usize,
        concat!("Size of: ", stringify!(AVStereo3D))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStereo3D>(),
        4usize,
        concat!("Alignment of ", stringify!(AVStereo3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(view)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVStereo3D structure and set its fields to default values.\n The resulting struct can be freed using av_freep().\n\n @return An AVStereo3D filled with default values or NULL on failure."]
    pub fn av_stereo3d_alloc() -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Allocate a complete AVFrameSideData and add it to the frame.\n\n @param frame The frame which side data is added to.\n\n @return The AVStereo3D structure to be filled by caller."]
    pub fn av_stereo3d_create_side_data(frame: *mut AVFrame) -> *mut AVStereo3D;
}
extern "C" {
    #[doc = " Provide a human-readable name of a given stereo3d type.\n\n @param type The input stereo3d type value.\n\n @return The name of the stereo3d value, or \"unknown\"."]
    pub fn av_stereo3d_type_name(type_: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the AVStereo3DType form a human-readable name.\n\n @param name The input string.\n\n @return The AVStereo3DType value, or -1 if not found."]
    pub fn av_stereo3d_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil TEA algorithm\n @defgroup lavu_tea TEA\n @ingroup lavu_crypto\n @{"]
    pub static av_tea_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTEA {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVTEA context\n To free the struct: av_free(ptr)"]
    pub fn av_tea_alloc() -> *mut AVTEA;
}
extern "C" {
    #[doc = " Initialize an AVTEA context.\n\n @param ctx an AVTEA context\n @param key a key of 16 bytes used for encryption/decryption\n @param rounds the number of rounds in TEA (64 is the \"standard\")"]
    pub fn av_tea_init(ctx: *mut AVTEA, key: *const u8, rounds: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context.\n\n @param ctx an AVTEA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_tea_crypt(
        ctx: *mut AVTEA,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVThreadMessageQueue {
    _unused: [u8; 0],
}
#[doc = " Perform non-blocking operation.\n If this flag is set, send and recv operations are non-blocking and\n return AVERROR(EAGAIN) immediately if they can not proceed."]
pub const AV_THREAD_MESSAGE_NONBLOCK: AVThreadMessageFlags = 1;
pub type AVThreadMessageFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Allocate a new message queue.\n\n @param mq      pointer to the message queue\n @param nelem   maximum number of elements in the queue\n @param elsize  size of each element in the queue\n @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if\n          lavu was built without thread support"]
    pub fn av_thread_message_queue_alloc(
        mq: *mut *mut AVThreadMessageQueue,
        nelem: ::std::os::raw::c_uint,
        elsize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a message queue.\n\n The message queue must no longer be in use by another thread."]
    pub fn av_thread_message_queue_free(mq: *mut *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Send a message on the queue."]
    pub fn av_thread_message_queue_send(
        mq: *mut AVThreadMessageQueue,
        msg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a message from the queue."]
    pub fn av_thread_message_queue_recv(
        mq: *mut AVThreadMessageQueue,
        msg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the sending error code.\n\n If the error code is set to non-zero, av_thread_message_queue_send() will\n return it immediately. Conventional values, such as AVERROR_EOF or\n AVERROR(EAGAIN), can be used to cause the sending thread to stop or\n suspend its operation."]
    pub fn av_thread_message_queue_set_err_send(
        mq: *mut AVThreadMessageQueue,
        err: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set the receiving error code.\n\n If the error code is set to non-zero, av_thread_message_queue_recv() will\n return it immediately when there are no longer available messages.\n Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used\n to cause the receiving thread to stop or suspend its operation."]
    pub fn av_thread_message_queue_set_err_recv(
        mq: *mut AVThreadMessageQueue,
        err: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set the optional free message callback function which will be called if an\n operation is removing messages from the queue."]
    pub fn av_thread_message_queue_set_free_func(
        mq: *mut AVThreadMessageQueue,
        free_func: ::std::option::Option<unsafe extern "C" fn(msg: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Return the current number of messages in the queue.\n\n @return the current number of messages or AVERROR(ENOSYS) if lavu was built\n         without thread support"]
    pub fn av_thread_message_queue_nb_elems(mq: *mut AVThreadMessageQueue)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush the message queue\n\n This function is mostly equivalent to reading and free-ing every message\n except that it will be done in a single operation (no lock/unlock between\n reads)."]
    pub fn av_thread_message_flush(mq: *mut AVThreadMessageQueue);
}
extern "C" {
    #[doc = " Get the current time in microseconds."]
    pub fn av_gettime() -> i64;
}
extern "C" {
    #[doc = " Get the current time in microseconds since some unspecified starting point.\n On platforms that support it, the time comes from a monotonic clock\n This property makes this time source ideal for measuring relative time.\n The returned values may not be monotonic on platforms where a monotonic\n clock is not available."]
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    #[doc = " Indicates with a boolean result if the av_gettime_relative() time source\n is monotonic."]
    pub fn av_gettime_relative_is_monotonic() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sleep for a period of time.  Although the duration is expressed in\n microseconds, the actual delay may be rounded to the precision of the\n system timer.\n\n @param  usec Number of microseconds to sleep.\n @return zero on success or (negative) error code."]
    pub fn av_usleep(usec: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[doc = "< timecode is drop frame"]
pub const AV_TIMECODE_FLAG_DROPFRAME: AVTimecodeFlag = 1;
#[doc = "< timecode wraps after 24 hours"]
pub const AV_TIMECODE_FLAG_24HOURSMAX: AVTimecodeFlag = 2;
#[doc = "< negative time values are allowed"]
pub const AV_TIMECODE_FLAG_ALLOWNEGATIVE: AVTimecodeFlag = 4;
pub type AVTimecodeFlag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTimecode {
    #[doc = "< timecode frame start (first base frame number)"]
    pub start: ::std::os::raw::c_int,
    #[doc = "< flags such as drop frame, +24 hours support, ..."]
    pub flags: u32,
    #[doc = "< frame rate in rational form"]
    pub rate: AVRational,
    #[doc = "< frame per second; must be consistent with the rate field"]
    pub fps: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_AVTimecode() {
    const UNINIT: ::std::mem::MaybeUninit<AVTimecode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVTimecode>(),
        20usize,
        concat!("Size of: ", stringify!(AVTimecode))
    );
    assert_eq!(
        ::std::mem::align_of::<AVTimecode>(),
        4usize,
        concat!("Alignment of ", stringify!(AVTimecode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(fps)
        )
    );
}
extern "C" {
    #[doc = " Adjust frame number for NTSC drop frame time code.\n\n @param framenum frame number to adjust\n @param fps      frame per second, multiples of 30\n @return         adjusted frame number\n @warning        adjustment is only valid for multiples of NTSC 29.97"]
    pub fn av_timecode_adjust_ntsc_framenum2(
        framenum: ::std::os::raw::c_int,
        fps: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert frame number to SMPTE 12M binary representation.\n\n @param tc       timecode data correctly initialized\n @param framenum frame number\n @return         the SMPTE binary representation\n\n See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\"\n the format description as follows:\n bits 0-5:   hours, in BCD(6bits)\n bits 6:     BGF1\n bits 7:     BGF2 (NTSC) or FIELD (PAL)\n bits 8-14:  minutes, in BCD(7bits)\n bits 15:    BGF0 (NTSC) or BGF2 (PAL)\n bits 16-22: seconds, in BCD(7bits)\n bits 23:    FIELD (NTSC) or BGF0 (PAL)\n bits 24-29: frames, in BCD(6bits)\n bits 30:    drop  frame flag (0: non drop,    1: drop)\n bits 31:    color frame flag (0: unsync mode, 1: sync mode)\n @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.\n @note Frame number adjustment is automatically done in case of drop timecode,\n       you do NOT have to call av_timecode_adjust_ntsc_framenum2().\n @note The frame number is relative to tc->start.\n @note Color frame (CF) and binary group flags (BGF) bits are set to zero."]
    pub fn av_timecode_get_smpte_from_framenum(
        tc: *const AVTimecode,
        framenum: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = " Convert sei info to SMPTE 12M binary representation.\n\n @param rate     frame rate in rational form\n @param drop     drop flag\n @param hh       hour\n @param mm       minute\n @param ss       second\n @param ff       frame number\n @return         the SMPTE binary representation"]
    pub fn av_timecode_get_smpte(
        rate: AVRational,
        drop: ::std::os::raw::c_int,
        hh: ::std::os::raw::c_int,
        mm: ::std::os::raw::c_int,
        ss: ::std::os::raw::c_int,
        ff: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = " Load timecode string in buf.\n\n @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tc       timecode data correctly initialized\n @param framenum frame number\n @return         the buf parameter\n\n @note Timecode representation can be a negative timecode and have more than\n       24 hours, but will only be honored if the flags are correctly set.\n @note The frame number is relative to tc->start."]
    pub fn av_timecode_make_string(
        tc: *const AVTimecode,
        buf: *mut ::std::os::raw::c_char,
        framenum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format.\n\n In contrast to av_timecode_make_smpte_tc_string this function supports 50/60\n fps timecodes by using the field bit.\n\n @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param rate       frame rate of the timecode\n @param tcsmpte    the 32-bit SMPTE timecode\n @param prevent_df prevent the use of a drop flag when it is known the DF bit\n                   is arbitrary\n @param skip_field prevent the use of a field flag when it is known the field\n                   bit is arbitrary (e.g. because it is used as PC flag)\n @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string2(
        buf: *mut ::std::os::raw::c_char,
        rate: AVRational,
        tcsmpte: u32,
        prevent_df: ::std::os::raw::c_int,
        skip_field: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the SMPTE timecode format.\n\n @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tcsmpte    the 32-bit SMPTE timecode\n @param prevent_df prevent the use of a drop flag when it is known the DF bit\n                   is arbitrary\n @return           the buf parameter"]
    pub fn av_timecode_make_smpte_tc_string(
        buf: *mut ::std::os::raw::c_char,
        tcsmpte: u32,
        prevent_df: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the timecode string from the 25-bit timecode format (MPEG GOP format).\n\n @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n @param tc25bit the 25-bits timecode\n @return        the buf parameter"]
    pub fn av_timecode_make_mpeg_tc_string(
        buf: *mut ::std::os::raw::c_char,
        tc25bit: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Init a timecode struct with the passed parameters.\n\n @param log_ctx     a pointer to an arbitrary struct of which the first field\n                    is a pointer to an AVClass struct (used for av_log)\n @param tc          pointer to an allocated AVTimecode\n @param rate        frame rate in rational form\n @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n                    (see AVTimecodeFlag)\n @param frame_start the first frame number\n @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: ::std::os::raw::c_int,
        frame_start: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Init a timecode struct from the passed timecode components.\n\n @param log_ctx     a pointer to an arbitrary struct of which the first field\n                    is a pointer to an AVClass struct (used for av_log)\n @param tc          pointer to an allocated AVTimecode\n @param rate        frame rate in rational form\n @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n                    (see AVTimecodeFlag)\n @param hh          hours\n @param mm          minutes\n @param ss          seconds\n @param ff          frames\n @return            0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_components(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: ::std::os::raw::c_int,
        hh: ::std::os::raw::c_int,
        mm: ::std::os::raw::c_int,
        ss: ::std::os::raw::c_int,
        ff: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse timecode representation (hh:mm:ss[:;.]ff).\n\n @param log_ctx a pointer to an arbitrary struct of which the first field is a\n                pointer to an AVClass struct (used for av_log).\n @param tc      pointer to an allocated AVTimecode\n @param rate    frame rate in rational form\n @param str     timecode string which will determine the frame start\n @return        0 on success, AVERROR otherwise"]
    pub fn av_timecode_init_from_string(
        tc: *mut AVTimecode,
        rate: AVRational,
        str_: *const ::std::os::raw::c_char,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the timecode feature is available for the given frame rate\n\n @return 0 if supported, <0 otherwise"]
    pub fn av_timecode_check_frame_rate(rate: AVRational) -> ::std::os::raw::c_int;
}
#[doc = " @addtogroup lavu_tree AVTree\n @ingroup lavu_data\n\n Low-complexity tree container\n\n Insertion, removal, finding equal, largest which is smaller than and\n smallest which is larger than, all have O(log n) worst-case complexity.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTreeNode {
    _unused: [u8; 0],
}
extern "C" {
    pub static av_tree_node_size: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an AVTreeNode."]
    pub fn av_tree_node_alloc() -> *mut AVTreeNode;
}
extern "C" {
    #[doc = " Find an element.\n @param root a pointer to the root node of the tree\n @param next If next is not NULL, then next[0] will contain the previous\n             element and next[1] the next element. If either does not exist,\n             then the corresponding entry in next is unchanged.\n @param cmp compare function used to compare elements in the tree,\n            API identical to that of Standard C's qsort\n            It is guaranteed that the first and only the first argument to cmp()\n            will be the key parameter to av_tree_find(), thus it could if the\n            user wants, be a different type (like an opaque context).\n @return An element with cmp(key, elem) == 0 or NULL if no such element\n         exists in the tree."]
    pub fn av_tree_find(
        root: *const AVTreeNode,
        key: *mut ::std::os::raw::c_void,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                key: *const ::std::os::raw::c_void,
                b: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        next: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Insert or remove an element.\n\n If *next is NULL, then the supplied element will be removed if it exists.\n If *next is non-NULL, then the supplied element will be inserted, unless\n it already exists in the tree.\n\n @param rootp A pointer to a pointer to the root node of the tree; note that\n              the root node can change during insertions, this is required\n              to keep the tree balanced.\n @param key  pointer to the element key to insert in the tree\n @param next Used to allocate and free AVTreeNodes. For insertion the user\n             must set it to an allocated and zeroed object of at least\n             av_tree_node_size bytes size. av_tree_insert() will set it to\n             NULL if it has been consumed.\n             For deleting elements *next is set to NULL by the user and\n             av_tree_insert() will set it to the AVTreeNode which was\n             used for the removed element.\n             This allows the use of flat arrays, which have\n             lower overhead compared to many malloced elements.\n             You might want to define a function like:\n             @code\n             void *tree_insert(struct AVTreeNode **rootp, void *key,\n                               int (*cmp)(void *key, const void *b),\n                               AVTreeNode **next)\n             {\n                 if (!*next)\n                     *next = av_mallocz(av_tree_node_size);\n                 return av_tree_insert(rootp, key, cmp, next);\n             }\n             void *tree_remove(struct AVTreeNode **rootp, void *key,\n                               int (*cmp)(void *key, const void *b, AVTreeNode **next))\n             {\n                 av_freep(next);\n                 return av_tree_insert(rootp, key, cmp, next);\n             }\n             @endcode\n @param cmp compare function used to compare elements in the tree, API identical\n            to that of Standard C's qsort\n @return If no insertion happened, the found element; if an insertion or\n         removal happened, then either key or NULL will be returned.\n         Which one it is depends on the tree state and the implementation. You\n         should make no assumptions that it's one or the other in the code."]
    pub fn av_tree_insert(
        rootp: *mut *mut AVTreeNode,
        key: *mut ::std::os::raw::c_void,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                key: *const ::std::os::raw::c_void,
                b: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        next: *mut *mut AVTreeNode,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_tree_destroy(t: *mut AVTreeNode);
}
extern "C" {
    #[doc = " Apply enu(opaque, &elem) to all the elements in the tree in a given range.\n\n @param cmp a comparison function that returns < 0 for an element below the\n            range, > 0 for an element above the range and == 0 for an\n            element inside the range\n\n @note The cmp function should use the same ordering used to construct the\n       tree."]
    pub fn av_tree_enumerate(
        t: *mut AVTreeNode,
        opaque: *mut ::std::os::raw::c_void,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        enu: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @file\n @brief Public header for libavutil TWOFISH algorithm\n @defgroup lavu_twofish TWOFISH\n @ingroup lavu_crypto\n @{"]
    pub static av_twofish_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTWOFISH {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate an AVTWOFISH context\n To free the struct: av_free(ptr)"]
    pub fn av_twofish_alloc() -> *mut AVTWOFISH;
}
extern "C" {
    #[doc = " Initialize an AVTWOFISH context.\n\n @param ctx an AVTWOFISH context\n @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption\n @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise"]
    pub fn av_twofish_init(
        ctx: *mut AVTWOFISH,
        key: *const u8,
        key_bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context\n\n @param ctx an AVTWOFISH context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 16 byte blocks\n @param iv initialization vector for CBC mode, NULL for ECB mode\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_twofish_crypt(
        ctx: *mut AVTWOFISH,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTXContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComplexFloat {
    pub re: f32,
    pub im: f32,
}
#[test]
fn bindgen_test_layout_AVComplexFloat() {
    const UNINIT: ::std::mem::MaybeUninit<AVComplexFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVComplexFloat>(),
        8usize,
        concat!("Size of: ", stringify!(AVComplexFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComplexFloat>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComplexFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexFloat),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexFloat),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComplexDouble {
    pub re: f64,
    pub im: f64,
}
#[test]
fn bindgen_test_layout_AVComplexDouble() {
    const UNINIT: ::std::mem::MaybeUninit<AVComplexDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVComplexDouble>(),
        16usize,
        concat!("Size of: ", stringify!(AVComplexDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComplexDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(AVComplexDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexDouble),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexDouble),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComplexInt32 {
    pub re: i32,
    pub im: i32,
}
#[test]
fn bindgen_test_layout_AVComplexInt32() {
    const UNINIT: ::std::mem::MaybeUninit<AVComplexInt32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVComplexInt32>(),
        8usize,
        concat!("Size of: ", stringify!(AVComplexInt32))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComplexInt32>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComplexInt32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexInt32),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComplexInt32),
            "::",
            stringify!(im)
        )
    );
}
#[doc = " Standard complex to complex FFT with sample data type of AVComplexFloat,\n AVComplexDouble or AVComplexInt32, for each respective variant.\n\n Output is not 1/len normalized. Scaling currently unsupported.\n The stride parameter must be set to the size of a single sample in bytes."]
pub const AV_TX_FLOAT_FFT: AVTXType = 0;
#[doc = " Standard complex to complex FFT with sample data type of AVComplexFloat,\n AVComplexDouble or AVComplexInt32, for each respective variant.\n\n Output is not 1/len normalized. Scaling currently unsupported.\n The stride parameter must be set to the size of a single sample in bytes."]
pub const AV_TX_DOUBLE_FFT: AVTXType = 2;
#[doc = " Standard complex to complex FFT with sample data type of AVComplexFloat,\n AVComplexDouble or AVComplexInt32, for each respective variant.\n\n Output is not 1/len normalized. Scaling currently unsupported.\n The stride parameter must be set to the size of a single sample in bytes."]
pub const AV_TX_INT32_FFT: AVTXType = 4;
#[doc = " Standard MDCT with a sample data type of float, double or int32_t,\n respecively. For the float and int32 variants, the scale type is\n 'float', while for the double variant, it's 'double'.\n If scale is NULL, 1.0 will be used as a default.\n\n Length is the frame size, not the window size (which is 2x frame).\n For forward transforms, the stride specifies the spacing between each\n sample in the output array in bytes. The input must be a flat array.\n\n For inverse transforms, the stride specifies the spacing between each\n sample in the input array in bytes. The output must be a flat array.\n\n NOTE: the inverse transform is half-length, meaning the output will not\n contain redundant data. This is what most codecs work with. To do a full\n inverse transform, set the AV_TX_FULL_IMDCT flag on init."]
pub const AV_TX_FLOAT_MDCT: AVTXType = 1;
#[doc = " Standard MDCT with a sample data type of float, double or int32_t,\n respecively. For the float and int32 variants, the scale type is\n 'float', while for the double variant, it's 'double'.\n If scale is NULL, 1.0 will be used as a default.\n\n Length is the frame size, not the window size (which is 2x frame).\n For forward transforms, the stride specifies the spacing between each\n sample in the output array in bytes. The input must be a flat array.\n\n For inverse transforms, the stride specifies the spacing between each\n sample in the input array in bytes. The output must be a flat array.\n\n NOTE: the inverse transform is half-length, meaning the output will not\n contain redundant data. This is what most codecs work with. To do a full\n inverse transform, set the AV_TX_FULL_IMDCT flag on init."]
pub const AV_TX_DOUBLE_MDCT: AVTXType = 3;
#[doc = " Standard MDCT with a sample data type of float, double or int32_t,\n respecively. For the float and int32 variants, the scale type is\n 'float', while for the double variant, it's 'double'.\n If scale is NULL, 1.0 will be used as a default.\n\n Length is the frame size, not the window size (which is 2x frame).\n For forward transforms, the stride specifies the spacing between each\n sample in the output array in bytes. The input must be a flat array.\n\n For inverse transforms, the stride specifies the spacing between each\n sample in the input array in bytes. The output must be a flat array.\n\n NOTE: the inverse transform is half-length, meaning the output will not\n contain redundant data. This is what most codecs work with. To do a full\n inverse transform, set the AV_TX_FULL_IMDCT flag on init."]
pub const AV_TX_INT32_MDCT: AVTXType = 5;
#[doc = " Real to complex and complex to real DFTs.\n For the float and int32 variants, the scale type is 'float', while for\n the double variant, it's a 'double'. If scale is NULL, 1.0 will be used\n as a default.\n\n For forward transforms (R2C), stride must be the spacing between two\n samples in bytes. For inverse transforms, the stride must be set\n to the spacing between two complex values in bytes.\n\n The forward transform performs a real-to-complex DFT of N samples to\n N/2+1 complex values.\n\n The inverse transform performs a complex-to-real DFT of N/2+1 complex\n values to N real samples. The output is not normalized, but can be\n made so by setting the scale value to 1.0/len.\n NOTE: the inverse transform always overwrites the input."]
pub const AV_TX_FLOAT_RDFT: AVTXType = 6;
#[doc = " Real to complex and complex to real DFTs.\n For the float and int32 variants, the scale type is 'float', while for\n the double variant, it's a 'double'. If scale is NULL, 1.0 will be used\n as a default.\n\n For forward transforms (R2C), stride must be the spacing between two\n samples in bytes. For inverse transforms, the stride must be set\n to the spacing between two complex values in bytes.\n\n The forward transform performs a real-to-complex DFT of N samples to\n N/2+1 complex values.\n\n The inverse transform performs a complex-to-real DFT of N/2+1 complex\n values to N real samples. The output is not normalized, but can be\n made so by setting the scale value to 1.0/len.\n NOTE: the inverse transform always overwrites the input."]
pub const AV_TX_DOUBLE_RDFT: AVTXType = 7;
#[doc = " Real to complex and complex to real DFTs.\n For the float and int32 variants, the scale type is 'float', while for\n the double variant, it's a 'double'. If scale is NULL, 1.0 will be used\n as a default.\n\n For forward transforms (R2C), stride must be the spacing between two\n samples in bytes. For inverse transforms, the stride must be set\n to the spacing between two complex values in bytes.\n\n The forward transform performs a real-to-complex DFT of N samples to\n N/2+1 complex values.\n\n The inverse transform performs a complex-to-real DFT of N/2+1 complex\n values to N real samples. The output is not normalized, but can be\n made so by setting the scale value to 1.0/len.\n NOTE: the inverse transform always overwrites the input."]
pub const AV_TX_INT32_RDFT: AVTXType = 8;
#[doc = " Real to real (DCT) transforms.\n\n The forward transform is a DCT-II.\n The inverse transform is a DCT-III.\n\n The input array is always overwritten. DCT-III requires that the\n input be padded with 2 extra samples. Stride must be set to the\n spacing between two samples in bytes."]
pub const AV_TX_FLOAT_DCT: AVTXType = 9;
#[doc = " Real to real (DCT) transforms.\n\n The forward transform is a DCT-II.\n The inverse transform is a DCT-III.\n\n The input array is always overwritten. DCT-III requires that the\n input be padded with 2 extra samples. Stride must be set to the\n spacing between two samples in bytes."]
pub const AV_TX_DOUBLE_DCT: AVTXType = 10;
#[doc = " Real to real (DCT) transforms.\n\n The forward transform is a DCT-II.\n The inverse transform is a DCT-III.\n\n The input array is always overwritten. DCT-III requires that the\n input be padded with 2 extra samples. Stride must be set to the\n spacing between two samples in bytes."]
pub const AV_TX_INT32_DCT: AVTXType = 11;
#[doc = " Discrete Cosine Transform I\n\n The forward transform is a DCT-I.\n The inverse transform is a DCT-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_FLOAT_DCT_I: AVTXType = 12;
#[doc = " Discrete Cosine Transform I\n\n The forward transform is a DCT-I.\n The inverse transform is a DCT-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_DOUBLE_DCT_I: AVTXType = 13;
#[doc = " Discrete Cosine Transform I\n\n The forward transform is a DCT-I.\n The inverse transform is a DCT-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_INT32_DCT_I: AVTXType = 14;
#[doc = " Discrete Sine Transform I\n\n The forward transform is a DST-I.\n The inverse transform is a DST-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_FLOAT_DST_I: AVTXType = 15;
#[doc = " Discrete Sine Transform I\n\n The forward transform is a DST-I.\n The inverse transform is a DST-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_DOUBLE_DST_I: AVTXType = 16;
#[doc = " Discrete Sine Transform I\n\n The forward transform is a DST-I.\n The inverse transform is a DST-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_INT32_DST_I: AVTXType = 17;
#[doc = " Discrete Sine Transform I\n\n The forward transform is a DST-I.\n The inverse transform is a DST-I multiplied by 2/(N + 1).\n\n The input array is always overwritten."]
pub const AV_TX_NB: AVTXType = 18;
pub type AVTXType = ::std::os::raw::c_uint;
#[doc = " Function pointer to a function to perform the transform.\n\n @note Using a different context than the one allocated during av_tx_init()\n is not allowed.\n\n @param s the transform context\n @param out the output array\n @param in the input array\n @param stride the input or output stride in bytes\n\n The out and in arrays must be aligned to the maximum required by the CPU\n architecture unless the AV_TX_UNALIGNED flag was set in av_tx_init().\n The stride must follow the constraints the transform type has specified."]
pub type av_tx_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVTXContext,
        out: *mut ::std::os::raw::c_void,
        in_: *mut ::std::os::raw::c_void,
        stride: isize,
    ),
>;
#[doc = " Allows for in-place transformations, where input == output.\n May be unsupported or slower for some transform types."]
pub const AV_TX_INPLACE: AVTXFlags = 1;
#[doc = " Relaxes alignment requirement for the in and out arrays of av_tx_fn().\n May be slower with certain transform types."]
pub const AV_TX_UNALIGNED: AVTXFlags = 2;
#[doc = " Performs a full inverse MDCT rather than leaving out samples that can be\n derived through symmetry. Requires an output array of 'len' floats,\n rather than the usual 'len/2' floats.\n Ignored for all transforms but inverse MDCTs."]
pub const AV_TX_FULL_IMDCT: AVTXFlags = 4;
#[doc = " Perform a real to half-complex RDFT.\n Only the real, or imaginary coefficients will\n be output, depending on the flag used. Only available for forward RDFTs.\n Output array must have enough space to hold N complex values\n (regular size for a real to complex transform)."]
pub const AV_TX_REAL_TO_REAL: AVTXFlags = 8;
#[doc = " Perform a real to half-complex RDFT.\n Only the real, or imaginary coefficients will\n be output, depending on the flag used. Only available for forward RDFTs.\n Output array must have enough space to hold N complex values\n (regular size for a real to complex transform)."]
pub const AV_TX_REAL_TO_IMAGINARY: AVTXFlags = 16;
#[doc = " Flags for av_tx_init()"]
pub type AVTXFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Initialize a transform context with the given configuration\n (i)MDCTs with an odd length are currently not supported.\n\n @param ctx the context to allocate, will be NULL on error\n @param tx pointer to the transform function pointer to set\n @param type type the type of transform\n @param inv whether to do an inverse or a forward transform\n @param len the size of the transform in samples\n @param scale pointer to the value to scale the output if supported by type\n @param flags a bitmask of AVTXFlags or 0\n\n @return 0 on success, negative error code on failure"]
    pub fn av_tx_init(
        ctx: *mut *mut AVTXContext,
        tx: *mut av_tx_fn,
        type_: AVTXType,
        inv: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        scale: *const ::std::os::raw::c_void,
        flags: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees a context and sets *ctx to NULL, does nothing when *ctx == NULL."]
    pub fn av_tx_uninit(ctx: *mut *mut AVTXContext);
}
pub type AVUUID = [u8; 16usize];
extern "C" {
    #[doc = " Parses a string representation of a UUID formatted according to IETF RFC 4122\n into an AVUUID. The parsing is case-insensitive. The string must be 37\n characters long, including the terminating NUL character.\n\n Example string representation: \"2fceebd0-7017-433d-bafb-d073a7116696\"\n\n @param[in]  in  String representation of a UUID,\n                 e.g. 2fceebd0-7017-433d-bafb-d073a7116696\n @param[out] uu  AVUUID\n @return         A non-zero value in case of an error."]
    pub fn av_uuid_parse(in_: *const ::std::os::raw::c_char, uu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parses a URN representation of a UUID, as specified at IETF RFC 4122,\n into an AVUUID. The parsing is case-insensitive. The string must be 46\n characters long, including the terminating NUL character.\n\n Example string representation: \"urn:uuid:2fceebd0-7017-433d-bafb-d073a7116696\"\n\n @param[in]  in  URN UUID\n @param[out] uu  AVUUID\n @return         A non-zero value in case of an error."]
    pub fn av_uuid_urn_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parses a string representation of a UUID formatted according to IETF RFC 4122\n into an AVUUID. The parsing is case-insensitive.\n\n @param[in]  in_start Pointer to the first character of the string representation\n @param[in]  in_end   Pointer to the character after the last character of the\n                      string representation. That memory location is never\n                      accessed. It is an error if `in_end - in_start != 36`.\n @param[out] uu       AVUUID\n @return              A non-zero value in case of an error."]
    pub fn av_uuid_parse_range(
        in_start: *const ::std::os::raw::c_char,
        in_end: *const ::std::os::raw::c_char,
        uu: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serializes a AVUUID into a string representation according to IETF RFC 4122.\n The string is lowercase and always 37 characters long, including the\n terminating NUL character.\n\n @param[in]  uu  AVUUID\n @param[out] out Pointer to an array of no less than 37 characters."]
    pub fn av_uuid_unparse(uu: *mut u8, out: *mut ::std::os::raw::c_char);
}
pub const AV_VIDEO_ENC_PARAMS_NONE: AVVideoEncParamsType = -1;
#[doc = " VP9 stores:\n - per-frame base (luma AC) quantizer index, exported as AVVideoEncParams.qp\n - deltas for luma DC, chroma AC and chroma DC, exported in the\n   corresponding entries in AVVideoEncParams.delta_qp\n - per-segment delta, exported as for each block as AVVideoBlockParams.delta_qp\n\n To compute the resulting quantizer index for a block:\n - for luma AC, add the base qp and the per-block delta_qp, saturating to\n   unsigned 8-bit.\n - for luma DC and chroma AC/DC, add the corresponding\n   AVVideoBlockParams.delta_qp to the luma AC index, again saturating to\n   unsigned 8-bit."]
pub const AV_VIDEO_ENC_PARAMS_VP9: AVVideoEncParamsType = 0;
#[doc = " H.264 stores:\n - in PPS (per-picture):\n   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp\n   * delta(s) for chroma QP values (same for both, or each separately),\n     exported as in the corresponding entries in AVVideoEncParams.delta_qp\n - per-slice QP delta, not exported directly, added to the per-MB value\n - per-MB delta; not exported directly; the final per-MB quantizer\n   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported\n   as AVVideoBlockParams.qp_delta."]
pub const AV_VIDEO_ENC_PARAMS_H264: AVVideoEncParamsType = 1;
#[doc = " H.264 stores:\n - in PPS (per-picture):\n   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp\n   * delta(s) for chroma QP values (same for both, or each separately),\n     exported as in the corresponding entries in AVVideoEncParams.delta_qp\n - per-slice QP delta, not exported directly, added to the per-MB value\n - per-MB delta; not exported directly; the final per-MB quantizer\n   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported\n   as AVVideoBlockParams.qp_delta."]
pub const AV_VIDEO_ENC_PARAMS_MPEG2: AVVideoEncParamsType = 2;
pub type AVVideoEncParamsType = ::std::os::raw::c_int;
#[doc = " Video encoding parameters for a given frame. This struct is allocated along\n with an optional array of per-block AVVideoBlockParams descriptors.\n Must be allocated with av_video_enc_params_alloc()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVideoEncParams {
    #[doc = " Number of blocks in the array.\n\n May be 0, in which case no per-block information is present. In this case\n the values of blocks_offset / block_size are unspecified and should not\n be accessed."]
    pub nb_blocks: ::std::os::raw::c_uint,
    #[doc = " Offset in bytes from the beginning of this structure at which the array\n of blocks starts."]
    pub blocks_offset: usize,
    pub block_size: usize,
    #[doc = " Type of the parameters (the codec they are used with)."]
    pub type_: AVVideoEncParamsType,
    #[doc = " Base quantisation parameter for the frame. The final quantiser for a\n given block in a given plane is obtained from this value, possibly\n combined with {@code delta_qp} and the per-block delta in a manner\n documented for each type."]
    pub qp: i32,
    #[doc = " Quantisation parameter offset from the base (per-frame) qp for a given\n plane (first index) and AC/DC coefficients (second index)."]
    pub delta_qp: [[i32; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_AVVideoEncParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVVideoEncParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVVideoEncParams>(),
        64usize,
        concat!("Size of: ", stringify!(AVVideoEncParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVVideoEncParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVVideoEncParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_blocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(nb_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blocks_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(blocks_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_qp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoEncParams),
            "::",
            stringify!(delta_qp)
        )
    );
}
#[doc = " Data structure for storing block-level encoding information.\n It is allocated as a part of AVVideoEncParams and should be retrieved with\n av_video_enc_params_block().\n\n sizeof(AVVideoBlockParams) is not a part of the ABI and new fields may be\n added to it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVideoBlockParams {
    #[doc = " Distance in luma pixels from the top-left corner of the visible frame\n to the top-left corner of the block.\n Can be negative if top/right padding is present on the coded frame."]
    pub src_x: ::std::os::raw::c_int,
    #[doc = " Distance in luma pixels from the top-left corner of the visible frame\n to the top-left corner of the block.\n Can be negative if top/right padding is present on the coded frame."]
    pub src_y: ::std::os::raw::c_int,
    #[doc = " Width and height of the block in luma pixels."]
    pub w: ::std::os::raw::c_int,
    #[doc = " Width and height of the block in luma pixels."]
    pub h: ::std::os::raw::c_int,
    #[doc = " Difference between this block's final quantization parameter and the\n corresponding per-frame value."]
    pub delta_qp: i32,
}
#[test]
fn bindgen_test_layout_AVVideoBlockParams() {
    const UNINIT: ::std::mem::MaybeUninit<AVVideoBlockParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVVideoBlockParams>(),
        20usize,
        concat!("Size of: ", stringify!(AVVideoBlockParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVVideoBlockParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AVVideoBlockParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoBlockParams),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoBlockParams),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoBlockParams),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoBlockParams),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_qp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoBlockParams),
            "::",
            stringify!(delta_qp)
        )
    );
}
extern "C" {
    #[doc = " Allocates memory for AVVideoEncParams of the given type, plus an array of\n {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be\n freed with a normal av_free() call.\n\n @param out_size if non-NULL, the size in bytes of the resulting data array is\n written here."]
    pub fn av_video_enc_params_alloc(
        type_: AVVideoEncParamsType,
        nb_blocks: ::std::os::raw::c_uint,
        out_size: *mut usize,
    ) -> *mut AVVideoEncParams;
}
extern "C" {
    #[doc = " Allocates memory for AVEncodeInfoFrame plus an array of\n {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}\n as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS\n and initializes the variables."]
    pub fn av_video_enc_params_create_side_data(
        frame: *mut AVFrame,
        type_: AVVideoEncParamsType,
        nb_blocks: ::std::os::raw::c_uint,
    ) -> *mut AVVideoEncParams;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVideoRect {
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_AVVideoRect() {
    const UNINIT: ::std::mem::MaybeUninit<AVVideoRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVVideoRect>(),
        16usize,
        concat!("Size of: ", stringify!(AVVideoRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVVideoRect>(),
        4usize,
        concat!("Alignment of ", stringify!(AVVideoRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoRect),
            "::",
            stringify!(height)
        )
    );
}
pub const AV_VIDEO_HINT_TYPE_CONSTANT: AVVideoHintType = 0;
pub const AV_VIDEO_HINT_TYPE_CHANGED: AVVideoHintType = 1;
pub type AVVideoHintType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVideoHint {
    #[doc = " Number of AVVideoRect present.\n\n May be 0, in which case no per-rectangle information is present. In this\n case the values of rect_offset / rect_size are unspecified and should\n not be accessed."]
    pub nb_rects: usize,
    #[doc = " Offset in bytes from the beginning of this structure at which the array\n of AVVideoRect starts."]
    pub rect_offset: usize,
    #[doc = " Size in bytes of AVVideoRect."]
    pub rect_size: usize,
    pub type_: AVVideoHintType,
}
#[test]
fn bindgen_test_layout_AVVideoHint() {
    const UNINIT: ::std::mem::MaybeUninit<AVVideoHint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVVideoHint>(),
        32usize,
        concat!("Size of: ", stringify!(AVVideoHint))
    );
    assert_eq!(
        ::std::mem::align_of::<AVVideoHint>(),
        8usize,
        concat!("Alignment of ", stringify!(AVVideoHint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_rects) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoHint),
            "::",
            stringify!(nb_rects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoHint),
            "::",
            stringify!(rect_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoHint),
            "::",
            stringify!(rect_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVVideoHint),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Allocate memory for the AVVideoHint struct along with an nb_rects-sized\n arrays of AVVideoRect.\n\n The side data contains a list of rectangles for the portions of the frame\n which changed from the last encoded one (and the remainder are assumed to be\n changed), or, alternately (depending on the type parameter) the unchanged\n ones (and the remanining ones are those which changed).\n Macroblocks will thus be hinted either to be P_SKIP-ped or go through the\n regular encoding procedure.\n\n It's responsibility of the caller to fill the AVRects accordingly, and to set\n the proper AVVideoHintType field.\n\n @param out_size if non-NULL, the size in bytes of the resulting data array is\n                 written here\n\n @return newly allocated AVVideoHint struct (must be freed by the caller using\n         av_free()) on success, NULL on memory allocation failure"]
    pub fn av_video_hint_alloc(nb_rects: usize, out_size: *mut usize) -> *mut AVVideoHint;
}
extern "C" {
    #[doc = " Same as av_video_hint_alloc(), except newly-allocated AVVideoHint is attached\n as side data of type AV_FRAME_DATA_VIDEO_HINT_INFO to frame."]
    pub fn av_video_hint_create_side_data(frame: *mut AVFrame, nb_rects: usize)
        -> *mut AVVideoHint;
}
#[doc = " @file\n @brief Public header for libavutil XTEA algorithm\n @defgroup lavu_xtea XTEA\n @ingroup lavu_crypto\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVXTEA {
    pub key: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_AVXTEA() {
    const UNINIT: ::std::mem::MaybeUninit<AVXTEA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AVXTEA>(),
        64usize,
        concat!("Size of: ", stringify!(AVXTEA))
    );
    assert_eq!(
        ::std::mem::align_of::<AVXTEA>(),
        4usize,
        concat!("Alignment of ", stringify!(AVXTEA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVXTEA),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    #[doc = " Allocate an AVXTEA context."]
    pub fn av_xtea_alloc() -> *mut AVXTEA;
}
extern "C" {
    #[doc = " Initialize an AVXTEA context.\n\n @param ctx an AVXTEA context\n @param key a key of 16 bytes used for encryption/decryption,\n            interpreted as big endian 32 bit numbers"]
    pub fn av_xtea_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Initialize an AVXTEA context.\n\n @param ctx an AVXTEA context\n @param key a key of 16 bytes used for encryption/decryption,\n            interpreted as little endian 32 bit numbers"]
    pub fn av_xtea_le_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,\n in big endian format.\n\n @param ctx an AVXTEA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Encrypt or decrypt a buffer using a previously initialized context,\n in little endian format.\n\n @param ctx an AVXTEA context\n @param dst destination array, can be equal to src\n @param src source array, can be equal to dst\n @param count number of 8 byte blocks\n @param iv initialization vector for CBC mode, if NULL then ECB will be used\n @param decrypt 0 for encryption, 1 for decryption"]
    pub fn av_xtea_le_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: ::std::os::raw::c_int,
        iv: *mut u8,
        decrypt: ::std::os::raw::c_int,
    );
}
pub const SWR_DITHER_NONE: SwrDitherType = 0;
pub const SWR_DITHER_RECTANGULAR: SwrDitherType = 1;
pub const SWR_DITHER_TRIANGULAR: SwrDitherType = 2;
pub const SWR_DITHER_TRIANGULAR_HIGHPASS: SwrDitherType = 3;
#[doc = "< not part of API/ABI"]
pub const SWR_DITHER_NS: SwrDitherType = 64;
pub const SWR_DITHER_NS_LIPSHITZ: SwrDitherType = 65;
pub const SWR_DITHER_NS_F_WEIGHTED: SwrDitherType = 66;
pub const SWR_DITHER_NS_MODIFIED_E_WEIGHTED: SwrDitherType = 67;
pub const SWR_DITHER_NS_IMPROVED_E_WEIGHTED: SwrDitherType = 68;
pub const SWR_DITHER_NS_SHIBATA: SwrDitherType = 69;
pub const SWR_DITHER_NS_LOW_SHIBATA: SwrDitherType = 70;
pub const SWR_DITHER_NS_HIGH_SHIBATA: SwrDitherType = 71;
#[doc = "< not part of API/ABI"]
pub const SWR_DITHER_NB: SwrDitherType = 72;
#[doc = " Dithering algorithms"]
pub type SwrDitherType = ::std::os::raw::c_uint;
#[doc = "< SW Resampler"]
pub const SWR_ENGINE_SWR: SwrEngine = 0;
#[doc = "< SoX Resampler"]
pub const SWR_ENGINE_SOXR: SwrEngine = 1;
#[doc = "< not part of API/ABI"]
pub const SWR_ENGINE_NB: SwrEngine = 2;
#[doc = " Resampling Engines"]
pub type SwrEngine = ::std::os::raw::c_uint;
#[doc = "< Cubic"]
pub const SWR_FILTER_TYPE_CUBIC: SwrFilterType = 0;
#[doc = "< Blackman Nuttall windowed sinc"]
pub const SWR_FILTER_TYPE_BLACKMAN_NUTTALL: SwrFilterType = 1;
#[doc = "< Kaiser windowed sinc"]
pub const SWR_FILTER_TYPE_KAISER: SwrFilterType = 2;
#[doc = " Resampling Filter Types"]
pub type SwrFilterType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the AVClass for SwrContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find().\n @return the AVClass of SwrContext"]
    pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Allocate SwrContext.\n\n If you use this function you will need to set the parameters (manually or\n with swr_alloc_set_opts2()) before calling swr_init().\n\n @see swr_alloc_set_opts2(), swr_init(), swr_free()\n @return NULL on error, allocated context otherwise"]
    pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
    #[doc = " Initialize context after user parameters have been set.\n @note The context must be configured using the AVOption API.\n\n @see av_opt_set_int()\n @see av_opt_set_dict()\n\n @param[in,out]   s Swr context to initialize\n @return AVERROR error code in case of failure."]
    pub fn swr_init(s: *mut SwrContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether an swr context has been initialized or not.\n\n @param[in]       s Swr context to check\n @see swr_init()\n @return positive if it has been initialized, 0 if not initialized"]
    pub fn swr_is_initialized(s: *mut SwrContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate SwrContext if needed and set/reset common parameters.\n\n This function does not require s to be allocated with swr_alloc(). On the\n other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters\n on the allocated context.\n\n @param s               existing Swr context if available, or NULL if not\n @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)\n @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).\n @param out_sample_rate output sample rate (frequency in Hz)\n @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)\n @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).\n @param in_sample_rate  input sample rate (frequency in Hz)\n @param log_offset      logging level offset\n @param log_ctx         parent logging context, can be NULL\n\n @see swr_init(), swr_free()\n @return NULL on error, allocated context otherwise\n @deprecated use @ref swr_alloc_set_opts2()"]
    pub fn swr_alloc_set_opts(
        s: *mut SwrContext,
        out_ch_layout: i64,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: ::std::os::raw::c_int,
        in_ch_layout: i64,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: ::std::os::raw::c_int,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut SwrContext;
}
extern "C" {
    #[doc = " Allocate SwrContext if needed and set/reset common parameters.\n\n This function does not require *ps to be allocated with swr_alloc(). On the\n other hand, swr_alloc() can use swr_alloc_set_opts2() to set the parameters\n on the allocated context.\n\n @param ps              Pointer to an existing Swr context if available, or to NULL if not.\n                        On success, *ps will be set to the allocated context.\n @param out_ch_layout   output channel layout (e.g. AV_CHANNEL_LAYOUT_*)\n @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).\n @param out_sample_rate output sample rate (frequency in Hz)\n @param in_ch_layout    input channel layout (e.g. AV_CHANNEL_LAYOUT_*)\n @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).\n @param in_sample_rate  input sample rate (frequency in Hz)\n @param log_offset      logging level offset\n @param log_ctx         parent logging context, can be NULL\n\n @see swr_init(), swr_free()\n @return 0 on success, a negative AVERROR code on error.\n         On error, the Swr context is freed and *ps set to NULL."]
    pub fn swr_alloc_set_opts2(
        ps: *mut *mut SwrContext,
        out_ch_layout: *const AVChannelLayout,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: ::std::os::raw::c_int,
        in_ch_layout: *const AVChannelLayout,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: ::std::os::raw::c_int,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the given SwrContext and set the pointer to NULL.\n\n @param[in] s a pointer to a pointer to Swr context"]
    pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
    #[doc = " Closes the context so that swr_is_initialized() returns 0.\n\n The context can be brought back to life by running swr_init(),\n swr_init() can also be used without swr_close().\n This function is mainly provided for simplifying the usecase\n where one tries to support libavresample and libswresample.\n\n @param[in,out] s Swr context to be closed"]
    pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
    #[doc = " Convert audio.\n\n in and in_count can be set to 0 to flush the last few samples out at the\n end.\n\n If more input is provided than output space, then the input will be buffered.\n You can avoid this buffering by using swr_get_out_samples() to retrieve an\n upper bound on the required number of output samples for the given number of\n input samples. Conversion will run directly without copying whenever possible.\n\n @param s         allocated Swr context, with parameters set\n @param out       output buffers, only the first one need be set in case of packed audio\n @param out_count amount of space available for output in samples per channel\n @param in        input buffers, only the first one need to be set in case of packed audio\n @param in_count  number of input samples available in one channel\n\n @return number of samples output per channel, negative value on error"]
    pub fn swr_convert(
        s: *mut SwrContext,
        out: *mut *mut u8,
        out_count: ::std::os::raw::c_int,
        in_: *mut *const u8,
        in_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert the next timestamp from input to output\n timestamps are in 1/(in_sample_rate * out_sample_rate) units.\n\n @note There are 2 slightly differently behaving modes.\n       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)\n              in this case timestamps will be passed through with delays compensated\n       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)\n              in this case the output timestamps will match output sample numbers.\n              See ffmpeg-resampler(1) for the two modes of compensation.\n\n @param[in] s     initialized Swr context\n @param[in] pts   timestamp for the next input sample, INT64_MIN if unknown\n @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are\n      function used internally for timestamp compensation.\n @return the output timestamp for the next output sample"]
    pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
    #[doc = " Activate resampling compensation (\"soft\" compensation). This function is\n internally called when needed in swr_next_pts().\n\n @param[in,out] s             allocated Swr context. If it is not initialized,\n                              or SWR_FLAG_RESAMPLE is not set, swr_init() is\n                              called with the flag set.\n @param[in]     sample_delta  delta in PTS per sample\n @param[in]     compensation_distance number of samples to compensate for\n @return    >= 0 on success, AVERROR error codes if:\n            @li @c s is NULL,\n            @li @c compensation_distance is less than 0,\n            @li @c compensation_distance is 0 but sample_delta is not,\n            @li compensation unsupported by resampler, or\n            @li swr_init() fails when called."]
    pub fn swr_set_compensation(
        s: *mut SwrContext,
        sample_delta: ::std::os::raw::c_int,
        compensation_distance: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a customized input channel mapping.\n\n @param[in,out] s           allocated Swr context, not yet initialized\n @param[in]     channel_map customized input channel mapping (array of channel\n                            indexes, -1 for a muted channel)\n @return >= 0 on success, or AVERROR error code in case of failure."]
    pub fn swr_set_channel_mapping(
        s: *mut SwrContext,
        channel_map: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a channel mixing matrix.\n\n This function is the one used internally by libswresample for building the\n default mixing matrix. It is made public just as a utility function for\n building custom matrices.\n\n @param in_layout           input channel layout\n @param out_layout          output channel layout\n @param center_mix_level    mix level for the center channel\n @param surround_mix_level  mix level for the surround channel(s)\n @param lfe_mix_level       mix level for the low-frequency effects channel\n @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent\n                            overflow. if INT_MAX, coefficients will not be\n                            normalized.\n @param[out] matrix         mixing coefficients; matrix[i + stride * o] is\n                            the weight of input channel i in output channel o.\n @param stride              distance between adjacent input channels in the\n                            matrix array\n @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)\n @param log_ctx             parent logging context, can be NULL\n @return                    0 on success, negative AVERROR code on failure\n @deprecated                use @ref swr_build_matrix2()"]
    pub fn swr_build_matrix(
        in_layout: u64,
        out_layout: u64,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        rematrix_maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: ::std::os::raw::c_int,
        matrix_encoding: AVMatrixEncoding,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a channel mixing matrix.\n\n This function is the one used internally by libswresample for building the\n default mixing matrix. It is made public just as a utility function for\n building custom matrices.\n\n @param in_layout           input channel layout\n @param out_layout          output channel layout\n @param center_mix_level    mix level for the center channel\n @param surround_mix_level  mix level for the surround channel(s)\n @param lfe_mix_level       mix level for the low-frequency effects channel\n @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent\n                            overflow. if INT_MAX, coefficients will not be\n                            normalized.\n @param[out] matrix         mixing coefficients; matrix[i + stride * o] is\n                            the weight of input channel i in output channel o.\n @param stride              distance between adjacent input channels in the\n                            matrix array\n @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)\n @param log_ctx             parent logging context, can be NULL\n @return                    0 on success, negative AVERROR code on failure"]
    pub fn swr_build_matrix2(
        in_layout: *const AVChannelLayout,
        out_layout: *const AVChannelLayout,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: isize,
        matrix_encoding: AVMatrixEncoding,
        log_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a customized remix matrix.\n\n @param s       allocated Swr context, not yet initialized\n @param matrix  remix coefficients; matrix[i + stride * o] is\n                the weight of input channel i in output channel o\n @param stride  offset between lines of the matrix\n @return  >= 0 on success, or AVERROR error code in case of failure."]
    pub fn swr_set_matrix(
        s: *mut SwrContext,
        matrix: *const f64,
        stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Drops the specified number of output samples.\n\n This function, along with swr_inject_silence(), is called by swr_next_pts()\n if needed for \"hard\" compensation.\n\n @param s     allocated Swr context\n @param count number of samples to be dropped\n\n @return >= 0 on success, or a negative AVERROR code on failure"]
    pub fn swr_drop_output(
        s: *mut SwrContext,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Injects the specified number of silence samples.\n\n This function, along with swr_drop_output(), is called by swr_next_pts()\n if needed for \"hard\" compensation.\n\n @param s     allocated Swr context\n @param count number of samples to be dropped\n\n @return >= 0 on success, or a negative AVERROR code on failure"]
    pub fn swr_inject_silence(
        s: *mut SwrContext,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the delay the next input sample will experience relative to the next output sample.\n\n Swresample can buffer data if more input has been provided than available\n output space, also converting between sample rates needs a delay.\n This function returns the sum of all such delays.\n The exact delay is not necessarily an integer value in either input or\n output sample rate. Especially when downsampling by a large value, the\n output sample rate may be a poor choice to represent the delay, similarly\n for upsampling and the input sample rate.\n\n @param s     swr context\n @param base  timebase in which the returned delay will be:\n              @li if it's set to 1 the returned delay is in seconds\n              @li if it's set to 1000 the returned delay is in milliseconds\n              @li if it's set to the input sample rate then the returned\n                  delay is in input samples\n              @li if it's set to the output sample rate then the returned\n                  delay is in output samples\n              @li if it's the least common multiple of in_sample_rate and\n                  out_sample_rate then an exact rounding-free delay will be\n                  returned\n @returns     the delay in 1 / @c base units."]
    pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
    #[doc = " Find an upper bound on the number of samples that the next swr_convert\n call will output, if called with in_samples of input samples. This\n depends on the internal state, and anything changing the internal state\n (like further swr_convert() calls) will may change the number of samples\n swr_get_out_samples() returns for the same number of input samples.\n\n @param in_samples    number of input samples.\n @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()\n       or swr_set_compensation() invalidates this limit\n @note it is recommended to pass the correct available buffer size\n       to all functions like swr_convert() even if swr_get_out_samples()\n       indicates that less would be used.\n @returns an upper bound on the number of samples that the next swr_convert\n          will output or a negative value to indicate an error"]
    pub fn swr_get_out_samples(
        s: *mut SwrContext,
        in_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the @ref LIBSWRESAMPLE_VERSION_INT constant.\n\n This is useful to check if the build-time libswresample has the same version\n as the run-time one.\n\n @returns     the unsigned int-typed version"]
    pub fn swresample_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the swr build-time configuration.\n\n @returns     the build-time @c ./configure flags"]
    pub fn swresample_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the swr license.\n\n @returns     the license of libswresample, determined at build-time"]
    pub fn swresample_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the samples in the input AVFrame and write them to the output AVFrame.\n\n Input and output AVFrames must have channel_layout, sample_rate and format set.\n\n If the output AVFrame does not have the data pointers allocated the nb_samples\n field will be set using av_frame_get_buffer()\n is called to allocate the frame.\n\n The output AVFrame can be NULL or have fewer allocated samples than required.\n In this case, any remaining samples not written to the output will be added\n to an internal FIFO buffer, to be returned at the next call to this function\n or to swr_convert().\n\n If converting sample rate, there may be data remaining in the internal\n resampling delay buffer. swr_get_delay() tells the number of\n remaining samples. To get this data as output, call this function or\n swr_convert() with NULL input.\n\n If the SwrContext configuration does not match the output and\n input AVFrame settings the conversion does not take place and depending on\n which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED\n or the result of a bitwise-OR of them is returned.\n\n @see swr_delay()\n @see swr_convert()\n @see swr_get_delay()\n\n @param swr             audio resample context\n @param output          output AVFrame\n @param input           input AVFrame\n @return                0 on success, AVERROR on failure or nonmatching\n                        configuration."]
    pub fn swr_convert_frame(
        swr: *mut SwrContext,
        output: *mut AVFrame,
        input: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure or reconfigure the SwrContext using the information\n provided by the AVFrames.\n\n The original resampling context is reset even on failure.\n The function calls swr_close() internally if the context is open.\n\n @see swr_close();\n\n @param swr             audio resample context\n @param out             output AVFrame\n @param in              input AVFrame\n @return                0 on success, AVERROR on failure."]
    pub fn swr_config_frame(
        swr: *mut SwrContext,
        out: *const AVFrame,
        in_: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup libsws libswscale\n Color conversion and scaling library.\n\n @{\n\n Return the LIBSWSCALE_VERSION_INT constant."]
    pub fn swscale_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libswscale build-time configuration."]
    pub fn swscale_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libswscale license."]
    pub fn swscale_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a pointer to yuv<->rgb coefficients for the given colorspace\n suitable for sws_setColorspaceDetails().\n\n @param colorspace One of the SWS_CS_* macros. If invalid,\n SWS_CS_DEFAULT is used."]
    pub fn sws_getCoefficients(colorspace: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsVector {
    #[doc = "< pointer to the list of coefficients"]
    pub coeff: *mut f64,
    #[doc = "< number of coefficients in the vector"]
    pub length: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SwsVector() {
    const UNINIT: ::std::mem::MaybeUninit<SwsVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SwsVector>(),
        16usize,
        concat!("Size of: ", stringify!(SwsVector))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsVector>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[test]
fn bindgen_test_layout_SwsFilter() {
    const UNINIT: ::std::mem::MaybeUninit<SwsFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SwsFilter>(),
        32usize,
        concat!("Size of: ", stringify!(SwsFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lumH) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lumV) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chrH) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chrV) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported input format, 0\n otherwise."]
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported output format, 0\n otherwise."]
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param[in]  pix_fmt the pixel format\n @return a positive value if an endianness conversion for pix_fmt is\n supported, 0 otherwise."]
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an empty SwsContext. This must be filled and passed to\n sws_init_context(). For filling see AVOptions, options.c and\n sws_setColorspaceDetails()."]
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    #[doc = " Initialize the swscaler context sws_context.\n\n @return zero or positive value on success, a negative value on\n error"]
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the swscaler context swsContext.\n If swsContext is NULL, then does nothing."]
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    #[doc = " Allocate and return an SwsContext. You need it to perform\n scaling/conversion operations using sws_scale().\n\n @param srcW the width of the source image\n @param srcH the height of the source image\n @param srcFormat the source image format\n @param dstW the width of the destination image\n @param dstH the height of the destination image\n @param dstFormat the destination image format\n @param flags specify which algorithm and options to use for rescaling\n @param param extra parameters to tune the used scaler\n              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n              function, param[0] tunes f(1) and param[1] f(1)\n              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n              frequency\n              For SWS_LANCZOS param[0] tunes the width of the window function\n @return a pointer to an allocated context, or NULL in case of error\n @note this function is to be removed after a saner alternative is\n       written"]
    pub fn sws_getContext(
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Scale the image slice in srcSlice and put the resulting scaled\n slice in the image in dst. A slice is a sequence of consecutive\n rows in an image.\n\n Slices have to be provided in sequential order, either in\n top-bottom or bottom-top order. If slices are provided in\n non-sequential order the behavior of the function is undefined.\n\n @param c         the scaling context previously created with\n                  sws_getContext()\n @param srcSlice  the array containing the pointers to the planes of\n                  the source slice\n @param srcStride the array containing the strides for each plane of\n                  the source image\n @param srcSliceY the position in the source image of the slice to\n                  process, that is the number (counted starting from\n                  zero) in the image of the first row of the slice\n @param srcSliceH the height of the source slice, that is the number\n                  of rows in the slice\n @param dst       the array containing the pointers to the planes of\n                  the destination image\n @param dstStride the array containing the strides for each plane of\n                  the destination image\n @return          the height of the output slice"]
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const ::std::os::raw::c_int,
        srcSliceY: ::std::os::raw::c_int,
        srcSliceH: ::std::os::raw::c_int,
        dst: *const *mut u8,
        dstStride: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Scale source data from src and write the output to dst.\n\n This is merely a convenience wrapper around\n - sws_frame_start()\n - sws_send_slice(0, src->height)\n - sws_receive_slice(0, dst->height)\n - sws_frame_end()\n\n @param c   The scaling context\n @param dst The destination frame. See documentation for sws_frame_start() for\n            more details.\n @param src The source frame.\n\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn sws_scale_frame(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the scaling process for a given pair of source/destination frames.\n Must be called before any calls to sws_send_slice() and sws_receive_slice().\n\n This function will retain references to src and dst, so they must both use\n refcounted buffers (if allocated by the caller, in case of dst).\n\n @param c   The scaling context\n @param dst The destination frame.\n\n            The data buffers may either be already allocated by the caller or\n            left clear, in which case they will be allocated by the scaler.\n            The latter may have performance advantages - e.g. in certain cases\n            some output planes may be references to input planes, rather than\n            copies.\n\n            Output data will be written into this frame in successful\n            sws_receive_slice() calls.\n @param src The source frame. The data buffers must be allocated, but the\n            frame data does not have to be ready at this point. Data\n            availability is then signalled by sws_send_slice().\n @return 0 on success, a negative AVERROR code on failure\n\n @see sws_frame_end()"]
    pub fn sws_frame_start(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finish the scaling process for a pair of source/destination frames previously\n submitted with sws_frame_start(). Must be called after all sws_send_slice()\n and sws_receive_slice() calls are done, before any new sws_frame_start()\n calls.\n\n @param c   The scaling context"]
    pub fn sws_frame_end(c: *mut SwsContext);
}
extern "C" {
    #[doc = " Indicate that a horizontal slice of input data is available in the source\n frame previously provided to sws_frame_start(). The slices may be provided in\n any order, but may not overlap. For vertically subsampled pixel formats, the\n slices must be aligned according to subsampling.\n\n @param c   The scaling context\n @param slice_start first row of the slice\n @param slice_height number of rows in the slice\n\n @return a non-negative number on success, a negative AVERROR code on failure."]
    pub fn sws_send_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a horizontal slice of the output data to be written into the frame\n previously provided to sws_frame_start().\n\n @param c   The scaling context\n @param slice_start first row of the slice; must be a multiple of\n                    sws_receive_slice_alignment()\n @param slice_height number of rows in the slice; must be a multiple of\n                     sws_receive_slice_alignment(), except for the last slice\n                     (i.e. when slice_start+slice_height is equal to output\n                     frame height)\n\n @return a non-negative number if the data was successfully written into the output\n         AVERROR(EAGAIN) if more input data needs to be provided before the\n                         output can be produced\n         another negative AVERROR code on other kinds of scaling failure"]
    pub fn sws_receive_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the alignment required for slices\n\n @param c   The scaling context\n @return alignment required for output slices requested with sws_receive_slice().\n         Slice offsets and sizes passed to sws_receive_slice() must be\n         multiples of the value returned from this function."]
    pub fn sws_receive_slice_alignment(c: *const SwsContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @param c the scaling context\n @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n @param brightness 16.16 fixed point brightness correction\n @param contrast 16.16 fixed point contrast correction\n @param saturation 16.16 fixed point saturation correction\n\n @return A negative error code on error, non negative otherwise.\n         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported."]
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const ::std::os::raw::c_int,
        srcRange: ::std::os::raw::c_int,
        table: *const ::std::os::raw::c_int,
        dstRange: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        saturation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return A negative error code on error, non negative otherwise.\n         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported."]
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut ::std::os::raw::c_int,
        srcRange: *mut ::std::os::raw::c_int,
        table: *mut *mut ::std::os::raw::c_int,
        dstRange: *mut ::std::os::raw::c_int,
        brightness: *mut ::std::os::raw::c_int,
        contrast: *mut ::std::os::raw::c_int,
        saturation: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and return an uninitialized vector with length coefficients."]
    pub fn sws_allocVec(length: ::std::os::raw::c_int) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Return a normalized Gaussian curve used to filter stuff\n quality = 3 is high quality, lower is lower quality."]
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Scale all the coefficients of a by the scalar value."]
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    #[doc = " Scale all the coefficients of a so that their sum equals height."]
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: ::std::os::raw::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    #[doc = " Check if context can be reused, otherwise reallocate a new one.\n\n If context is NULL, just calls sws_getContext() to get a new\n context. Otherwise, checks if the parameters are the ones already\n saved in context. If that is the case, returns the current\n context. Otherwise, frees context and gets a new context with\n the new parameters.\n\n Be warned that srcFilter and dstFilter are not checked, they\n are assumed to remain the same."]
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n\n The output frame will have the same packed format as the palette.\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n\n With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Get the AVClass for swsContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn sws_get_class() -> *const AVClass;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = " Private context used for internal data.\n\n Unlike priv_data, this is not codec-specific. It is used in general\n libavcodec functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct URLContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterCommand {
    pub _address: u8,
}
